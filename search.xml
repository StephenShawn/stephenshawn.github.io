<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>在Nodejs中使用 Playwright</title>
    <url>/2025/02/03/automate/Playwright/</url>
    <content><![CDATA[<p>首先，确保你已经安装了 <strong>Node.js</strong>。可以通过以下命令来检查是否已经安装 Node.js：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure>

<p>如果没有安装 Node.js，你可以从 <a href="https://nodejs.org/">Node.js 官网</a> 下载并安装最新版本的 Node.js。</p>
<h3 id="2-初始化-Node-js-项目"><a href="#2-初始化-Node-js-项目" class="headerlink" title="2. 初始化 Node.js 项目"></a>2. <strong>初始化 Node.js 项目</strong></h3><p>如果你还没有创建 Node.js 项目，可以通过以下命令初始化一个新的 Node.js 项目：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> my-playwright-project</span><br><span class="line"><span class="built_in">cd</span> my-playwright-project</span><br><span class="line">npm init -y</span><br></pre></td></tr></table></figure>

<p>这将会创建一个 <code>package.json</code> 文件，管理你的项目依赖。</p>
<h3 id="3-安装-Playwright"><a href="#3-安装-Playwright" class="headerlink" title="3. 安装 Playwright"></a>3. <strong>安装 Playwright</strong></h3><p>你可以使用 <strong>npm</strong> 或 <strong>yarn</strong> 来安装 Playwright。执行以下命令安装 Playwright 和浏览器依赖：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install playwright</span><br></pre></td></tr></table></figure>

<p>默认情况下，Playwright 会安装必要的浏览器二进制文件（Chromium、Firefox 和 WebKit），因此它会比较大。如果你只需要安装特定的浏览器，你可以选择安装指定的浏览器包：</p>
<ul>
<li><p><strong>只安装 Chromium</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install playwright-chromium</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只安装 Firefox</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install playwright-firefox</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>只安装 WebKit</strong>:</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">npm install playwright-webkit</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="4-验证安装"><a href="#4-验证安装" class="headerlink" title="4. 验证安装"></a>4. <strong>验证安装</strong></h3><p>安装完成后，你可以创建一个简单的脚本来测试 Playwright 是否工作正常：</p>
<p>创建一个文件 <code>test.js</code>，并添加以下内容：</p>
<figure class="highlight javascript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; chromium &#125; = <span class="built_in">require</span>(<span class="string">&quot;playwright&quot;</span>);</span><br><span class="line"></span><br><span class="line">(<span class="title function_">async</span> () =&gt; &#123;</span><br><span class="line">  <span class="comment">// 启动浏览器</span></span><br><span class="line">  <span class="keyword">const</span> browser = <span class="keyword">await</span> chromium.<span class="title function_">launch</span>(&#123; <span class="attr">headless</span>: <span class="literal">false</span> &#125;);</span><br><span class="line">  <span class="keyword">const</span> page = <span class="keyword">await</span> browser.<span class="title function_">newPage</span>();</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 打开一个页面</span></span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">goto</span>(<span class="string">&quot;https://example.com&quot;</span>);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 截图保存</span></span><br><span class="line">  <span class="keyword">await</span> page.<span class="title function_">screenshot</span>(&#123; <span class="attr">path</span>: <span class="string">&quot;example.png&quot;</span> &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 关闭浏览器</span></span><br><span class="line">  <span class="keyword">await</span> browser.<span class="title function_">close</span>();</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>

<p>然后，运行脚本：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">node test.js</span><br></pre></td></tr></table></figure>

<p>如果一切正常，Playwright 会启动一个 Chromium 浏览器实例并打开 <code>https://example.com</code>，然后保存页面截图为 <code>example.png</code>。</p>
<h3 id="5-常见问题"><a href="#5-常见问题" class="headerlink" title="5. 常见问题"></a>5. <strong>常见问题</strong></h3><ul>
<li>如果你在安装过程中遇到浏览器二进制文件下载失败的情况，确保你的网络连接正常，并且没有防火墙或代理阻止下载。</li>
<li>Playwright 会在安装时自动下载 Chromium、Firefox 和 WebKit。如果你不需要某个浏览器，可以手动卸载它们，或者仅安装你需要的特定浏览器。</li>
</ul>
<hr>
<p>通过这些步骤，你就可以在 Node.js 环境中成功安装并使用 Playwright 进行浏览器自动化操作。</p>
]]></content>
      <categories>
        <category>broswer-automate</category>
      </categories>
      <tags>
        <tag>Playwright</tag>
      </tags>
  </entry>
  <entry>
    <title>数据库SQL语言</title>
    <url>/2022/07/14/database/MysqlSQL/</url>
    <content><![CDATA[<ol>
<li>DDL (Data Definition Language): 数据定义语言</li>
<li>DML (Data Manipulation Language)：数据操作语言</li>
<li>DCL (Data Control Language): 数据控制语言</li>
<li>DQL (Data Query Language): 数据查询语言</li>
</ol>
<ul>
<li>ddl：数据库或表的结构操作(****)</li>
<li>dml：对表的记录进行更新(增、删、改)(****)</li>
<li>dql：对表的记录的查询(****，难点)</li>
<li>dcl：对用户的创建及授权(****)</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h4><ul>
<li><p>查看所有数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE DATABASENAME</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> MYDB CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AlTER</span> DATABASE MYDB CHARSET <span class="keyword">SET</span> utf8 </span><br></pre></td></tr></table></figure></li>
<li><p>删除数据库</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database MYDB</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>int：整型;</li>
<li>double ：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</li>
<li>decimal：浮点型 ，在表单钱方面使用该类型，因为不会出现精度缺失问题；</li>
<li>char：固定长度字符串类型，char(255);</li>
<li>varchar: 可变字符串类型：varchar(65535);</li>
<li>text(clob):字符串类型；</li>
</ul>
<ol>
<li>tinytext 2^8-1 Byte</li>
<li>text 2^16-1 Byte</li>
<li>mediumtext 2^24-1 Byte</li>
<li>longtext 2^34-1 Byte</li>
</ol>
<ul>
<li>blob ：字节类型；</li>
</ul>
<ol>
<li>tinyblob 2^8-1 Byte</li>
<li>blob 2^16-1 Byte</li>
<li>mediumblob 2^24-1 Byte</li>
<li>longblob 2^34-1 Byte</li>
</ol>
<ul>
<li>date：日期类型，格式为：yyyy-MM-dd;</li>
<li>time: 时间类型 格式为：hh:mm:ss</li>
<li>timestamp: 时间戳类型；</li>
</ul>
<h4 id="二、表"><a href="#二、表" class="headerlink" title="二、表"></a>二、表</h4><ul>
<li>创建表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] TABLENAME (cloumn01 type01,cloumn02 type02,cloumn03 type03);</span><br></pre></td></tr></table></figure></li>
<li>查看当前数据库中所有表名称：SHOW TABLES;</li>
<li>查看指定表的创建语句：SHOW CREATE TABLE 表名(了解)；</li>
<li>查看表结构：DESC 表名;</li>
<li>删除表结构：DROP TABLE 表名;</li>
<li>修改表：前缀：ALTER TABLE 表名;</li>
</ul>
<ol>
<li>修改之添加列：<br> AlTER TABLE 表名 ADD （<br> 列名 列类型，<br> 列名 列类型，<br> …<br> ）</li>
<li>修改列类型（如果被修改的列已存在数据，那么新的列类型可能会影响到已存在数据）：ALTER TABLE 表名 MODIFY 列名 列类型</li>
<li>修改列名：ALTER TABLE 表名 CHANGE 原列名 新列名 新类型</li>
<li>删除列：ALTER TABLE 表名 DROP 列名</li>
<li>修改表名称：ALTER TABLE 原表名 RENAME TO 新表名</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><ul>
<li>添加表记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT INTO</span> tableName (c1,c2,c3)<span class="keyword">values</span>(v1,v2,v3);</span><br></pre></td></tr></table></figure></li>
<li>修改表记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tableName <span class="keyword">set</span> c1 <span class="operator">=</span> v1,c2 <span class="operator">=</span> v2;</span><br><span class="line"><span class="keyword">update</span> tableName <span class="keyword">set</span> c1 <span class="operator">=</span> v1,c2 <span class="operator">=</span> v2 <span class="keyword">where</span> c3 <span class="operator">=</span> v3 <span class="keyword">or</span> c4 <span class="operator">=</span> v4;</span><br><span class="line"><span class="keyword">delete</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> gender <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><ul>
<li>一个项目创建一个用户！一个项目对应的数据库只有一个！</li>
<li>这个用户只能对这个数据库有权限，其他数据库不能操作</li>
</ul>
<ol>
<li>创建用户</li>
</ol>
<ul>
<li>在指定的IP地址上登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> username<span class="variable">@IP</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在任意的IP地址上登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> username@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>给用户授权<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 部分权限授权</span></span><br><span class="line"> <span class="keyword">GRANT</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> shawn<span class="variable">@IP</span></span><br><span class="line"><span class="comment">-- 所有权限授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
<li>撤销授权<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">FROM</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
<li>查看权限<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
<li>删除用户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tableName;</span><br></pre></td></tr></table></figure>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFNUll(c1,v1);</span><br><span class="line">DATE_FORMAT(&quot;yyyy-MM-dd&quot;,&#x27;%Y-%m-%d&#x27;);</span><br><span class="line">CONCAT(v1,v2,v3);</span><br><span class="line">distinct;</span><br><span class="line">-- &#x27;_&#x27;匹配一个字符</span><br><span class="line">-- &#x27;%&#x27;匹配零个到N个字符</span><br><span class="line">like &#x27;_%&#x27;;</span><br><span class="line">-- （当前页-1）* 每页记录数</span><br><span class="line">limit (17-1)*8,8</span><br></pre></td></tr></table></figure>

<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><h4 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h4>]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql与MariaDB</title>
    <url>/2022/09/16/database/Mysql%E4%B8%8EMariaDB/</url>
    <content><![CDATA[<h1 id="MariaDB和MySQL全面对比"><a href="#MariaDB和MySQL全面对比" class="headerlink" title="MariaDB和MySQL全面对比"></a><a href="https://zhuanlan.zhihu.com/p/43993816">MariaDB和MySQL全面对比</a></h1>]]></content>
      <categories>
        <category>MariaDB</category>
      </categories>
      <tags>
        <tag>Mysql与MariaDB区别</tag>
      </tags>
  </entry>
  <entry>
    <title>浏览器自动化测试</title>
    <url>/2025/02/03/automate/automates/</url>
    <content><![CDATA[<h3 id="一、Playwright"><a href="#一、Playwright" class="headerlink" title="一、Playwright"></a>一、Playwright</h3><p>Playwright 是用 <strong>TypeScript</strong>（JavaScript 的超集）编写的。TypeScript 提供了静态类型检查，增强了 Playwright 的可维护性和开发体验。Playwright 的核心代码和 API 基于 Node.js 环境，因此它是一个主要面向 <strong>JavaScript&#x2F;TypeScript</strong> 开发者的工具。</p>
<p>然而，Playwright 并不仅仅限于 JavaScript 和 TypeScript，它提供了 <strong>多语言绑定</strong>，使得开发者可以使用其他编程语言来操作 Playwright。除了 TypeScript 和 JavaScript，Playwright 还支持以下语言：</p>
<ul>
<li><strong>Python</strong>：通过 Playwright 的 Python 库，你可以使用 Python 编写自动化脚本。</li>
<li>**C#**：Playwright 为 C# 开发者提供了相应的库和接口。</li>
<li><strong>Java</strong>：Playwright 也提供了 Java 语言的绑定，允许 Java 开发者使用 Playwright 进行浏览器自动化。</li>
</ul>
<h3 id="语言支持的绑定："><a href="#语言支持的绑定：" class="headerlink" title="语言支持的绑定："></a>语言支持的绑定：</h3><ol>
<li><strong>TypeScript&#x2F;JavaScript</strong>：最原生的支持，因为 Playwright 本身是用 TypeScript 开发的。</li>
<li><strong>Python</strong>：提供了 Python 绑定，可以方便地在 Python 环境中使用 Playwright。</li>
<li>**C#**：Playwright 为 C# 开发者提供了 SDK 和 API。</li>
<li><strong>Java</strong>：Playwright 同样支持 Java 环境的使用，提供了相应的 API。</li>
</ol>
<p>总结来说，Playwright 的核心是使用 <strong>TypeScript</strong> 编写的，但它的多语言支持使得开发者可以根据自己的需求选择不同的编程语言来使用该工具。</p>
<h3 id="二、Selenium"><a href="#二、Selenium" class="headerlink" title="二、Selenium"></a>二、Selenium</h3><p>Selenium 是用 <strong>Java</strong> 编写的核心库，但它支持多种编程语言，包括 Java、Python、C#、Ruby、JavaScript（Node.js）等。Selenium 提供了多种语言的绑定（API），这样开发者可以使用自己熟悉的编程语言与 Selenium 进行交互。</p>
<h3 id="主要组成部分："><a href="#主要组成部分：" class="headerlink" title="主要组成部分："></a>主要组成部分：</h3><ol>
<li><strong>Selenium WebDriver</strong>：<ul>
<li>这是 Selenium 最核心的部分，负责与浏览器进行交互。</li>
<li>WebDriver 本身是用 Java 编写的，但可以通过语言绑定支持多种编程语言。</li>
</ul>
</li>
<li><strong>Selenium Grid</strong>：<ul>
<li>用于并行化测试和跨多个机器执行。</li>
<li>Selenium Grid 也是用 Java 编写的。</li>
</ul>
</li>
<li><strong>Selenium IDE</strong>：<ul>
<li>一个用于录制和回放测试脚本的工具，最初是作为 Firefox 插件开发的，后来支持 Chrome。</li>
<li>IDE 也是基于 JavaScript 和其他前端技术的。</li>
</ul>
</li>
</ol>
<h3 id="支持的编程语言："><a href="#支持的编程语言：" class="headerlink" title="支持的编程语言："></a>支持的编程语言：</h3><ul>
<li><strong>Java</strong>：最早的 Selenium 版本是用 Java 开发的，提供了最完整的功能和最广泛的社区支持。</li>
<li><strong>Python</strong>：提供了 Python 语言的绑定，适用于使用 Python 编写自动化脚本的开发者。</li>
<li>**C#**：C# 开发者可以使用 Selenium 提供的 C# 语言绑定进行自动化操作。</li>
<li><strong>Ruby</strong>：Selenium 同样提供了 Ruby 绑定，适合 Ruby 开发者。</li>
<li>**JavaScript (Node.js)**：Selenium 也支持 JavaScript 和 Node.js 环境，适合现代 Web 开发的自动化测试。</li>
</ul>
<p>总结来说，<strong>Selenium WebDriver</strong> 的核心部分是用 Java 编写的，但它提供了多种语言的接口，使得开发者可以使用不同的编程语言进行自动化测试或爬虫开发。</p>
]]></content>
      <categories>
        <category>broswer-automate</category>
      </categories>
      <tags>
        <tag>浏览器自动化测试</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习大纲</title>
    <url>/2022/06/28/database/docker%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h3 id="Docker-network-（容器网络）"><a href="#Docker-network-（容器网络）" class="headerlink" title="Docker network （容器网络）"></a>Docker network （容器网络）</h3><h3 id="Docker-compose（容器编排）"><a href="#Docker-compose（容器编排）" class="headerlink" title="Docker compose（容器编排）"></a>Docker compose（容器编排）</h3><h3 id="Docker-Swarm（集群）"><a href="#Docker-Swarm（集群）" class="headerlink" title="Docker Swarm（集群）"></a>Docker Swarm（集群）</h3><h3 id="CI-CD-jenkins-流水线"><a href="#CI-CD-jenkins-流水线" class="headerlink" title="CI&#x2F;CD jenkins (流水线)"></a>CI&#x2F;CD jenkins (流水线)</h3><h3 id="ansible-自动化工具，部署"><a href="#ansible-自动化工具，部署" class="headerlink" title="ansible (自动化工具，部署)"></a><a href="http://ansible.com.cn/docs">ansible</a> (自动化工具，部署)</h3>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker学习大纲</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装mysql</title>
    <url>/2022/07/15/database/docker%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> docker run -d -p 3306:3306 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /opt/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /opt/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /opt/mysql/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql01 mysql:5.7 \</span><br><span class="line">--character-set-server=utf8mb4 \</span><br><span class="line">--collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的基本命令</title>
    <url>/2022/06/27/database/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><h3 id="一、帮助命令"><a href="#一、帮助命令" class="headerlink" title="一、帮助命令"></a>一、帮助命令</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version # 显示docker的版本</span><br><span class="line">docker info </span><br><span class="line">docker 命令 --help # 万能命令</span><br></pre></td></tr></table></figure>

<h3 id="二、镜像命令"><a href="#二、镜像命令" class="headerlink" title="二、镜像命令"></a>二、镜像命令</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像</span></span><br><span class="line">docker images  # 列出所有镜像</span><br><span class="line">docker images -a</span><br><span class="line">docker images -aq # 只显示镜像id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search --filter=STARS=3000 #搜索镜像star大于3000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull 镜像[:tag] # 如果不写tag 默认是 latest</span><br><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete  # 分层下载，docker image的核心 联合文件系统</span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 #签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest #真实地址</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi -f 容器id # 删除指定的镜像</span><br><span class="line">docker rmi -f 容器id 容器id 容器id # 删除多个的镜像</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部镜像</span><br></pre></td></tr></table></figure>

<h3 id="三、容器命令"><a href="#三、容器命令" class="headerlink" title="三、容器命令"></a>三、容器命令</h3><h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器</span><br><span class="line">-d 后台运行方式</span><br><span class="line">-it 使用交互式运行 进入容器查看内容</span><br><span class="line">-p 指定容器的端口 -p 8080:8080</span><br><span class="line">	—P 主机端口：容器端口 </span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-P 随机端口</span><br></pre></td></tr></table></figure>

<h4 id="列出所有的运行的容器"><a href="#列出所有的运行的容器" class="headerlink" title="列出所有的运行的容器"></a>列出所有的运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps 命令</span></span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">列出当前正在运行的容器</span></span><br><span class="line">-a # 列出当前正在运行的容器+带历史运行过的容器</span><br><span class="line">-n=? # 最近创建过的容器</span><br><span class="line">-q # 只显示容器的编号</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@localhost ~]# docker ps -aq</span><br><span class="line">1a8af1ce6330</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                            PORTS     NAMES</span><br><span class="line">1a8af1ce6330   centos    &quot;/bin/bash&quot;   12 minutes ago   Exited (127) About a minute ago             zealous_bartik</span><br></pre></td></tr></table></figure>

<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit #直接容器停止并退出</span><br><span class="line">Ctrl + P + Q #容器不停止退出</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id       			# 删除指定容器</span><br><span class="line">docker rm -f $(docker ps -aq)	 # 删除全部容器</span><br><span class="line">docker ps -a -q|xargs docker run # 删除全部容器（linux命令）</span><br></pre></td></tr></table></figure>

<h4 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id</span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></table></figure>

<h3 id="四、常用其他命令"><a href="#四、常用其他命令" class="headerlink" title="四、常用其他命令"></a>四、常用其他命令</h3><h5 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -d 镜像名</span></span><br><span class="line">[root@localhost ~]# docker run -d centos</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">问题docker ps ，发现 centos 停止了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑， docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己编写一段shell脚本</span></span><br><span class="line">[root@localhost ~]# docker run -d centos /bin/sh -c &quot;while true; do echo test;sleep 1;done&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前在运行的容器</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">9916a0298bfd   centos    &quot;/bin/sh -c &#x27;while t…&quot;   19 seconds ago   Up 18 seconds             condescending_curie</span><br><span class="line">113e7bdad55e   centos    &quot;/bin/bash&quot;              12 minutes ago   Up 12 minutes             serene_pasteur</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示日志</span></span><br><span class="line">-tf </span><br><span class="line">--tail number # 要显示日志的条数</span><br><span class="line">[root@localhost ~]# docker logs -f -t --tail 10  113e7bdad55e</span><br></pre></td></tr></table></figure>

<h5 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker top 容器<span class="built_in">id</span></span></span><br><span class="line">[root@localhost ~]# docker top 9916a0298bfd</span><br><span class="line">UID                 PID                 PPID                C                   STIME     </span><br><span class="line">root                180675              180655              0                   20:05      root                183113              180675              0                   20:44     </span><br></pre></td></tr></table></figure>

<h5 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker inspect 容器<span class="built_in">id</span></span></span><br><span class="line">[root@localhost ~]# docker inspect 9916a0298bfd </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-03-23T00:05:18.49632074Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true; do echo test;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 180675,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2022-03-23T00:05:19.263635448Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/condescending_curie&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3-init/diff:/var/lib/docker/overlay2/e75ba16da0fef020c7930a9b6190dbd33a83a8324702c144c689c5cd4e323146/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;9916a0298bfd&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true; do echo test;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;f28f51fd2c85ab7e8ba88827ec901c9ef4b517428747bd1cdf5196810db622c7&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/f28f51fd2c85&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;41b020afb72dc9602f5a030e56d816692170c2f0427377829da822e62976732a&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;d91d646c67beba9f1d4aa5cfa191bad1f24cf153ae1c6e3a37cf34599502a27f&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;41b020afb72dc9602f5a030e56d816692170c2f0427377829da822e62976732a&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS             PORTS     NAMES</span><br><span class="line">9916a0298bfd   centos    &quot;/bin/sh -c &#x27;while t…&quot;   About an hour ago   Up About an hour             condescending_curie</span><br><span class="line">113e7bdad55e   centos    &quot;/bin/bash&quot;              About an hour ago   Up About an hour             serene_pasteur</span><br><span class="line">[root@localhost ~]# docker exec -it 9916a0298bfd /bin/bash</span><br><span class="line">[root@9916a0298bfd /]# ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 00:05 ?        00:00:01 /bin/sh -c while true; do echo test;sleep 1;done</span><br><span class="line">root        4061       0  0 01:12 pts/0    00:00:00 /bin/bash</span><br><span class="line">root        4088       1  0 01:12 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">root        4089    4061  0 01:12 pts/0    00:00:00 ps -ef</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line">正在执行当前的代码...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span>     <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach	  <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure>

<h5 id="从容器内烤贝文件到主机上"><a href="#从容器内烤贝文件到主机上" class="headerlink" title="从容器内烤贝文件到主机上"></a>从容器内烤贝文件到主机上</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker cp  b4bb1f3f7685:/home/test.java /home</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入docker容器内</span></span><br><span class="line">[root@b4bb1f3f7685 /]# cd /home</span><br><span class="line">[root@b4bb1f3f7685 home]# ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建java文件</span></span><br><span class="line">[root@b4bb1f3f7685 home]# touch test.java</span><br><span class="line">[root@b4bb1f3f7685 home]# ls</span><br><span class="line">test.java</span><br><span class="line">[root@b4bb1f3f7685 home]# exit</span><br><span class="line">exit</span><br><span class="line">docker cp 容器id:容器内部路径 目的的主路径</span><br><span class="line">[root@localhost home]# docker cp  b4bb1f3f7685:/home/test.java /home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">shawn  test.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五、安装服务器软件"><a href="#五、安装服务器软件" class="headerlink" title="五、安装服务器软件"></a>五、安装服务器软件</h3><h5 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方的使用</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> tomcat:9.0</span><br><span class="line"><span class="comment"># 我们之前的启动都是后台，停止了容器之后，容器还是可以查到 docker run -it --rm 一般用来测试，用完就删除</span></span><br><span class="line"><span class="comment">#下载在启动</span></span><br><span class="line">docker pull tomcat:9.0</span><br></pre></td></tr></table></figure>

<h5 id="安装es-kibana"><a href="#安装es-kibana" class="headerlink" title="安装es+kibana"></a>安装es+kibana</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口很多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 十分的耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般需要放置到安全目录 挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--net somenetwork 网路配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 elasticsearch</span></span><br><span class="line">[root@localhost ~]# docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动了 linux就卡住了 docker stats 查看cpu的状态</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 是十分耗内存的 1.xG   1核2G</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker stats</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试一下es是否成功了</span></span><br><span class="line">[root@localhost ~]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;6620e2b536c4&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;9i4LLjxvTVKf46Hp1qHkqA&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.6.2&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.4.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赶紧关闭，增加内存的限制,修改配置文件 -e 环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>

<h5 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h5><blockquote>
<p>docker 图形化界面管理工具！提供一个后台供我们操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -p 8090:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker的基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装oracle</title>
    <url>/2022/07/15/database/docker%E5%AE%89%E8%A3%85oracle/</url>
    <content><![CDATA[<h1 id="docker安装oracle"><a href="#docker安装oracle" class="headerlink" title="docker安装oracle"></a><a href="https://zhuanlan.zhihu.com/p/443324194">docker安装oracle</a></h1><h3 id="1、安装docker环境。"><a href="#1、安装docker环境。" class="headerlink" title="1、安装docker环境。"></a>1、安装docker环境。</h3><h3 id="2、开始拉取oracle镜像"><a href="#2、开始拉取oracle镜像" class="headerlink" title="2、开始拉取oracle镜像"></a>2、开始拉取oracle镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure>

<h3 id="3、下载完成后，查看镜像"><a href="#3、下载完成后，查看镜像" class="headerlink" title="3、下载完成后，查看镜像"></a>3、下载完成后，查看镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="4、创建容器"><a href="#4、创建容器" class="headerlink" title="4、创建容器"></a>4、创建容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure>

<p>可以写成shell脚本，下次打开oracle数据库就可以一条命令创建容器。</p>
<p>shell脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN ANSIBLE MANAGED BLOCK</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">docker <span class="built_in">rm</span> -f oracle11;</span><br><span class="line">docker run -it -d -p 1521:1521</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /opt/oracle/oradata/dbs:/home/oracle/app/oracle/product/11.2.0/dbhome_2/dbs \</span><br><span class="line">-v /opt/oracle/oradata:/home/oracle/app/oracle/oradata \</span><br><span class="line">-e ORACLE_PWD=helowin --name oracle11 registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br><span class="line"><span class="comment"># END ANSIBLE MANAGED BLOCK</span></span><br></pre></td></tr></table></figure>



<p><strong>但为了保存上一次容易的配置值，是不建议写这个shell脚本的，下次打开直接用docker start oracle11命令打开。</strong></p>
<p>如果创建成功能会返回容器id</p>
<h3 id="5、进入镜像进行配置"><a href="#5、进入镜像进行配置" class="headerlink" title="5、进入镜像进行配置"></a>5、进入镜像进行配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it oracle11 bash</span><br></pre></td></tr></table></figure>

<h3 id="6、进行sql登录"><a href="#6、进行sql登录" class="headerlink" title="6、进行sql登录"></a>6、进行sql登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure>

<p>发现没有该命令，需要先配置环境变量，所以切换root用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root </span><br></pre></td></tr></table></figure>

<p>输入密码：helowin</p>
<h3 id="7、编辑profile文件配置ORACLE环境变量"><a href="#7、编辑profile文件配置ORACLE环境变量" class="headerlink" title="7、编辑profile文件配置ORACLE环境变量"></a>7、编辑profile文件配置ORACLE环境变量</h3><p>打开：vi &#x2F;etc&#x2F;profile ，在文件最后写上下面内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2</span><br><span class="line"><span class="built_in">export</span> ORACLE_SID=helowin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ORACLE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="8、保存后执行source-etc-profile-加载环境变量；"><a href="#8、保存后执行source-etc-profile-加载环境变量；" class="headerlink" title="8、保存后执行source /etc/profile 加载环境变量；"></a>8、保存后执行<code>source /etc/profile</code> 加载环境变量；</h3><h3 id="9、创建软连接"><a href="#9、创建软连接" class="headerlink" title="9、创建软连接"></a>9、创建软连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s <span class="variable">$ORACLE_HOME</span>/bin/sqlplus /usr/bin</span><br></pre></td></tr></table></figure>

<h3 id="10、切换到oracle-用户"><a href="#10、切换到oracle-用户" class="headerlink" title="10、切换到oracle 用户"></a>10、切换到oracle 用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - oracle</span><br></pre></td></tr></table></figure>



<p><em>这里还要说一下，一定要写中间的短横线 - 必须要，否则软连接无效</em></p>
<h3 id="11、登录sqlplus并修改sys、system用户密码"><a href="#11、登录sqlplus并修改sys、system用户密码" class="headerlink" title="11、登录sqlplus并修改sys、system用户密码"></a>11、登录sqlplus并修改sys、system用户密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span>nolog   <span class="comment">--登录</span></span><br><span class="line">conn <span class="operator">/</span><span class="keyword">as</span> sysdba  <span class="comment">--</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> identified <span class="keyword">by</span> <span class="keyword">system</span>;<span class="comment">--修改system用户账号密码；</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys identified <span class="keyword">by</span> <span class="keyword">system</span>;<span class="comment">--修改sys用户账号密码；</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> test identified <span class="keyword">by</span> test; <span class="comment">-- 创建内部管理员账号密码；</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>,resource,dba <span class="keyword">to</span> yan_test; <span class="comment">--将dba权限授权给内部管理员账号和密码；</span></span><br><span class="line"><span class="keyword">ALTER</span> PROFILE <span class="keyword">DEFAULT</span> LIMIT PASSWORD_LIFE_TIME UNLIMITED; <span class="comment">--修改密码规则策略为密码永不过期；（会出现坑，后面讲解）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> processes<span class="operator">=</span><span class="number">1000</span> <span class="keyword">scope</span><span class="operator">=</span>spfile; <span class="comment">--修改数据库最大连接数据；</span></span><br></pre></td></tr></table></figure>

<h3 id="12、修改以上信息后，需要重新启动数据库；"><a href="#12、修改以上信息后，需要重新启动数据库；" class="headerlink" title="12、修改以上信息后，需要重新启动数据库；"></a>12、修改以上信息后，需要重新启动数据库；</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn /as sysdba</span><br><span class="line">shutdown immediate; --关闭数据库</span><br><span class="line">startup; --启动数据库</span><br><span class="line">exit：退出软链接</span><br></pre></td></tr></table></figure>

<hr>
<p>*<strong>上面提到的其中一个坑说明：*</strong></p>
<p>当执行修改密码的时候出现 ： database not open</p>
<p>提示数据库没有打开，不急按如下操作</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>

<p>注意了：这里也许还会提示 ： ORA-01507: database not mounted</p>
<p><strong>解决办法：</strong></p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database mount;</span><br></pre></td></tr></table></figure>

<p>输入 ：alter database open;</p>
<p>然后就可执行 修改数据库密码的命令了</p>
<p>改完之后输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> PROFILE <span class="keyword">DEFAULT</span> LIMIT PASSWORD_LIFE_TIME UNLIMITED;</span><br></pre></td></tr></table></figure>

<p><strong>刷新下表 exit 是退出sql 软连接</strong></p>
<h3 id="13、复制oracle的数据及配置"><a href="#13、复制oracle的数据及配置" class="headerlink" title="13、复制oracle的数据及配置"></a>13、复制oracle的数据及配置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo docker cp <span class="built_in">id</span>:/home/oracle/app/oracle /opt/oracle</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像讲解</title>
    <url>/2022/06/28/database/docker%E9%95%9C%E5%83%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><ul>
<li>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时，库、环境变量和配置文件。</li>
<li>所有的应用，直接打包docker镜像，就可以直接跑起来！</li>
<li>如何得到镜像：<ol>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像DockerFile</li>
</ol>
</li>
</ul>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote>
<p>UnionsFS( 联合文件系统 Union Filesystem) )</p>
</blockquote>
<p>联合文件系统：union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，union文件系统是docker镜像的基础。镜像可以通过分层来继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但在外面来看，只是看到一个文件系统，联合加载会把各层文件系统叠加，这样最终的文件系统会包含所有底层</p>
<p>的文件和目录</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动会加载bootfs文件系统，Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核就在内存中了，此时内存的使用权已经由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs（root file system），在bootfs之上。包含的就是典型linux系统中&#x2F;dev,&#x2F;proc,&#x2F;bin&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><strong>虚拟机的Centos都是好几个G，为什么Docker这里才200M？</strong></p>
<p>对于精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同发行版可以公用bootfs。。</p>
<p>虚拟机是分钟级，容器是秒级。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像信息</span></span><br><span class="line">[root@localhost ~]# docker image inspect redis:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>.分层理解</p>
</blockquote>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[tag]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看运行的容器</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                 COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">01f17edc0c92   tomcat                &quot;catalina.sh run&quot;   3 months ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建自己的tomcat镜像</span></span><br><span class="line">[root@localhost ~]# docker commit -a=&quot;StephenShawn&quot; -m=&quot;add webapps&quot; 01f17edc0c92 tomcat01:0.1</span><br><span class="line">sha256:5da731531f9fea322cbf4cb2a971c5924672001746de2871171537faf4e6abe9</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">tomcat01              0.1       5da731531f9f   14 seconds ago   684MB</span><br><span class="line">tomcat                9.0       b8e65a4d736d   6 months ago     680MB</span><br><span class="line">tomcat                latest    fb5657adc892   6 months ago     680MB</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>dokcer镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes</title>
    <url>/2022/07/17/database/kubernetes/</url>
    <content><![CDATA[<h1 id="Kubernetes镜像"><a href="#Kubernetes镜像" class="headerlink" title="Kubernetes镜像"></a>Kubernetes镜像</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kubernetes是一个开源系统，用于容器化应用的自动部署、扩缩和管理。它将构成应用的容器按逻辑单位进行分组以便于管理和发现。</p>
<p>下载地址：<a href="https://mirrors.aliyun.com/kubernetes/">https://mirrors.aliyun.com/kubernetes/</a></p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian &#x2F; Ubuntu"></a>Debian &#x2F; Ubuntu</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span> &amp;&amp; apt-<span class="built_in">get</span> install -<span class="keyword">y</span> apt-transport-https</span><br><span class="line">curl https://mirrors.aliyun.<span class="keyword">com</span>/kubernetes/apt/doc/apt-key.gpg | apt-key <span class="built_in">add</span> - </span><br><span class="line"><span class="keyword">cat</span> &lt;&lt;EOF &gt;/etc/apt/sources.<span class="keyword">list</span>.d/kubernetes.<span class="keyword">list</span></span><br><span class="line"><span class="keyword">deb</span> https://mirrors.aliyun.<span class="keyword">com</span>/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> install -<span class="keyword">y</span> kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<h3 id="CentOS-RHEL-Fedora"><a href="#CentOS-RHEL-Fedora" class="headerlink" title="CentOS &#x2F; RHEL &#x2F; Fedora"></a>CentOS &#x2F; RHEL &#x2F; Fedora</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; <span class="regexp">/etc/yum</span>.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/repos/</span>kubernetes-el7-x86_64/</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">repo_gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/yum</span>-key.gpg https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/</span>rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce <span class="number">0</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>

<p>ps: 由于官网未开放同步方式, 可能会有索引gpg检查失败的情况, 这时请用 <code>yum install -y --nogpgcheck kubelet kubeadm kubectl</code> 安装</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>官方主页：<a href="https://kubernetes.io/">https://kubernetes.io/</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
  <entry>
    <title>Redhat Enterprise Linux</title>
    <url>/2024/04/11/database/linux/</url>
    <content><![CDATA[<h1 id="兼容RHEL的linux系统的现状"><a href="#兼容RHEL的linux系统的现状" class="headerlink" title="兼容RHEL的linux系统的现状"></a>兼容RHEL的linux系统的现状</h1><h3 id="RHEL（Redhat-Enterprise-Linux）的免费替代"><a href="#RHEL（Redhat-Enterprise-Linux）的免费替代" class="headerlink" title="RHEL（Redhat Enterprise Linux）的免费替代"></a>RHEL（Redhat Enterprise Linux）的免费替代</h3><p>国外较出名兼容RHEL有RockyLinux与Amalinux</p>
<h5 id="RHEL常用的自8版本以后改为DNF（与yum兼容）"><a href="#RHEL常用的自8版本以后改为DNF（与yum兼容）" class="headerlink" title="RHEL常用的自8版本以后改为DNF（与yum兼容）"></a>RHEL常用的自8版本以后改为DNF（与yum兼容）</h5><p><a href="https://access.redhat.com/documentation/zh-cn/red_hat_enterprise_linux/9/html-single/managing_software_with_the_dnf_tool/index#doc-wrapper">dnf的使用</a></p>
]]></content>
      <categories>
        <category>操作系统</category>
      </categories>
      <tags>
        <tag>linux</tag>
      </tags>
  </entry>
  <entry>
    <title>Mybatis-Plus</title>
    <url>/2024/04/11/database/mybatis/</url>
    <content><![CDATA[<h1 id="Mybatis-Plus-常规用法"><a href="#Mybatis-Plus-常规用法" class="headerlink" title="Mybatis-Plus 常规用法"></a>Mybatis-Plus 常规用法</h1><p><a href="https://baomidou.com/pages/24112f/">Mybatis-Plus 使用文档</a></p>
]]></content>
      <categories>
        <category>数据库查询</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js爬虫</title>
    <url>/2023/09/25/database/nodejs-spider/</url>
    <content><![CDATA[<ul>
<li>Node.js常用爬虫框架与无头浏览器</li>
</ul>
<p><strong>NodeCrawler</strong><br><strong>Simplecrawler</strong></p>
<p><a href="https://www.npmjs.com/package/puppeteer"><strong>puppeteer</strong></a></p>
<p>JavaScript编写的开源Web爬虫</p>
<ol>
<li>NodeCrawler<br>实现语言： JavaScript<br>GitHub星标数： 3999<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>NodeCrawler是一种广为使用的Web爬虫，它基于NodeJS实现，具有非常快的爬取速度。<br>Nodecrawler非常适用于偏爱使用JavaScript编程或者致力于JavaScript项目的开发人员。其安装也非常简单。<br>JSDOM和Cheerio（用于HTML解析）实现服务器端渲染。其中，JSDOM更为稳定。<br>特性：</p>
<p>使用 Cheerio（默认）或JSDOM实现服务端DOM和自动jQuery插入。<br>可配置池子规模和重试次数。<br>控制爬取率限制。<br>请求的优先队列。<br>支持forceUTF8模式，使得爬虫可以检测并转换字符集。<br>与4.x乃至更新版本兼容。<br>– 官方文档：<a href="https://github.com/bda-research/node-crawler">https://github.com/bda-research/node-crawler</a></p>
<p>– 官方网站：<a href="http://nodecrawler.org/">http://nodecrawler.org/</a></p>
<span id="more"></span>
<ol start="2">
<li>Simplecrawler<br>实现语言： JavaScript<br>GitHub星标数：1764<br>官方支持链接<br>简介：</li>
</ol>
<p>Simplecrawler设计提供基本的、灵活且稳定的网站爬取API。<br>Simplecrawler在实现上考虑了针对特大型Web站点的归档、分析和搜索。它可爬取上百万页面，并毫无问题地向磁盘写入数十GB数据。<br>特性：</p>
<p>提供了用于自动检测链接资源的一些简单逻辑，用户可自行替换和添加。<br>自动请求任何robots.txt禁止规则。<br>具有灵活的队列系统，可在磁盘上冻结和解冻。<br>– 官方文档： <a href="https://github.com/simplecrawler/simplecrawler">https://github.com/simplecrawler/simplecrawler</a></p>
<p>– 官方网站： <a href="https://www.npmjs.com/package/simplecrawler">https://www.npmjs.com/package/simplecrawler</a></p>
<ol start="3">
<li>Js-crawler :<br>实现语言： JavaScript<br>GitHub星标数： 167<br>官方支持链接)<br>简介：</li>
</ol>
<p>使用NodeJS实现的Web爬虫，支持HTTP和HTTPS<br>– 官方文档： <a href="https://github.com/antivanov/js-crawler">https://github.com/antivanov/js-crawler</a></p>
<p>– 官方网站： <a href="https://github.com/antivanov/js-crawler">https://github.com/antivanov/js-crawler</a></p>
<ol start="4">
<li>Webster<br>实现语言： JavaScript<br>GitHub星标数： 201<br>官方支持链接<br>简介：</li>
</ol>
<p>Webster是一种使用NodeJS编写的可靠Web爬取和采集框架，用于爬取Web站点并从页面中抽取结构化数据。<br>与其他爬取框架的不同之处在于，Webster可以抓取浏览器客户端的JavaScript和Ajax请求呈现的内容。<br>– 官方文档： <a href="http://webster.zhuyingda.com/">http://webster.zhuyingda.com/</a></p>
<p>– 官方网站： <a href="https://github.com/zhuyingda/webster">https://github.com/zhuyingda/webster</a></p>
<ol start="5">
<li>Node-osmosis<br>实现语言：JavaScript<br>GitHub星标数： 3630<br>**官方支持链接<br>简介：</li>
</ol>
<ul>
<li>一种使用NodeJS实现的HTML&#x2F;XML解析器和Web爬虫。</li>
</ul>
<p>特性：</p>
<p>使用原生libxml的C绑定。<br>干净的Promise类接口。<br>支持CSS 3.0和XPath 1.0选择器的混合。<br>Sizzle选择器、Slick选择器以及更多。<br>不具有像jQuery、cheerio或jsdom那样的大型依赖。<br>构成深度和复杂的数据结构。<br>HTML解析器特性：<br>快速解析；<br>高速搜索；<br>内存占用小。<br>HTML DOM特性：<br>加载和搜索ajax内容；<br>DOM交互和事件；<br>执行嵌入和远程脚本；<br>在DOM中执行代码。<br>HTTP请求特性：<br>日志记录URL，重定向和错误；<br>Cookie的jar包，以及自定义Cookie&#x2F;头部&#x2F;用户代理；<br>登录&#x2F;表单提交、会话Cookie，基本的认证；<br>单代理、多代理，处理代理失败情况；<br>限制重试和重定向。<br>– 官方文档： <a href="https://rchipka.github.io/node-osmosis/global.html">https://rchipka.github.io/node-osmosis/global.html</a></p>
<p>– 官方网站： <a href="https://www.npmjs.com/package/osmosis">https://www.npmjs.com/package/osmosis</a></p>
<ol start="6">
<li>Supercrawler<br>实现语言：JavaScript<br>GitHub星标数： 4341<br>官方支持链接<br>简介：</li>
</ol>
<p>Supercrawler是一种使用NodeJS实现的Web爬虫，在设计上支持高度可配置和易用性。<br>一旦成功爬取一个网页（可以是图像、文本文档或其他任何文件），Supercrawler将会触发用户自定义的内容类型（content-type）处理器，处理页面解析、保存数据以及其它一些用户定义的功能。<br>特性：</p>
<p>链接检测：Supercrawler会解析所爬取的HTML文档，识别其中链接并添加到队列中。<br>机器人解析：在爬取前Supercrawler会请求robots.txt并检查其中的禁止规则。它也可识别站点地图。<br>站点地图解析：Supercrawler可以从XML站点地图文件中读取链接，并将链接添加到队列中。<br>并发限制：Supercrawler可限制在任一时间发出的请求数。<br>速率限制：Supercrawler可添加请求的时延，以免对服务器产生轰炸。<br>指数补偿（Exponential backoff）重试：Supercrawler将依此在一小时、两小时、四小时乃至更多时间后重试请求。要使用该特性，爬取队列必须使用数据库或Redis作为后端。<br>主机名均衡：Supercrawler可在不同主机名间平均分割请求量。要使用该特性，爬取队列必须以Redis为后端。<br>– 官方文档： <a href="https://github.com/brendonboshell/supercrawler">https://github.com/brendonboshell/supercrawler</a></p>
<p>– 官方网站： <a href="https://github.com/brendonboshell/supercrawler">https://github.com/brendonboshell/supercrawler</a></p>
<ol start="7">
<li>Web scraper的Chrome扩展<br>实现语言：JavaScript<br>GitHub星标数： 775<br>官方支持链接<br>简介：</li>
</ol>
<p>Web Scraper是一种Chrome浏览器扩展，构建用于从Web页面抽取数据。<br>用户可以使用该扩展创建计划（站点地图），定义如何遍历一个Web网站，以及如何从中抽取数据。<br>Web Scraper使用站点地图相应地遍历网站，并从中抽取数据。<br>支持以CSV格式导出所抽取的数据。<br>特性：</p>
<p>抽取多个页面。<br>站点地图和抽取的数据存储在浏览器的本地存储，也可存储在CouchDB中。<br>多种数据类型选取。<br>支持从动态网页（JavaScript+AJAX）抽取数据。<br>浏览抽取的数据。<br>以CSV格式导出抽取的数据。<br>导入、导出站点地图。<br>只依赖于Chrome浏览器。<br>– 官方文档： <a href="https://www.webscraper.io/documentation">https://www.webscraper.io/documentation</a></p>
<p>– 官方网站： <a href="https://www.webscraper.io/">https://www.webscraper.io</a></p>
<ol start="8">
<li>Headless Chrome爬虫<br>实现语言：JavaScript<br>GitHub星标数： 3256<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>使用基本HTML文件请求的爬虫，通常速度很快。但这样的爬虫往往会抽取到空白内容，尤其是在爬取使用AngularJS、React和Vue.js等现代前端框架构建的网站时。<br>特性：</p>
<p>分布式爬取。<br>可配置并发、延迟和重试。<br>支持深度优先搜索和广度优先搜索算法。<br>支持插拔缓存存储，例如Redis。<br>支持导出CSV和JSON。<br>在达到最大请求时暂停爬取，并可在任一时刻恢复。<br>自动插入用于抽取的jQuery。<br>保存屏幕截图，用于证实爬取过程。<br>模拟设备和用户代理。<br>具有优先队列，可提高爬取效率。<br>– 官方文档： <a href="https://github.com/yujiosaka/headless-chrome-crawler/blob/master/docs/API.md">https://github.com/yujiosaka/headless-chrome-crawler/blob/master/docs/API.md</a></p>
<p>– 官方网站： <a href="https://github.com/yujiosaka/headless-chrome-crawler">https://github.com/yujiosaka/headless-chrome-crawler</a></p>
<ol start="9">
<li>X-ray<br>实现语言：JavaScript<br>GitHub星标数： 4464<br>官方支持链接</li>
</ol>
<p>特性：</p>
<p>模式灵活：支持字符串、数组、对象以及嵌套对象结构。模式并非绑定于所抽取的页面结构，支持用户获取选定结构中的数据。<br>可组合（Composable）：API是完全可组合的，赋予用户抽取每个页面的极大灵活性。<br>分页支持：爬取页面在Web站点上的所有分页。X-ray还支持请求延迟和分页限制，并支持将爬取页面导入到单个文件中。这样一旦单个页面产生错误，用户不会失去所有已爬取的数据。<br>爬虫支持：从一个页面开始，轻易跳转另一个页面。页面跳转是可预测的，按深度优先爬取所有页面。<br>负责任的爬取：X-ray支持并发、限制、延迟、超时和限制，实现负责任地爬取任何页面。<br>可插拔驱动：可按用户需求置换不同的爬虫。<br>– 官方文档： <a href="https://github.com/matthewmueller/x-ray">https://github.com/matthewmueller/x-ray</a></p>
<p>– 官方网站： <a href="https://www.npmjs.com/package/x-ray-scraper">https://www.npmjs.com/package/x-ray-scraper</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Node.js爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>rockylinux install</title>
    <url>/2022/09/12/database/rockylinux-install/</url>
    <content><![CDATA[<h1 id="安装、网络、包源配置"><a href="#安装、网络、包源配置" class="headerlink" title="安装、网络、包源配置"></a><a href="https://blog.csdn.net/dreamerrrrrr/article/details/119837681">安装、网络、包源配置</a></h1><h2 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h2><ul>
<li>rockylinux下载地址<code>https://mirrors.aliyun.com/rockylinux</code></li>
</ul>
<pre><code class="shell">sed -e &#39;s|^mirrorlist=|#mirrorlist=|g&#39; \
    -e &#39;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#39; \
    -i.bak \
    /etc/yum.repos.d/Rocky-*.repo

dnf makecache

# RHEL常用命令

- [DNF](https://wangchujiang.com/linux-command/c/dnf.html)
- [NetworkManager](https://blog.csdn.net/yangshihuz/article/details/106643970)
- [sytemctl](https://linux265.com/news/3385.html)
- [firewalld](https://blog.51cto.com/andyxu/2137046)
</code></pre>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>兼容centos的社区实现</tag>
      </tags>
  </entry>
  <entry>
    <title>git配置SSH密钥</title>
    <url>/2025/01/31/git/git-rsa/</url>
    <content><![CDATA[<h3 id="1-生成新的-SSH-密钥"><a href="#1-生成新的-SSH-密钥" class="headerlink" title="1.生成新的 SSH 密钥"></a>1.生成新的 SSH 密钥</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh-keygen -t ed25519 -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-测试-SSH-连接"><a href="#2-测试-SSH-连接" class="headerlink" title="2.测试 SSH 连接"></a>2.测试 SSH 连接</h3><p>​	将 <code>your_email@example.com</code> 替换为你在 Git 服务提供商（如 GitHub）上注册的邮箱地址。</p>
<p>执行命令后，会提示你选择密钥的保存位置和设置密码（密码可以为空）。一般情况下，直接按回车键使用默认设置即可。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">ssh -T git@github.com</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git配置SSH密钥</tag>
      </tags>
  </entry>
  <entry>
    <title>git配置用户名和密码</title>
    <url>/2022/05/14/git/git-username/</url>
    <content><![CDATA[<h3 id="1-全局配置"><a href="#1-全局配置" class="headerlink" title="1.全局配置"></a>1.全局配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;Your Name&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure>

<h3 id="2-全局配置删除"><a href="#2-全局配置删除" class="headerlink" title="2.全局配置删除"></a>2.全局配置删除</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --global --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure>

<h3 id="3-系统配置删除"><a href="#3-系统配置删除" class="headerlink" title="3.系统配置删除"></a>3.系统配置删除</h3><p>系统配置会影响系统上所有用户的所有 Git 仓库，操作时需谨慎。删除系统配置的用户和邮箱信息，使用以下命令：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --system --<span class="built_in">unset</span> user.name</span><br><span class="line">git config --system --<span class="built_in">unset</span> user.email</span><br></pre></td></tr></table></figure>

<h3 id="4-查看全局配置"><a href="#4-查看全局配置" class="headerlink" title="4.查看全局配置"></a>4.查看全局配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --global --list</span><br></pre></td></tr></table></figure>

<h3 id="5-查看系统配置"><a href="#5-查看系统配置" class="headerlink" title="5.查看系统配置"></a>5.查看系统配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">git config --system --list</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git配置</tag>
      </tags>
  </entry>
  <entry>
    <title>rockylinux8-network-config</title>
    <url>/2023/12/17/database/rockylinux8-network-config/</url>
    <content><![CDATA[<h4 id="查看linux内核信息"><a href="#查看linux内核信息" class="headerlink" title="查看linux内核信息"></a>查看linux内核信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>
<h4 id="查看linux发行版信息"><a href="#查看linux发行版信息" class="headerlink" title="查看linux发行版信息"></a>查看linux发行版信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/os-release</span><br></pre></td></tr></table></figure>
<h4 id="配置静态网路"><a href="#配置静态网路" class="headerlink" title="配置静态网路"></a>配置静态网路</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line"><span class="comment"># 静态IP地址</span></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=ens160</span><br><span class="line">UUID=293f1d04-332e-4de2-8f19-4910bca6672c</span><br><span class="line">DEVICE=ens160</span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 本机地址</span></span><br><span class="line">IPADDR=192.168.166.6</span><br><span class="line"><span class="comment"># 子网掩码</span></span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="comment"># 虚拟VM8网卡 NAT 网关</span></span><br><span class="line">GATEWAY=192.168.166.2</span><br><span class="line"><span class="comment"># DNS 域名解析服务器IP地址</span></span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=223.5.5.5</span><br><span class="line">DNS3=8.8.8.8</span><br></pre></td></tr></table></figure>
<h4 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<h4 id="SSH连接问题-网络不可达-怀疑是VMware软件问题，配置SSH映射就好了"><a href="#SSH连接问题-网络不可达-怀疑是VMware软件问题，配置SSH映射就好了" class="headerlink" title="SSH连接问题 网络不可达(怀疑是VMware软件问题，配置SSH映射就好了)"></a>SSH连接问题 网络不可达(怀疑是VMware软件问题，配置SSH映射就好了)</h4><p>网络也能ping外网了，具体操作见<a href="https://blog.csdn.net/YiRan_Zhao/article/details/110121526">地址</a></p>
]]></content>
      <categories>
        <category>rockylinux8</category>
      </categories>
      <tags>
        <tag>rockylinux8-network-config</tag>
      </tags>
  </entry>
  <entry>
    <title>centos安装docker</title>
    <url>/2022/06/06/database/rockylinx-install-docker/</url>
    <content><![CDATA[<h3 id="rockylinux安装教程"><a href="#rockylinux安装教程" class="headerlink" title="rockylinux安装教程"></a><a href="https://blog.csdn.net/dreamerrrrrr/article/details/119837681">rockylinux安装教程</a></h3><h1 id="install-on-CentOS-Install-Docker-Engine-on-CentOS-Docker-Documentation"><a href="#install-on-CentOS-Install-Docker-Engine-on-CentOS-Docker-Documentation" class="headerlink" title="[install on CentOS](Install Docker Engine on CentOS | Docker Documentation)"></a>[install on CentOS](<a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a>)</h1><h3 id="Uninstall-old-versions"><a href="#Uninstall-old-versions" class="headerlink" title="Uninstall old versions"></a>Uninstall old versions</h3><hr>
<figure class="highlight apache"><table><tr><td class="code"><pre><span class="line"><span class="attribute">sudo</span> yum remove docker <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-client <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-client-latest <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-common <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-latest <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-latest-logrotate <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-logrotate <span class="punctuation">\</span></span><br><span class="line"><span class="punctuation"></span>                  docker-engine </span><br></pre></td></tr></table></figure>
<h3 id="Install-using-the-repository"><a href="#Install-using-the-repository" class="headerlink" title="Install using the repository"></a>Install using the repository</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"> sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="Install-Docker-Engine"><a href="#Install-Docker-Engine" class="headerlink" title="Install Docker Engine"></a>Install Docker Engine</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h3 id="Start-Docker"><a href="#Start-Docker" class="headerlink" title="Start Docker"></a>Start Docker</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> systemctl start docker</span><br></pre></td></tr></table></figure>

<h3 id="Uninstall-Docker-Engine"><a href="#Uninstall-Docker-Engine" class="headerlink" title="Uninstall Docker Engine"></a>Uninstall Docker Engine</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">rm</span> -rf /var/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="var-lib-docker-为默认工作目录"><a href="#var-lib-docker-为默认工作目录" class="headerlink" title="&#x2F;var&#x2F;lib&#x2F;docker 为默认工作目录"></a>&#x2F;var&#x2F;lib&#x2F;docker 为默认工作目录</h3><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">sudo</span> <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line"><span class="built_in">sudo</span> <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://rz9fml8b.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line"><span class="built_in">sudo</span> systemctl daemon-reload</span><br><span class="line"><span class="built_in">sudo</span> systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>centos安装docker</tag>
      </tags>
  </entry>
  <entry>
    <title>Java_Stream_API</title>
    <url>/2022/07/13/java/Java-Stream-API/</url>
    <content><![CDATA[<p>2.1. Empty Stream<br>We should use the empty() method in case of the creation of an empty stream:</p>
<p>Stream<String> streamEmpty &#x3D; Stream.empty();<br>We often use the empty() method upon creation to avoid returning null for streams with no element:</p>
<p>public Stream<String> streamOf(List<String> list) {<br>    return list &#x3D;&#x3D; null || list.isEmpty() ? Stream.empty() : list.stream();<br>}</p>
<span id="more"></span>
<p>2.2. Stream of Collection<br>We can also create a stream of any type of Collection (Collection, List, Set):</p>
<p>Collection<String> collection &#x3D; Arrays.asList(“a”, “b”, “c”);<br>Stream<String> streamOfCollection &#x3D; collection.stream();<br>2.3. Stream of Array<br>An array can also be the source of a stream:</p>
<p>Stream<String> streamOfArray &#x3D; Stream.of(“a”, “b”, “c”);<br>We can also create a stream out of an existing array or of part of an array:</p>
<p>String[] arr &#x3D; new String[]{“a”, “b”, “c”};<br>Stream<String> streamOfArrayFull &#x3D; Arrays.stream(arr);<br>Stream<String> streamOfArrayPart &#x3D; Arrays.stream(arr, 1, 3);<br>2.4. Stream.builder()<br>When builder is used, the desired type should be additionally specified in the right part of the statement, otherwise the build() method will create an instance of the Stream<Object>:</p>
<p>Stream<String> streamBuilder &#x3D;<br>  Stream.<String>builder().add(“a”).add(“b”).add(“c”).build();<br>2.5. Stream.generate()<br>The generate() method accepts a Supplier<T> for element generation. As the resulting stream is infinite, the developer should specify the desired size, or the generate() method will work until it reaches the memory limit:</p>
<p>Stream<String> streamGenerated &#x3D;<br>  Stream.generate(() -&gt; “element”).limit(10);<br>The code above creates a sequence of ten strings with the value “element.”</p>
<p>2.6. Stream.iterate()<br>Another way of creating an infinite stream is by using the iterate() method:</p>
<p>Stream<Integer> streamIterated &#x3D; Stream.iterate(40, n -&gt; n + 2).limit(20);<br>The first element of the resulting stream is the first parameter of the iterate() method. When creating every following element, the specified function is applied to the previous element. In the example above the second element will be 42.</p>
<p>2.7. Stream of Primitives<br>Java 8 offers the possibility to create streams out of three primitive types: int, long and double. As Stream<T> is a generic interface, and there is no way to use primitives as a type parameter with generics, three new special interfaces were created: IntStream, LongStream, DoubleStream.</p>
<p>Using the new interfaces alleviates unnecessary auto-boxing, which allows for increased productivity:</p>
<p>IntStream intStream &#x3D; IntStream.range(1, 3);<br>LongStream longStream &#x3D; LongStream.rangeClosed(1, 3);<br>The range(int startInclusive, int endExclusive) method creates an ordered stream from the first parameter to the second parameter. It increments the value of subsequent elements with the step equal to 1. The result doesn’t include the last parameter, it is just an upper bound of the sequence.</p>
<p>The rangeClosed(int startInclusive, int endInclusive) method does the same thing with only one difference, the second element is included. We can use these two methods to generate any of the three types of streams of primitives.</p>
<p>Since Java 8, the Random class provides a wide range of methods for generating streams of primitives. For example, the following code creates a DoubleStream, which has three elements:</p>
<p>Random random &#x3D; new Random();<br>DoubleStream doubleStream &#x3D; random.doubles(3);<br>2.8. Stream of String<br>We can also use String as a source for creating a stream with the help of the chars() method of the String class. Since there is no interface for CharStream in JDK, we use the IntStream to represent a stream of chars instead.</p>
<p>IntStream streamOfChars &#x3D; “abc”.chars();<br>The following example breaks a String into sub-strings according to specified RegEx:</p>
<p>Stream<String> streamOfString &#x3D;<br>  Pattern.compile(“, “).splitAsStream(“a, b, c”);<br>2.9. Stream of File<br>Furthermore, Java NIO class Files allows us to generate a Stream<String> of a text file through the lines() method. Every line of the text becomes an element of the stream:</p>
<p>Path path &#x3D; Paths.get(“C:\file.txt”);<br>Stream<String> streamOfStrings &#x3D; Files.lines(path);<br>Stream<String> streamWithCharset &#x3D;<br>  Files.lines(path, Charset.forName(“UTF-8”));<br>The Charset can be specified as an argument of the lines() method.</p>
<ol start="3">
<li>Referencing a Stream<br>We can instantiate a stream, and have an accessible reference to it, as long as only intermediate operations are called. Executing a terminal operation makes a stream inaccessible.</li>
</ol>
<p>To demonstrate this, we will forget for a while that the best practice is to chain the sequence of operation. Besides its unnecessary verbosity, technically the following code is valid:</p>
<p>Stream<String> stream &#x3D;<br>  Stream.of(“a”, “b”, “c”).filter(element -&gt; element.contains(“b”));<br>Optional<String> anyElement &#x3D; stream.findAny();<br>However, an attempt to reuse the same reference after calling the terminal operation will trigger the IllegalStateException:</p>
<p>Optional<String> firstElement &#x3D; stream.findFirst();<br>As the IllegalStateException is a RuntimeException, a compiler will not signalize about a problem. So it is very important to remember that Java 8 streams can’t be reused.</p>
<p>This kind of behavior is logical. We designed streams to apply a finite sequence of operations to the source of elements in a functional style, not to store elements.</p>
<p>So to make the previous code work properly, some changes should be made:</p>
<p>List<String> elements &#x3D;<br>  Stream.of(“a”, “b”, “c”).filter(element -&gt; element.contains(“b”))<br>    .collect(Collectors.toList());<br>Optional<String> anyElement &#x3D; elements.stream().findAny();<br>Optional<String> firstElement &#x3D; elements.stream().findFirst();<br>4. Stream Pipeline<br>To perform a sequence of operations over the elements of the data source and aggregate their results, we need three parts: the source, intermediate operation(s) and a terminal operation.</p>
<p>Intermediate operations return a new modified stream. For example, to create a new stream of the existing one without few elements, the skip() method should be used:</p>
<p>Stream<String> onceModifiedStream &#x3D;<br>  Stream.of(“abcd”, “bbcd”, “cbcd”).skip(1);<br>If we need more than one modification, we can chain intermediate operations. Let’s assume that we also need to substitute every element of the current Stream<String> with a sub-string of the first few chars. We can do this by chaining the skip() and map() methods:</p>
<p>Stream<String> twiceModifiedStream &#x3D;<br>  stream.skip(1).map(element -&gt; element.substring(0, 3));<br>As we can see, the map() method takes a lambda expression as a parameter. If we want to learn more about lambdas, we can take a look at our tutorial Lambda Expressions and Functional Interfaces: Tips and Best Practices.</p>
<p>A stream by itself is worthless; the user is interested in the result of the terminal operation, which can be a value of some type or an action applied to every element of the stream. We can only use one terminal operation per stream.</p>
<p>The correct and most convenient way to use streams is by a stream pipeline, which is a chain of the stream source, intermediate operations, and a terminal operation:</p>
<p>List<String> list &#x3D; Arrays.asList(“abc1”, “abc2”, “abc3”);<br>long size &#x3D; list.stream().skip(1)<br>  .map(element -&gt; element.substring(0, 3)).sorted().count();<br>5. Lazy Invocation<br>Intermediate operations are lazy. This means that they will be invoked only if it is necessary for the terminal operation execution.</p>
<p>For example, let’s call the method wasCalled(), which increments an inner counter every time it’s called:</p>
<p>private long counter;</p>
<p>private void wasCalled() {<br>    counter++;<br>}<br>Now let’s call the method wasCalled() from operation filter():</p>
<p>List<String> list &#x3D; Arrays.asList(“abc1”, “abc2”, “abc3”);<br>counter &#x3D; 0;<br>Stream<String> stream &#x3D; list.stream().filter(element -&gt; {<br>    wasCalled();<br>    return element.contains(“2”);<br>});<br>As we have a source of three elements, we can assume that the filter() method will be called three times, and the value of the counter variable will be 3. However, running this code doesn’t change counter at all, it is still zero, so the filter() method wasn’t even called once. The reason why is missing of the terminal operation.</p>
<p>Let’s rewrite this code a little bit by adding a map() operation and a terminal operation, findFirst(). We will also add the ability to track the order of method calls with the help of logging:</p>
<p>Optional<String> stream &#x3D; list.stream().filter(element -&gt; {<br>    log.info(“filter() was called”);<br>    return element.contains(“2”);<br>}).map(element -&gt; {<br>    log.info(“map() was called”);<br>    return element.toUpperCase();<br>}).findFirst();<br>The resulting log shows that we called the filter() method twice and the map() method once. This is because the pipeline executes vertically. In our example, the first element of the stream didn’t satisfy the filter’s predicate. Then we invoked the filter() method for the second element, which passed the filter. Without calling the filter() for the third element, we went down through the pipeline to the map() method.</p>
<p>The findFirst() operation satisfies by just one element. So in this particular example, the lazy invocation allowed us to avoid two method calls, one for the filter() and one for the map().</p>
<ol start="6">
<li>Order of Execution<br>From the performance point of view, the right order is one of the most important aspects of chaining operations in the stream pipeline:</li>
</ol>
<p>long size &#x3D; list.stream().map(element -&gt; {<br>    wasCalled();<br>    return element.substring(0, 3);<br>}).skip(2).count();<br>Execution of this code will increase the value of the counter by three. This means that we called the map() method of the stream three times, but the value of the size is one. So the resulting stream has just one element, and we executed the expensive map() operations for no reason two out of the three times.</p>
<p>If we change the order of the skip() and the map() methods, the counter will increase by only one. So we will call the map() method only once:</p>
<p>long size &#x3D; list.stream().skip(2).map(element -&gt; {<br>    wasCalled();<br>    return element.substring(0, 3);<br>}).count();<br>This brings us to the following rule: intermediate operations which reduce the size of the stream should be placed before operations which are applying to each element. So we need to keep methods such as skip(), filter(), and distinct() at the top of our stream pipeline.</p>
<ol start="7">
<li>Stream Reduction<br>The API has many terminal operations which aggregate a stream to a type or to a primitive: count(), max(), min(), and sum(). However, these operations work according to the predefined implementation. So what if a developer needs to customize a Stream’s reduction mechanism? There are two methods which allow us to do this, the reduce() and the collect() methods.</li>
</ol>
<p>7.1. The reduce() Method<br>There are three variations of this method, which differ by their signatures and returning types. They can have the following parameters:</p>
<p>identity – the initial value for an accumulator, or a default value if a stream is empty and there is nothing to accumulate</p>
<p>accumulator – a function which specifies the logic of the aggregation of elements. As the accumulator creates a new value for every step of reducing, the quantity of new values equals the stream’s size and only the last value is useful. This is not very good for the performance.</p>
<p>combiner – a function which aggregates the results of the accumulator. We only call combiner in a parallel mode to reduce the results of accumulators from different threads.</p>
<p>Now let’s look at these three methods in action:</p>
<p>OptionalInt reduced &#x3D;<br>  IntStream.range(1, 4).reduce((a, b) -&gt; a + b);<br>reduced &#x3D; 6 (1 + 2 + 3)</p>
<p>int reducedTwoParams &#x3D;<br>  IntStream.range(1, 4).reduce(10, (a, b) -&gt; a + b);<br>reducedTwoParams &#x3D; 16 (10 + 1 + 2 + 3)</p>
<p>int reducedParams &#x3D; Stream.of(1, 2, 3)<br>  .reduce(10, (a, b) -&gt; a + b, (a, b) -&gt; {<br>     log.info(“combiner was called”);<br>     return a + b;<br>  });<br>The result will be the same as in the previous example (16), and there will be no login, which means that combiner wasn’t called. To make a combiner work, a stream should be parallel:</p>
<p>int reducedParallel &#x3D; Arrays.asList(1, 2, 3).parallelStream()<br>    .reduce(10, (a, b) -&gt; a + b, (a, b) -&gt; {<br>       log.info(“combiner was called”);<br>       return a + b;<br>    });<br>The result here is different (36), and the combiner was called twice. Here the reduction works by the following algorithm: the accumulator ran three times by adding every element of the stream to identity. These actions are being done in parallel. As a result, they have (10 + 1 &#x3D; 11; 10 + 2 &#x3D; 12; 10 + 3 &#x3D; 13;). Now combiner can merge these three results. It needs two iterations for that (12 + 13 &#x3D; 25; 25 + 11 &#x3D; 36).</p>
<p>7.2. The collect() Method<br>The reduction of a stream can also be executed by another terminal operation, the collect() method. It accepts an argument of the type Collector, which specifies the mechanism of reduction. There are already created, predefined collectors for most common operations. They can be accessed with the help of the Collectors type.</p>
<p>In this section, we will use the following List as a source for all streams:</p>
<p>List<Product> productList &#x3D; Arrays.asList(new Product(23, “potatoes”),<br>  new Product(14, “orange”), new Product(13, “lemon”),<br>  new Product(23, “bread”), new Product(13, “sugar”));<br>Converting a stream to the Collection (Collection, List or Set):</p>
<p>List<String> collectorCollection &#x3D;<br>  productList.stream().map(Product::getName).collect(Collectors.toList());<br>Reducing to String:</p>
<p>String listToString &#x3D; productList.stream().map(Product::getName)<br>  .collect(Collectors.joining(“, “, “[“, “]”));<br>The joiner() method can have from one to three parameters (delimiter, prefix, suffix). The most convenient thing about using joiner() is that the developer doesn’t need to check if the stream reaches its end to apply the suffix and not to apply a delimiter. Collector will take care of that.</p>
<p>Processing the average value of all numeric elements of the stream:</p>
<p>double averagePrice &#x3D; productList.stream()<br>  .collect(Collectors.averagingInt(Product::getPrice));<br>Processing the sum of all numeric elements of the stream:</p>
<p>int summingPrice &#x3D; productList.stream()<br>  .collect(Collectors.summingInt(Product::getPrice));<br>The methods averagingXX(), summingXX() and summarizingXX() can work with primitives (int, long, double) and with their wrapper classes (Integer, Long, Double). One more powerful feature of these methods is providing the mapping. As a result, the developer doesn’t need to use an additional map() operation before the collect() method.</p>
<p>Collecting statistical information about stream’s elements:</p>
<p>IntSummaryStatistics statistics &#x3D; productList.stream()<br>  .collect(Collectors.summarizingInt(Product::getPrice));<br>By using the resulting instance of type IntSummaryStatistics, the developer can create a statistical report by applying the toString() method. The result will be a String common to this one “IntSummaryStatistics{count&#x3D;5, sum&#x3D;86, min&#x3D;13, average&#x3D;17,200000, max&#x3D;23}.”</p>
<p>It is also easy to extract from this object separate values for count, sum, min, and average by applying the methods getCount(), getSum(), getMin(), getAverage(), and getMax(). All of these values can be extracted from a single pipeline.</p>
<p>Grouping of stream’s elements according to the specified function:</p>
<p>Map&lt;Integer, List<Product>&gt; collectorMapOfLists &#x3D; productList.stream()<br>  .collect(Collectors.groupingBy(Product::getPrice));<br>In the example above, the stream was reduced to the Map, which groups all products by their price.</p>
<p>Dividing stream’s elements into groups according to some predicate:</p>
<p>Map&lt;Boolean, List<Product>&gt; mapPartioned &#x3D; productList.stream()<br>  .collect(Collectors.partitioningBy(element -&gt; element.getPrice() &gt; 15));<br>Pushing the collector to perform additional transformation:</p>
<p>Set<Product> unmodifiableSet &#x3D; productList.stream()<br>  .collect(Collectors.collectingAndThen(Collectors.toSet(),<br>  Collections::unmodifiableSet));<br>In this particular case, the collector has converted a stream to a Set, and then created the unchangeable Set out of it.</p>
<p>Custom collector:</p>
<p>If for some reason a custom collector should be created, the easiest and least verbose way of doing so is to use the method of() of the type Collector.</p>
<p>Collector&lt;Product, ?, LinkedList<Product>&gt; toLinkedList &#x3D;<br>  Collector.of(LinkedList::new, LinkedList::add,<br>    (first, second) -&gt; {<br>       first.addAll(second);<br>       return first;<br>    });</p>
<p>LinkedList<Product> linkedListOfPersons &#x3D;<br>  productList.stream().collect(toLinkedList);<br>In this example, an instance of the Collector got reduced to the LinkedList<Persone>.</p>
<ol start="8">
<li>Parallel Streams<br>Before Java 8, parallelization was complex. The emergence of the ExecutorService and the ForkJoin simplified a developer’s life a little bit, but it was still worth remembering how to create a specific executor, how to run it, and so on. Java 8 introduced a way of accomplishing parallelism in a functional style.</li>
</ol>
<p>The API allows us to create parallel streams, which perform operations in a parallel mode. When the source of a stream is a Collection or an array, it can be achieved with the help of the parallelStream() method:</p>
<p>Stream<Product> streamOfCollection &#x3D; productList.parallelStream();<br>boolean isParallel &#x3D; streamOfCollection.isParallel();<br>boolean bigPrice &#x3D; streamOfCollection<br>  .map(product -&gt; product.getPrice() * 12)<br>  .anyMatch(price -&gt; price &gt; 200);<br>If the source of a stream is something other than a Collection or an array, the parallel() method should be used:</p>
<p>IntStream intStreamParallel &#x3D; IntStream.range(1, 150).parallel();<br>boolean isParallel &#x3D; intStreamParallel.isParallel();<br>Under the hood, Stream API automatically uses the ForkJoin framework to execute operations in parallel. By default, the common thread pool will be used and there is no way (at least for now) to assign some custom thread pool to it. This can be overcome by using a custom set of parallel collectors.</p>
<p>When using streams in parallel mode, avoid blocking operations. It is also best to use parallel mode when tasks need a similar amount of time to execute. If one task lasts much longer than the other, it can slow down the complete app’s workflow.</p>
<p>The stream in parallel mode can be converted back to the sequential mode by using the sequential() method:</p>
<p>IntStream intStreamSequential &#x3D; intStreamParallel.sequential();<br>boolean isParallel &#x3D; intStreamSequential.isParallel();</p>
]]></content>
  </entry>
  <entry>
    <title>idea快捷键</title>
    <url>/2022/07/11/idea/idea-shortcut-key/</url>
    <content><![CDATA[<h2 id="常用快捷键1"><a href="#常用快捷键1" class="headerlink" title="常用快捷键1"></a><a href="https://zhuanlan.zhihu.com/p/410613271">常用快捷键1</a></h2><h2 id="常用快捷键2"><a href="#常用快捷键2" class="headerlink" title="常用快捷键2"></a><a href="https://blog.csdn.net/weixin_45395059/article/details/125591122">常用快捷键2</a></h2><ul>
<li>ctrl + alt + o 代码优化(自动删除多余的包与变量)</li>
<li>Alt + F12 打开terminal(终端) </li>
<li>ctrl+shift+(+&#x2F;-) 展开全部折叠全部</li>
<li>ctrl+（+&#x2F;-） 展开折叠当前方法</li>
<li>shift + f6 重命名(重构)</li>
<li>ctrl + alt + l 代码格式化</li>
<li>alt + insert 创建内容</li>
<li>psvm main方法</li>
<li>sout 输出语句</li>
<li>Ctrl + d 复制一行</li>
<li>Ctrl + y 删除一行</li>
<li>Ctrl + Shift + Up&#x2F;Down 代码向上&#x2F;下移动</li>
<li>Ctrl + n 搜索类</li>
<li>alt + insert 生成代码</li>
<li>alt + Enter 导包，生成变量</li>
<li>Ctrl + &#x2F; 或 Ctrl + Shift+ &#x2F; 单行注释或多行注释</li>
<li>fori 回车即可 for循环</li>
<li>ctrl + alt + t 代码包围try-catch,if,while等</li>
<li>ctrl + alt + -&gt; 向后 ctrl + alt + &lt;- 向前</li>
<li>显示代码结构：alt + 7</li>
<li>显示导航栏：alt + 1</li>
<li>撤销 ctrl + Z</li>
<li>REDO 操作 ctrl + shif + z</li>
<li>Tab 缩进 shift+Tab 撤销缩进</li>
<li>Ctrl + u 选择行</li>
<li>alt + f8 查看变量值</li>
<li>ctrl + alt +B 查找接口实现类</li>
<li>ctrl + h 查看类或接口的继承关系</li>
<li>ctrl + o 覆写方法</li>
</ul>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul>
<li>ctrl + r 替换</li>
<li>ctrl + shift + r 路径中替换</li>
</ul>
<h2 id="调试debug"><a href="#调试debug" class="headerlink" title="调试debug"></a>调试<a href="https://blog.csdn.net/m0_37154839/article/details/107617122">debug</a></h2><ul>
<li>F9 调试</li>
</ul>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>容器数据卷</title>
    <url>/2022/06/28/database/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><p>原理：将容器目录挂载到Linux的目录</p>
<p><strong>容器的持久化和同步操作 ！容器间也是可以数据共享的</strong></p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote>
<p>方式一：直接使用命令来挂载 -v</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录：容器内目录</span><br></pre></td></tr></table></figure>

<h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取镜像 </span></span><br><span class="line">[root@localhost ~]# docker pull mysql:5.7</span><br><span class="line"></span><br><span class="line"><span class="comment"># 不挂载数据</span></span><br><span class="line"><span class="comment">## 查看主机是否有msql服务</span></span><br><span class="line">[root@localhost home]# ps -ef |grep mysql</span><br><span class="line">root       13049   12627  0 14:40 pts/5    00:00:00 grep --color=auto mysql</span><br><span class="line"><span class="comment">## 启动mysql容器</span></span><br><span class="line">[root@localhost home]# docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span><br><span class="line">95a10c860fd5ab401b7d29f728addff9b99f1f2a6b28286d78d9d78958843a6b</span><br><span class="line"><span class="comment">## 查看msql容器是否运行</span></span><br><span class="line">[root@localhost home]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">95a10c860fd5   mysql:5.7   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   6 seconds ago   Up 5 seconds   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   kind_shannon</span><br><span class="line"><span class="comment">## 进入mysql容器内</span></span><br><span class="line">[root@localhost home]# docker <span class="built_in">exec</span> -it 95a10c860fd5 /bin/bash</span><br><span class="line"><span class="comment">## 登录mysql</span></span><br><span class="line">root@95a10c860fd5:/# mysql -u root -p</span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection <span class="built_in">id</span> is 2</span><br><span class="line">Server version: 5.7.36 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"><span class="comment">## 查看数据库有哪些</span></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment">## 创建数据库</span></span><br><span class="line">mysql&gt; create database db01;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="comment">## 使用数据库</span></span><br><span class="line">mysql&gt; use db01</span><br><span class="line">Database changed</span><br><span class="line"><span class="comment">## 创建表student</span></span><br><span class="line">mysql&gt; create table student(<span class="built_in">id</span> int,name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"><span class="comment">## 向student表插入数据</span></span><br><span class="line">mysql&gt; insert into student values(1,<span class="string">&#x27;z3&#x27;</span>);</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line"><span class="comment">## 查询student表所有数据</span></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * from student ;</span><br><span class="line">+------+------+</span><br><span class="line">| <span class="built_in">id</span>   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | z3   |</span><br><span class="line">+------+------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * from student;</span><br><span class="line">+------+------+</span><br><span class="line">| <span class="built_in">id</span>   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | z3   |</span><br><span class="line">|    2 | lisi |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment">## 查看数据库默认字符集为latin1</span></span><br><span class="line">mysql&gt; show variables like <span class="string">&#x27;character%&#x27;</span> ;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | latin1                     |</span><br><span class="line">| character_set_connection | latin1                     |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | latin1                     |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器 需要做数据挂载！</span></span><br><span class="line">[root@localhost ~]# docker run -d -p 3306:3306 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /home/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /home/mysql/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql01 mysql:5.7</span><br><span class="line"><span class="comment">#修改字符集</span></span><br><span class="line"><span class="comment"># 创建my.conf并填入以下内容</span></span><br><span class="line">vi /home/mysql/conf/my.cnf</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">  [client]</span><br><span class="line">	default_character_set=utf8</span><br><span class="line">  [mysqld]</span><br><span class="line">	collation_server = utf8_general_ci</span><br><span class="line">	character_set_server = uft8</span><br><span class="line"><span class="comment"># 方法二	</span></span><br><span class="line">	[mysql]</span><br><span class="line">	  default-character-set=utf8mb4</span><br><span class="line">	[mysqld]</span><br><span class="line">	  character_set_server = utf8</span><br><span class="line">	  init_connect=<span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br><span class="line">	  lower_case_table_names=1</span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line">[root@localhost ~]# docker run -d -p 3306:3306 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /home/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /home/mysql/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql01 mysql:5.7 \</span><br><span class="line">--character-set-server=utf8mb4 \</span><br><span class="line">--collation-server=utf8mb4_unicode_ci</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">新项目只考虑utf8mb4</span><br><span class="line">　　UTF-8 编码是一种变长的编码机制，可以用1~4个字节存储字符。</span><br><span class="line"></span><br><span class="line">　　因为历史遗留问题，MySQL 中的 utf8 编码并不是真正的 UTF-8，而是阉割版的，最长只有3个字节。当遇到占4个字节的 UTF-8 编码，例如 emoji 字符或者复杂的汉字，也就是我们通常在聊天时发的小黄脸表情，会导致存储异常。</span><br><span class="line"></span><br><span class="line">　　从 5.5.3 开始，MySQL 开始用 utf8mb4 编码来实现完整的 UTF-8，其中 mb4 表示 most bytes 4，最多占用4个字节，用来兼容四个字节的Unicode（万国码）。utf8mb4是utf8的一个扩展。从 8.0 之后，将会在某个版本开始用 utf8mb4 作为默认字符编码。</span><br><span class="line"><span class="comment"># 重启mysql02</span></span><br><span class="line">docker restart mysql02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="具名与匿名挂载"><a href="#具名与匿名挂载" class="headerlink" title="具名与匿名挂载"></a>具名与匿名挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看卷的命令</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[root@localhost home]# docker volume --<span class="built_in">help</span></span></span><br><span class="line"></span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br><span class="line"></span><br><span class="line">-v 容器内路径！</span><br><span class="line">docker run -d -P</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载</span></span><br><span class="line">[root@localhost home]# docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 卷名：容器内路径</span></span><br><span class="line">[root@localhost home]# docker run -d -P --name nginx02 -v my-nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看挂载路径</span></span><br><span class="line">[root@localhost home]# docker volume inspect my-nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-06-28T22:46:09-04:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-nginx/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有的docker容器内的卷，没有自定义目录的情况下都是在/var/lib/docker/volumes/xxx/_data</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载！</span></span><br><span class="line">-v 容器内路径   # 匿名挂载</span><br><span class="line">-v 卷名：容器内路径 # 具名挂载</span><br><span class="line">-v /宿主机路径:/容器内路径 # 指定路径挂载</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径:ro rw 改变读写权限</span></span><br><span class="line">ro readonly #只读</span><br><span class="line">rw readwrite #读写</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦这个设置容器权限，容器对我们挂载出来的内容就有先限定了！</span></span><br><span class="line"> docker run -d -P --name nginx02 -v my-nginx:/etc/nginx:ro nginx</span><br><span class="line"> docker run -d -P --name nginx02 -v my-nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>Dockerfile 就是用来构建 docker 镜像的构建文件 ！ 命令脚本！</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写dockerfile脚本</span></span><br><span class="line">[root@localhost docker-test-<span class="keyword">volume</span><span class="language-bash">]# vi dockerfile1</span></span><br><span class="line">[root@localhost docker-test-<span class="keyword">volume</span><span class="language-bash">]# <span class="built_in">cat</span> dockerfile1 </span></span><br><span class="line">FORM centos</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;------end------&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@localhost docker-test-<span class="keyword">volume</span><span class="language-bash">]# docker build -f dockerfile1 -t shawn/centos:1.0 .</span></span><br><span class="line">-f 指定dockerfile文件</span><br><span class="line">-t 指定镜像名以及版本</span><br><span class="line">. 在当前目录生成</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据卷同步</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it --name docker03 --volumes-from docker01 shawn/centos:1.0(镜像启动)</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p>
<p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的</p>
<h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>1、每个保留关键字（指令）都是必须是大写字母</p>
<p>2、执行从上到下顺序执行</p>
<p>3、#表示注释</p>
<p>4、每个指令都会创建提交一个新的镜像层，并提交！</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">可写容器（<span class="attribute">container</span>）</span><br><span class="line">镜像（tomcat）</span><br><span class="line">镜像（jdk）</span><br><span class="line"><span class="function"><span class="title">rootfs</span><span class="params">(基础镜像 centos/ubuntu)</span></span></span><br><span class="line">bootfs</span><br></pre></td></tr></table></figure>

<p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p>
<p>Docker镜像逐渐成为企业交付的标准，必须要掌握 ！</p>
<p>步骤：开发 部署 运维 缺一不可 ！</p>
<p>DockerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile构建生成镜像，最终发布与运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务的</p>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>       <span class="comment"># 基础镜像，一切从这里开始构建</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="comment"># 镜像是谁写的，姓名+邮箱</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">        <span class="comment"># 镜像构建的时候需要运行的命令</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash">        <span class="comment"># 步骤：tomcat镜像，这个tomcat压缩包！添加内容</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash">    <span class="comment"># 镜像的工作目录</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash">     <span class="comment"># 挂载的目录</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>     <span class="comment"># 保留端口配置</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">        <span class="comment"># 指定容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="comment"># 指定容器启动的时候要运行的命令，可以追加命令</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span>    <span class="comment"># 当构建一个被继承DockerFile 这个时候就会运行 ONBUILD 的指令。触发指令。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">       <span class="comment"># 类似ADD，将我们文件拷贝到镜像中</span></span></span><br><span class="line"><span class="keyword">ENV</span>        <span class="comment"># 构建的时候设置环境变量！</span></span><br></pre></td></tr></table></figure>



<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span></span><br><span class="line"></span><br><span class="line">功能为指定基础镜像，并且必须是第一条指令。</span><br><span class="line"></span><br><span class="line">如果不以任何镜像为基础，那么写法为：<span class="keyword">FROM</span> scratch。</span><br><span class="line"></span><br><span class="line">同时意味着接下来所写的指令将作为镜像的第一层开始</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;digest&gt; </span><br><span class="line">三种写法，其中&lt;tag&gt;和&lt;digest&gt; 是可选项，如果没有选择，那么默认值为latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"> 功能为运行指定的命令</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">命令有两种格式</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">RUN</span><span class="language-bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line">第一种后边直接跟<span class="keyword">shell</span><span class="language-bash">命令</span></span><br><span class="line"></span><br><span class="line">在linux操作系统上默认 /bin/sh -c</span><br><span class="line"></span><br><span class="line">在windows操作系统上默认 <span class="keyword">cmd</span><span class="language-bash"> /S /C</span></span><br><span class="line"></span><br><span class="line">第二种是类似于函数调用。</span><br><span class="line"></span><br><span class="line">可将executable理解成为可执行文件，后面就是两个参数。</span><br><span class="line"></span><br><span class="line">两种写法比对：</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; echo $HOME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span></span></span><br><span class="line">注意：多行命令不要写多个<span class="keyword">RUN</span><span class="language-bash"><span class="string">，原因是Dockerfile中每一个指令都会建立一层.</span></span></span><br><span class="line"></span><br><span class="line"> 多少个<span class="keyword">RUN</span><span class="language-bash"><span class="string">就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string">书写时的换行符是\</span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">功能为容器启动时要运行的命令</span><br><span class="line"></span><br><span class="line">语法有三种写法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">CMD</span><span class="language-bash"><span class="string"> [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">CMD</span><span class="language-bash"><span class="string"> [&quot;param1&quot;,&quot;param2&quot;]</span></span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">CMD</span><span class="language-bash"><span class="string"> command param1 param2</span></span></span><br><span class="line">第三种比较好理解了，就时<span class="keyword">shell</span><span class="language-bash"><span class="string">这种执行方式和写法</span></span></span><br><span class="line"></span><br><span class="line">第一种和第二种其实都是可执行文件加上参数的形式</span><br><span class="line"></span><br><span class="line">举例说明两种写法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; </span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> [ &quot;echo&quot;, &quot;$HOME&quot; ]</span></span></span><br><span class="line">补充细节：这里边包括参数的一定要用双引号，就是<span class="string">&quot;,不能是单引号。千万不能写成单引号。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">原因是参数传递后，docker解析的是一个JSON array</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN &amp; CMD</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">不要把RUN和CMD搞混了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN是构件容器时就运行的命令以及提交运行结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CMD是容器启动时执行的命令，在构件时并不运行，构件时紧紧指定了这个命令到底是个什么样子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LABEL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">功能是为镜像指定标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br><span class="line"><span class="string"> 一个Dockerfile种可以有多个LABEL，如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LABEL &quot;</span>com.example.vendor<span class="string">&quot;=&quot;</span>ACME Incorporated<span class="string">&quot;</span></span><br><span class="line"><span class="string">LABEL com.example.label-with-value=&quot;</span>foo<span class="string">&quot;</span></span><br><span class="line"><span class="string">LABEL version=&quot;</span><span class="number">1.0</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">LABEL description=&quot;</span>This text illustrates \</span><br><span class="line">that <span class="keyword">label</span><span class="language-bash"><span class="string">-values can span multiple lines.&quot;</span></span></span><br><span class="line"> 但是并不建议这样写，最好就写成一行，如太长需要换行的话则使用\符号</span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"><span class="string"> multi.label1=&quot;value1&quot; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">multi.label2=&quot;value2&quot; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">other=&quot;value3&quot;</span></span></span><br><span class="line">说明：<span class="keyword">LABEL</span><span class="language-bash"><span class="string">会继承基础镜像种的LABEL，如遇到key相同，则值覆盖</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span></span><br><span class="line"></span><br><span class="line">指定作者</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br><span class="line"><span class="keyword">EXPOSE</span></span><br><span class="line"></span><br><span class="line">功能为暴漏容器运行时的监听端口给外部</span><br><span class="line"></span><br><span class="line">但是<span class="keyword">EXPOSE</span>并不会使容器访问主机的端口</span><br><span class="line"></span><br><span class="line">如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span></span><br><span class="line"></span><br><span class="line">功能为设置环境变量</span><br><span class="line"></span><br><span class="line">语法有两种</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">两者的区别就是第一种是一次设置一个，第二种是一次设置多个</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line"> 一个复制命令，把文件复制到景象中。</span><br><span class="line"></span><br><span class="line">如果把虚拟机与容器想象成两台linux服务器的话，那么这个命令就类似于scp，只是scp需要加用户名和密码的权限验证，而<span class="keyword">ADD</span><span class="language-bash"><span class="string">不用。</span></span></span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">ADD</span><span class="language-bash"><span class="string"> &lt;src&gt;... &lt;dest&gt;</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">ADD</span><span class="language-bash"><span class="string"> [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></span><br><span class="line">&lt;dest&gt;路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径</span><br><span class="line"></span><br><span class="line">&lt;src&gt;可以是一个本地文件或者是一个本地压缩文件，还可以是一个url</span><br><span class="line"></span><br><span class="line">如果把&lt;src&gt;写成一个url，那么<span class="keyword">ADD</span><span class="language-bash"><span class="string">就类似于wget命令</span></span></span><br><span class="line"></span><br><span class="line">如以下写法都是可以的：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"> test relativeDir/ </span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"> test /relativeDir</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"> http://example.com/foobar /</span></span></span><br><span class="line">尽量不要把&lt;scr&gt;写成一个文件夹，如果&lt;src&gt;是一个文件夹了，复制整个目录的内容,包括文件系统元数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">看这个名字就知道，又是一个复制命令</span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">COPY</span><span class="language-bash"><span class="string"> &lt;src&gt;... &lt;dest&gt;</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">COPY</span><span class="language-bash"><span class="string"> [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></span><br><span class="line">与<span class="keyword">ADD</span><span class="language-bash"><span class="string">的区别</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"><span class="string">的&lt;src&gt;只能是本地文件，其他用法一致</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">功能是启动时的默认命令</span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> command param1 param2</span></span></span><br><span class="line">如果从上到下看到这里的话，那么你应该对这两种语法很熟悉啦。</span><br><span class="line"></span><br><span class="line">第二种就是写<span class="keyword">shell</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">第一种就是可执行文件加参数</span><br><span class="line"></span><br><span class="line">与<span class="keyword">CMD</span><span class="language-bash"><span class="string">比较说明（这俩命令太像了，而且还可以配合使用）：</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 相同点：</span><br><span class="line"></span><br><span class="line">只能写一条，如果写了多条，那么只有最后一条生效</span><br><span class="line"></span><br><span class="line">容器启动时才运行，运行时机相同</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 不同点：</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string">不会被运行的command覆盖，而CMD则会被覆盖</span></span></span><br><span class="line"></span><br><span class="line"> 如果我们在Dockerfile种同时写了<span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string">和CMD，并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数</span></span></span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> [&quot;top&quot;, &quot;-b&quot;]</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> [&quot;-c&quot;]</span></span></span><br><span class="line">如果我们在Dockerfile种同时写了<span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string">和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效</span></span></span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> [&quot;top&quot;, &quot;-b&quot;]</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> ls -al</span></span></span><br><span class="line">那么将执行ls -al ,top -b不会执行。</span><br><span class="line"></span><br><span class="line">Docker官方使用一张表格来展示了<span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> 和CMD不同组合的执行情况</span></span></span><br><span class="line"></span><br><span class="line">（下方表格来自docker官网）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">可实现挂载功能，可以将内地文件夹或者其他容器种得文件夹挂在到这个容器种</span><br><span class="line"></span><br><span class="line">语法为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> [&quot;/data&quot;]</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">   [<span class="string">&quot;/data&quot;</span>]可以是一个JsonArray ，也可以是多个值。所以如下几种写法都是正确的</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> [&quot;/var/log/&quot;]</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> /var/log</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> /var/log /var/db</span></span></span><br><span class="line">一般的使用场景为需要持久化存储数据时</span><br><span class="line"></span><br><span class="line">容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。</span><br><span class="line"></span><br><span class="line">所以当数据需要持久化时用这个命令。</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span></span><br><span class="line"></span><br><span class="line">设置启动容器的用户，可以是用户名或UID，所以，只有下面的两种写法是正确的</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> daemo</span><br><span class="line"><span class="keyword">USER</span> UID</span><br><span class="line">注意：如果设置了容器以daemon用户去运行，那么<span class="keyword">RUN</span><span class="language-bash"><span class="string">, CMD 和 ENTRYPOINT 都会以这个用户去运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> /path/to/workdir</span></span></span><br><span class="line">设置工作目录，对<span class="keyword">RUN</span><span class="language-bash"><span class="string">,CMD,ENTRYPOINT,COPY,ADD生效。如果不存在则会创建，也可以设置多次。</span></span></span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> /a</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> b</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> c</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> pwd</span></span></span><br><span class="line">pwd执行的结果是/a/b/c</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string">也可以解析环境变量</span></span></span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> $DIRPATH/$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> pwd</span></span></span><br><span class="line">pwd的执行结果是/path/$DIRNAME</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line">设置变量命令，<span class="keyword">ARG</span>命令定义了一个变量，在docker build创建镜像的时候，使用 --build-<span class="keyword">arg</span> &lt;varname&gt;=&lt;value&gt;来指定参数</span><br><span class="line"></span><br><span class="line">如果用户在build镜像时指定了一个参数没有定义在Dockerfile种，那么将有一个Warning</span><br><span class="line"></span><br><span class="line">提示如下：</span><br><span class="line"></span><br><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">我们可以定义一个或多个参数，如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1</span><br><span class="line"><span class="keyword">ARG</span> buildno</span><br><span class="line">...</span><br><span class="line">也可以给参数一个默认值：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1=someuser</span><br><span class="line"><span class="keyword">ARG</span> buildno=<span class="number">1</span></span><br><span class="line">...</span><br><span class="line">如果我们给了<span class="keyword">ARG</span>定义的参数默认值，那么当build镜像时没有指定参数值，将会使用这个默认值</span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br><span class="line">这个命令只对当前镜像的子镜像生效。</span><br><span class="line"></span><br><span class="line">比如当前镜像为A，在Dockerfile种添加：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"><span class="string"> ls -al</span></span></span><br><span class="line">这个 ls -al 命令不会在A镜像构建或启动的时候执行</span><br><span class="line"></span><br><span class="line">此时有一个镜像B是基于A镜像构建的，那么这个ls -al 命令会在B镜像构建的时候被执行。</span><br><span class="line"></span><br><span class="line"><span class="keyword">STOPSIGNAL</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br><span class="line"><span class="keyword">STOPSIGNAL</span>命令是的作用是当容器推出时给系统发送什么样的指令</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line"> 容器健康状况检查命令</span><br><span class="line"></span><br><span class="line">语法有两种：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"> [OPTIONS] CMD command</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"> NONE</span></span></span><br><span class="line">第一个的功能是在容器内部运行一个命令来检查容器的健康状况</span><br><span class="line"></span><br><span class="line">第二个的功能是在基础镜像中取消健康检查命令</span><br><span class="line"></span><br><span class="line">[OPTIONS]的选项支持以下三中选项：</span><br><span class="line"></span><br><span class="line">    --interval=DURATION 两次检查默认的时间间隔为<span class="number">30</span>秒</span><br><span class="line"></span><br><span class="line">    --timeout=DURATION 健康检查命令运行超时时长，默认<span class="number">30</span>秒</span><br><span class="line"></span><br><span class="line">    --retries=N 当连续失败指定次数后，则容器被认为是不健康的，状态为unhealthy，默认次数是<span class="number">3</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string">命令只能出现一次，如果出现了多次，只有最后一个生效。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string">后边的命令的返回值决定了本次健康检查是否成功，具体的返回值如下：</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: success - 表示容器是健康的</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: unhealthy - 表示容器已经不能工作了</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: reserved - 保留值</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"> --interval=5m --timeout=3s \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">CMD curl -f http://localhost/ || exit 1</span></span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">健康检查命令是：curl -f http://localhost/ || exit <span class="number">1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker容器数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫</title>
    <url>/2023/09/25/java/java-spider/</url>
    <content><![CDATA[<p>Java编写的开源Web爬虫</p>
<ol>
<li>Apache Nutch<br>实现语言： Java<br>GitHub星标数： 1743<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>Apache Nutch是一种高度可扩展、可伸缩的开源Web爬虫软件项目。<br>如果要列出最好的开源Web爬虫列表，Apache Nutch无疑金榜题名。<br>作为一种用于数据挖掘的高度可扩展、可伸缩的开源代码Web数据抽取软件项目，Apache Nutch得到了广泛的使用。<br>Nutch支持单机运行，但是在Hadoop集群上运行可最大化地发挥其强大能力。<br>全球范围内很多数据分析人员和科研人员、应用开发人员和Web文本挖掘工程师都在使用Apache Nutch。<br>Apache Nutch是一种Java编写的跨平台解决方案。<br>特性：</p>
<p>默认情况下，爬取数据和分析数据是独立的过程。<br>广泛支持多种文档格式，包括纯文本、HTML&#x2F;XHTML+XML、XML、PDF、ZIP等。<br>使用XPath和命名空间实现映射。<br>通过Hadoop支持分布式文件系统。<br>链接图形式的数据库。<br>支持NTLM认证。<br>– 官方文档： <a href="https://wiki.apache.org/nutch/">https://wiki.apache.org/nutch/</a></p>
<p>– 官方网站： <a href="http://nutch.apache.org/">http://nutch.apache.org/</a></p>
<span id="more"></span>
<ol start="2">
<li>Heritrix<br> 实现语言： Java<br> GitHub星标数： 1236<br> 官方支持链接<br> 简介：</li>
</ol>
<p>在使用Java编写的免费开源Web爬虫中，Heritrix是其中一种得到广泛使用的工具。事实上，它是一种可扩展、Web规模、存档质量（archival-quality）的Web爬取项目。<br>Heritrix是一种扩展能力和性能很好的解决方案，支持用户即刻爬取并归档一组网站。此外，它在设计上考虑了robots.txt禁止规则和META机器人标签。<br>Heritrix可运行在Linux&#x2F;Unix和Windows系统上。<br>特性：</p>
<p>HTTP认证。<br>NTLM认证。<br>链接抽取中的XSL转换。<br>独立于搜索引擎。<br>是一种成熟并稳定的平台。<br>高度可配置。<br>支持在任一机器上运行。<br>– 官方文档： <a href="https://github.com/internetarchive/heritrix3/wiki/Heritrix%203.0%20and%203.1%20User%20Guide">https://github.com/internetarchive/heritrix3/wiki/Heritrix%203.0%20and%203.1%20User%20Guide</a></p>
<p>– 官方网站： <a href="https://github.com/internetarchive/heritrix3b">https://github.com/internetarchive/heritrix3b</a><br>3. ACHE爬虫<br>    实现语言： Java<br>    GitHub星标数： 154<br>    官方支持链接</p>
<p>简介：</p>
<p>ACHE是一种专用于特定用途的Web爬虫。<br>ACHE爬取满足特定标准的Web页面。例如，属于特定领域并包含用户指定模式的页面。<br>不同于通用爬虫，ACHE使用页面分类器遴选特定领域中的相关和无关页面。<br>页面分类器可以是基本的正则表达式（例如，匹配所有包含给定单词的页面），也可以基于机器学习的分类模型。ACHE也可以自动学习如何对链接做优先处理，实现高效地定位相关内容，避免检索无关的页面内容。<br>特性：</p>
<p>对固定网站列表的正常爬取。<br>通过自动链接优先处理，发现并爬取新的相关网站。<br>可配置不同类型的页面分类器（例如，机器学习、正则表达式等）。<br>持续重新爬取站点，实现页面更新的发现。<br>使用ElasticSearch对爬取页面做索引。<br>实时搜索爬取页面的Web接口。<br>用于监控爬虫的REST API和基于Web的用户接口。<br>使用TOR代理爬取隐含服务。<br>– 官方文档： <a href="http://ache.readthedocs.io/en/latest/">http://ache.readthedocs.io/en/latest/</a></p>
<p>– 官方网站： <a href="https://github.com/ViDA-NYU/ache">https://github.com/ViDA-NYU/ache</a></p>
<ol start="4">
<li>Crawler4j<br> 实现语言： Java<br> GitHub星标数： 3039<br> 官方支持链接<br> 简介：</li>
</ol>
<p>crawler4j是一种Java编写的开源Web爬虫，提供了爬取Web网站的基本接口。<br>开发人员可以使用crawler4j在数分钟内建立一个多线程Web爬虫。<br>– 官方文档： <a href="https://github.com/yasserg/crawler4j">https://github.com/yasserg/crawler4j</a></p>
<p>– 官方网站： <a href="https://github.com/yasserg/crawler4j">https://github.com/yasserg/crawler4j</a></p>
<ol start="5">
<li>Gecco<br> 实现语言： Java<br> GitHub星标数： 1245<br> 官方支持链接<br> 简介：</li>
</ol>
<p>Gecco是一种使用Java开发的轻量级Web爬虫，易于使用。<br>Gecco集成了jsoup、httpclient、fastjson、spring、htmlunit、redission等优秀框架。用户只需要配置一系列jQuery风格选择器，就能很快地建立一个爬虫。<br>Gecco框架具有优秀的扩展能力。框架基于一些开放式和封闭式设计原则，对改进封闭，对扩展开放。<br>特性：</p>
<p>易于使用，使用jQuery风格选择器抽取元素。<br>支持页面中的异步Ajax请求。<br>支持页面JavaScript变量抽取。<br>使用Redis实现分布式爬取（参见gecco-redis文档）。<br>支持使用Spring开发业务逻辑（参见gecco-spring文档）。<br>支持htmlunit扩展（参见gecco-htmlunit文档）。<br>支持多种扩展机制。<br>支持下载UserAgent的随机选择。<br>支持下载代理服务器的随机选取。<br>– 官方文档： <a href="https://github.com/xtuhcy/gecco">https://github.com/xtuhcy/gecco</a></p>
<p>– 官方网站： <a href="https://github.com/xtuhcy/gecco">https://github.com/xtuhcy/gecco</a></p>
<ol start="6">
<li>BUbiNG<br> 实现语言： Java<br> GitHub星标数：24<br> 官方支持链接<br> 简介：</li>
</ol>
<p>BUbiNG令人惊喜，它可称为下一代的开源Web爬虫。BUbiNG是一种Java开发的完全分布式爬虫（无需中央协调），每秒可爬取数千个网页，并支持采集大规模数据集。<br>BUbiNG的分布式是基于高速协议实现的，因此可以获得非常高的通量。<br>BUbiNG提供对海量数据的大规模爬取。它完全可配置、易于扩展，并可集成垃圾信息检测。<br>特性：</p>
<p>高度并行。<br>完全分布式。<br>使用JAI4J。JAI4J是一种基于JGroups实现的瘦功能层，实现任务指派。<br>（当前）使用剥离网页的指纹，检测近似的重复内容。<br>快速。<br>大规模爬取。<br>– 官方文档： <a href="http://law.di.unimi.it/software/bubing-docs/index.html">http://law.di.unimi.it/software/bubing-docs/index.html</a></p>
<p>– 官方网站： <a href="http://law.di.unimi.it/software.php#bubing">http://law.di.unimi.it/software.php#bubing</a></p>
<ol start="7">
<li>Narconex<br> 实现语言：Java<br> 官方支持链接</li>
</ol>
<p>简介：</p>
<p>对于寻求可满足企业级需求的开源Web爬虫的用户而言，Narconex是一种很好的工具。<br>Norconex支持用户爬取任何Web内容。用户可以独立运行这种全功能数据采集器，或是将其集成在自己的应用中。<br>支持所有操作系统。可在具有一般容量的单体服务器上爬取数百万信息。此外，Narconex提供多种内容和元数据操作特性，还可以抽取页面中特定的图像。<br>特性：</p>
<p>多线程。<br>支持按各种计划任务，抽取不同时间段的数据。<br>从HTML、Word、PDF等多种文件格式中抽取文本内容。<br>抽取文档相关的元数据。<br>支持抽取使用用JavaScript渲染的页面。<br>检测语言。<br>支持翻译。<br>可配置爬取速度。<br>可检测发生修改或已被删除的文档。<br>支持使用外部命令分析或操作文档。<br>– 官方文档： <a href="http://www.norconex.com/collectors/collector-http/getting-started">http://www.norconex.com/collectors/collector-http/getting-started</a></p>
<p>– 官方网站： <a href="http://www.norconex.com/collectors/collector-http/">http://www.norconex.com/collectors/collector-http/</a></p>
<ol start="8">
<li>WebSPHINX<br> 实现语言： Java<br> 当前尚不提供官方支持。</li>
</ol>
<p>简介：</p>
<p>WebSphinix是一种非常易于使用的可定制Web爬虫。它设计用于高级Web用户和Java编程人员，支持他们自动爬取小部分Web。<br>WebSphinix数据抽取解决方案也提供了一种全面的Java类库和交互式软件开发环境。WebSphinix包括两部分：爬虫基准测试（Crawler Workbench），WebSPHINX类库。<br>爬虫基准测试提供了很好的用户图形接口，支持用户配置并控制定制的Web爬虫。<br>WebSPHINX类库为使用Java编写Web爬虫提供支持。<br>WebSphinix支持运行在Windows、Linux、Mac和Android IOS上。<br>特性：</p>
<p>以图的方式可视化Web页面采集。<br>将多个页面组合为单个文档，以供查看和打印。<br>支持抽取所有满足设定模式的文本。<br>支持HTML解析。<br>支持robot.txt禁止标准。<br>通用HTML转换。<br>多线程Web页面检索。<br>– 官方文档： <a href="https://www.cs.cmu.edu/~rcm/websphinx/doc/index.html">https://www.cs.cmu.edu/~rcm/websphinx/doc/index.html</a></p>
<p>– 官方网站： <a href="https://www.cs.cmu.edu/~rcm/websphinx/#about">https://www.cs.cmu.edu/~rcm/websphinx/#about</a></p>
<ol start="9">
<li>Spiderman<br> 实现语言： Java<br> GitHub星标数： 2400<br> 官方支持链接<br> 简介：</li>
</ol>
<p>Spiderman是一种Java开源Web数据抽取工具。它采集特定的Web页面，并从中抽取有用数据。<br>Spiderman主要使用XPath和正则表达式等技术抽取实际数据。<br>特性：</p>
<p>更高的性能。<br>持久化集合状态。<br>分布式。<br>支持JavaScript。</p>
<p>– 官方文档： <a href="https://gitee.com/l-weiwei/spiderman">https://gitee.com/l-weiwei/spiderman</a><br>– 官方网站： <a href="https://gitee.com/l-weiwei/spiderman">https://gitee.com/l-weiwei/spiderman</a></p>
<ol start="10">
<li>WebCollector :<br>实现语言： Java<br>GitHub星标数： 1986<br>官方支持链接<br>简介：</li>
</ol>
<p>WebCollector是一种基于Java的开源Web爬虫框架。<br>它为实现Web爬取功能提供了一下基本的接口。用户可以使用它在五分钟内建立起一个多线程爬虫。<br>特性：</p>
<p>快速。<br>– 官方文档： <a href="https://github.com/CrawlScript/WebCollector">https://github.com/CrawlScript/WebCollector</a></p>
<p>– 官方网站： <a href="https://github.com/CrawlScript/WebCollector">https://github.com/CrawlScript/WebCollector</a></p>
<ol start="11">
<li>Webmagic<br>实现语言： Java<br>GitHub星标数： 6891<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>WebMagic是一种可扩展的爬虫框架。<br>WebMagic涵盖了爬虫的整个生命周期，包括下载、URL管理、内容抽取和持久化。<br>可用于简化一些特定爬虫的开发。<br>特性：</p>
<p>高度灵活的简单内核。<br>提供实现HTML抽取的简单API。<br>使用POJO标注定制爬虫，无需配置。<br>支持多线程和分布式。<br>易于集成。<br>– 官方文档： <a href="http://webmagic.io/docs/en/">http://webmagic.io/docs/en/</a></p>
<p>– 官方网站： <a href="https://github.com/code4craft/webmagic">https://github.com/code4craft/webmagic</a></p>
<ol start="12">
<li>StormCrawler<br>实现语言： Java<br>GitHub星标数：437<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>StormCrawler是一种基于Apache Storm构架分布式Web爬虫的开源SDK。<br>StormCrawler为开发人员构建爬虫提供了软件库和一系列资源。<br>StormCrawler完全适用于以数据流提供需获取和解析的URL的情况，也非常适用于大规模递归性爬取，尤其是需要低延迟的情况。<br>特性：</p>
<p>可扩展。<br>有弹性。<br>低延迟。<br>易于扩展。<br>运行良好且高效。<br>– 官方文档： <a href="http://stormcrawler.net/docs/api/">http://stormcrawler.net/docs/api/</a></p>
<p>– 官方网站： <a href="http://stormcrawler.net/">http://stormcrawler.net/</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Java爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc连接数据库SSL</title>
    <url>/2022/07/17/java/jdbc-SSL/</url>
    <content><![CDATA[<h4 id="在Java8及高版本以上的版本在调用ssl时会出现javax-net-ssl-SSLHandshakeException-No-appropriate-protocol的异常。"><a href="#在Java8及高版本以上的版本在调用ssl时会出现javax-net-ssl-SSLHandshakeException-No-appropriate-protocol的异常。" class="headerlink" title="在Java8及高版本以上的版本在调用ssl时会出现javax.net.ssl.SSLHandshakeException: No appropriate protocol的异常。"></a>在Java8及高版本以上的版本在调用ssl时会出现<code>javax.net.ssl.SSLHandshakeException: No appropriate protocol</code>的异常。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: No appropriate <span class="title function_">protocol</span> <span class="params">(protocol is disabled or cipher suites are inappropriate)</span></span><br><span class="line">	at sun.security.ssl.HandshakeContext.&lt;init&gt;(HandshakeContext.java:<span class="number">171</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at sun.security.ssl.ClientHandshakeContext.&lt;init&gt;(ClientHandshakeContext.java:<span class="number">98</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at sun.security.ssl.TransportContext.kickstart(TransportContext.java:<span class="number">220</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:<span class="number">428</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at com.mysql.cj.protocol.ExportControlled.performTlsHandshake(ExportControlled.java:<span class="number">316</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	at com.mysql.cj.protocol.StandardSocketFactory.performTlsHandshake(StandardSocketFactory.java:<span class="number">188</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeSocketConnection.performTlsHandshake(NativeSocketConnection.java:<span class="number">99</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeProtocol.negotiateSSLConnection(NativeProtocol.java:<span class="number">331</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	... <span class="number">68</span> common frames omitted</span><br></pre></td></tr></table></figure>


<h4 id="解决办法如下："><a href="#解决办法如下：" class="headerlink" title="解决办法如下："></a>解决办法如下：</h4><ol>
<li>修改<code>jre/lib/security/java.security</code>中的<code>disabledAlgorithms</code>，删除<code>SSLv3, TLSv1, TLSv1.1</code>，然后重启应用即可。在vim下，可以使用<code>/disabledAlgorithms</code>快速查找。</li>
</ol>
<p><code>jdk.tls.disabledAlgorithms=RC4, DES, MD5withRSA, \     DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \     include jdk.disabled.namedCurves</code></p>
<p>如果修改了，保存了，重启了还是没有效果，就看下面这个方法：</p>
<ol start="2">
<li>修改jdk配置文件<code>/etc/crypto-policies/back-ends/java.config</code>，类似上面方法一样，删除<code>SSLv3, TLSv1, TLSv1.1</code>，保存重启应用。</li>
</ol>
<p><code>jdk.tls.disabledAlgorithms=DH keySize &lt; 2048, SSLv2, SSLv3, TLSv1.1, DHE_DSS, RSA_EXPORT, DHE_DSS_EXPORT, DHE_RSA_EXPORT, DH_DSS_EXPORT, DH_RSA_EXPORT, DH_anon, ECDH_anon, DH_RSA, DH_DSS, ECDH, 3DES_EDE_CBC, DES_CBC, RC4_40, RC4_128, DES40_CBC, RC2, HmacMD5</code></p>
<ol start="3">
<li><p>另外jdk奇数版本可用，偶数版本有上面这个问题，可用通过<code>yum --showduplicate list java* | grep 1.8.0</code>查看可用的版本，选择奇数版本安装也能解决这个问题。</p>
</li>
<li><p>更新crypto-policies</p>
<p><code>update-crypto-policies --set LEGACY</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>数据库查询</category>
      </categories>
      <tags>
        <tag>jdbc</tag>
      </tags>
  </entry>
  <entry>
    <title>js模块化</title>
    <url>/2022/08/14/js/js/</url>
    <content><![CDATA[<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2>]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>js模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>TS的!和?用法</title>
    <url>/2022/09/11/js/TS/</url>
    <content><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="!用法"></a>!用法</h2><ul>
<li><p>用在变量前表示取反</p>
</li>
<li><p>用在赋值的内容后时，使null和undefined类型可以赋值给其他类型并通过编译，表示该变量值可空</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">y = <span class="literal">null</span>		<span class="comment">// 无法通过编译</span></span><br><span class="line">y = <span class="literal">undefined</span>	<span class="comment">// 无法通过编译</span></span><br><span class="line"></span><br><span class="line">y = <span class="literal">null</span>!</span><br><span class="line">y = <span class="literal">undefined</span>!</span><br><span class="line"><span class="comment">// 由于x是可选的，因此parma.x的类型为number | undefined，无法传递给number类型的y，因此需要用x!</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line"><span class="attr">x</span>?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params"><span class="attr">parma</span>: <span class="title class_">IDemo</span></span>) =&gt; &#123;</span><br><span class="line">y = parma.<span class="property">x</span>!</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果存在空情况的判断并赋具体值时，可以不用!，但是如果要想令y存在等于undefined的情况还是需要用!</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line"><span class="attr">x</span>?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params"><span class="attr">parma</span>: <span class="title class_">IDemo</span></span>) =&gt; &#123;</span><br><span class="line">y = parma.<span class="property">x</span> || <span class="number">1</span>	<span class="comment">// 如果为undefined，返回y=1，如果不为undefined，则返回parma.x的值</span></span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="?用法"></a>?用法</h2><ul>
<li>除了表示可选参数外，常用于防御性编程<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title function_">fetch</span>(...) || &#123;&#125;		<span class="comment">// 假设a是从后端拿到的一个对象类型数据</span></span><br><span class="line"><span class="keyword">const</span> unsafeData = a.<span class="property">b</span>.<span class="property">c</span>		<span class="comment">// 这样写时不安全的，无法确保b是否有值，如果为空则b.c会进行报错</span></span><br><span class="line"><span class="keyword">const</span> safeData = a?.<span class="property">b</span>?.<span class="property">c</span>		<span class="comment">// 实际上就是相当于 const safeData = a &amp;&amp; a.b &amp;&amp; a.b.c</span></span><br><span class="line">当使用A对象属性A.<span class="property">B</span>时，如果无法确定A是否为空，则需要用A?.<span class="property">B</span>，表示当A有值的时候才去访问B属性，没有值的时候就不去访问，如果不使用?则会报错</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于函数参数可选，因此parma无法确定是否拥有，所以无法正常使用parma.x，使用parma?.x向编译器假设此时parma不为空且为IDemo类型，同时parma?.x无法保证非空，因此使用parma?.x!来保证了整体通过编译</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params"><span class="attr">parma</span>?: <span class="title class_">IDemo</span></span>) =&gt; &#123;</span><br><span class="line">y = parma?.<span class="property">x</span>!</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parma?.<span class="property">x</span>)	<span class="comment">// 只是单纯调用属性时就无需!</span></span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用y = parma!.x!是会报错的，因为当parma为空时，是不拥有x属性的，会报找不到x的错误</span></span><br><span class="line">但是?用法只能读操作而不能写操作，对一个可能为空的属性赋值是不会被编译通过的，此时还需用用到类型断言</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错，不能赋值给可选属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params"><span class="attr">parma</span>?: <span class="title class_">IDemo</span></span>) =&gt; &#123;</span><br><span class="line">parma?.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言  </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo_</span> = (<span class="params"><span class="attr">parma</span>?: <span class="title class_">IDemo</span></span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> _parma = parma <span class="keyword">as</span> <span class="title class_">IDemo</span></span><br><span class="line">_parma.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TS</category>
      </categories>
      <tags>
        <tag>TS的!和?用法</tag>
      </tags>
  </entry>
  <entry>
    <title>题目</title>
    <url>/2024/02/07/node-register/nvm-pnpm/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/m0_73991249/article/details/141418185">nvm 在 vscode 中切换失败问题</a></p>
<p><a href="https://blog.csdn.net/qq_47753695/article/details/140617373">pnpm 的安装与使用_pnpm 环境变量设置-CSDN 博客</a></p>
]]></content>
      <tags>
        <tag>标签</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎高级搜索技巧</title>
    <url>/2022/06/03/others/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h5 id="逻辑与-或"><a href="#逻辑与-或" class="headerlink" title="逻辑与&#x2F;或"></a><em><strong>逻辑与&#x2F;或</strong></em></h5><hr>
<ul>
<li>注意AND、OR必须大写，否则会被认为是普通的单词，而不是搜索指令</li>
<li>与普通编程语言不一样的是，OR指令优先于AND指令</li>
<li>简写：AND指令一般以空格代替，不明确写出。另外AND指令还可以用+代替。OR指令可用|代替</li>
</ul>
<h5 id="逻辑非："><a href="#逻辑非：" class="headerlink" title="逻辑非：-"></a><em><strong>逻辑非：-</strong></em></h5><hr>
<ul>
<li>样例：搜索引擎 历史 -文化 -中国历史 -世界历史</li>
</ul>
<h5 id="完整匹配-“-“"><a href="#完整匹配-“-“" class="headerlink" title="完整匹配 “ “"></a><em><strong>完整匹配 “ “</strong></em></h5><hr>
<ul>
<li>样例：”world war I” 表示搜索一次世界大战</li>
</ul>
<h5 id="通配符："><a href="#通配符：" class="headerlink" title="通配符：*?"></a><em><strong>通配符：*?</strong></em></h5><hr>
<ul>
<li>与我们通常的习惯一致，“*”代表一连串字符，“?”代表单个字符</li>
</ul>
<h5 id="site-在某个网站或域名下搜索"><a href="#site-在某个网站或域名下搜索" class="headerlink" title="site: 在某个网站或域名下搜索"></a><em><strong>site: 在某个网站或域名下搜索</strong></em></h5><hr>
<ul>
<li>样例：搜索引擎 技巧 site:edu.cn</li>
<li>这表示要在中文教育科研网站（edu.cn）上关于搜索引擎技巧的页面</li>
</ul>
<h5 id="filetype-搜索某种类型的文件"><a href="#filetype-搜索某种类型的文件" class="headerlink" title="filetype: 搜索某种类型的文件"></a><em><strong>filetype: 搜索某种类型的文件</strong></em></h5><hr>
<ul>
<li>样例：天文学 filetype:pdf </li>
<li>简写: 天文学:pdf</li>
<li>这表示只搜索pdf文件</li>
<li>tips：样例 天文学三个字位置任意写</li>
</ul>
<h5 id="in指令-位置关键词查找"><a href="#in指令-位置关键词查找" class="headerlink" title="in指令: 位置关键词查找"></a><em><strong>in指令: 位置关键词查找</strong></em></h5><hr>
<ul>
<li>intitle: 在网页标题中查找。这通常对讨论比较多的热门话题很有效。例如：intitle:”GeForce 7800”+测试</li>
<li>例如：allintitile:”GeForce 7800” 测试 与 intitle:”GeForce 7800”+测试 的含义一致。但是，allintitile是排他的，不能加上其他非intitle方面的限制条件</li>
<li>inurl: 在网页的url地址中查找。例如：inurl:dowload 表示查找url中包含download的网页</li>
<li>allinurl: inurl的排他指令</li>
<li>inanchor: 在网页的链接锚中查找</li>
</ul>
<h5 id="link-搜索所有链接到某个URL地址的网页"><a href="#link-搜索所有链接到某个URL地址的网页" class="headerlink" title="link: 搜索所有链接到某个URL地址的网页"></a><em><strong>link: 搜索所有链接到某个URL地址的网页</strong></em></h5><hr>
<ul>
<li>例如：link:<a href="http://www.newhua.com/">www.newhua.com</a> 表示所有指向“华军软件园”外部链接。</li>
</ul>
<h5 id="related-寻找某网页的“类似网页”"><a href="#related-寻找某网页的“类似网页”" class="headerlink" title="related: 寻找某网页的“类似网页”"></a><em><strong>related: 寻找某网页的“类似网页”</strong></em></h5><hr>
<ul>
<li>例如：related:<a href="http://www.newhua.com/">www.newhua.com</a> 表示找和“华军软件园”类似的网页。</li>
</ul>
<h5 id="cache-网页快照（略"><a href="#cache-网页快照（略" class="headerlink" title="cache: 网页快照（略)"></a><em><strong>cache: 网页快照（略)</strong></em></h5><hr>
<ul>
<li>查看网站的 Google 缓存版本，会直接显示缓存页面	</li>
<li>cache:weibo.com	查看微博的谷歌快照</li>
</ul>
<h5 id="daterange-查找特定时间网页"><a href="#daterange-查找特定时间网页" class="headerlink" title="daterange 查找特定时间网页"></a><em><strong>daterange 查找特定时间网页</strong></em></h5><hr>
<ul>
<li>例如：”Spice Girls“ daterange:2450958-2450968。这里时间日期的格式是按天文学的儒略日</li>
<li>儒略日数（Julian Day Number，JDN）的计算是从格林威治标准时间的中午开始，包含一个整天的时间，起点的时间（0日）回溯至儒略历的公元前4713年1月1日中午12点（在格里历是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的UT12:00是儒略日2,451,545。</li>
<li>世界时UT即格林尼治平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式。以地球自转为基础的时间计量系统。</li>
<li>格林尼治（Greenwich），是英国伦敦的一个区，位于伦敦东南、泰晤士河南岸</li>
</ul>
<h5 id="表示数值范围"><a href="#表示数值范围" class="headerlink" title=".. 表示数值范围"></a><em><strong>.. 表示数值范围</strong></em></h5><hr>
<ul>
<li>例如：数码相机 600..900 万像素 3000..4000 元</li>
<li>注意：“900”与“万”之间必须有空格。</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title="@"></a><em><strong>@</strong></em></h5><hr>
<ul>
<li>在用于搜索社交媒体的字词前加上@	trump @twitter	搜索trump的twitter</li>
</ul>
<h5 id="-1"><a href="#-1" class="headerlink" title="$"></a><em><strong>$</strong></em></h5><hr>
<ul>
<li>在数字前加上$搜索特定价格	camera $400	搜索400$的camera</li>
</ul>
<h5 id="-2"><a href="#-2" class="headerlink" title="#"></a><em><strong>#</strong></em></h5><hr>
<ul>
<li>搜索 # 标签	#throwbackthursday	</li>
<li>搜索标签throwbackthursday</li>
</ul>
<h5 id="info"><a href="#info" class="headerlink" title="info"></a><em><strong>info</strong></em></h5><hr>
<ul>
<li>在网址前加info:，获取网站详情	info:github.com	搜索github网站详情</li>
</ul>
<h5 id="intext"><a href="#intext" class="headerlink" title="intext"></a><em><strong>intext</strong></em></h5><hr>
<ul>
<li>搜索查询词出现在页面正文(title)中的页面，支持中文和英文	SEO intext:搜索引擎	在正文包含【搜索引擎】的网页中搜索【SEO】</li>
</ul>
<h5 id="allintext"><a href="#allintext" class="headerlink" title="allintext"></a><em><strong>allintext</strong></em></h5><hr>
<ul>
<li>即all+inanchor 页面正文包含多个关键词的页面	allintext:SEO 搜索引擎优化	相当于：intext:SEO intext:搜索引擎优化</li>
</ul>
<h5 id="inanchor"><a href="#inanchor" class="headerlink" title="inanchor"></a><em><strong>inanchor</strong></em></h5><hr>
<ul>
<li>搜索链接锚文字(即链接显示的文字)中包含搜索词的页面	inanchor:前端	搜索链接锚文字中包含【前端】的页面</li>
</ul>
<h5 id="allinanchor"><a href="#allinanchor" class="headerlink" title="allinanchor"></a><em><strong>allinanchor</strong></em></h5><hr>
<ul>
<li><pre><code>即all+inanchor 页面链接锚文字包含多个关键词的页面	allinanchor:SEO 搜索引擎优化	相当于：inanchor:SEO inanchor:搜索引擎优化
</code></pre>
</li>
</ul>
<h5 id="weather"><a href="#weather" class="headerlink" title="weather"></a><em><strong>weather</strong></em></h5><hr>
<ul>
<li>weather&#x2F;time&#x2F;sunrise&#x2F;sundown+城市名，返回城市的天气&#x2F;时间&#x2F;日出时间&#x2F;日落时间</li>
<li>weather:beijing	显示北京的天气</li>
</ul>
<h5 id="music"><a href="#music" class="headerlink" title="music"></a><em><strong>music</strong></em></h5><hr>
<ul>
<li>music或者用songs，歌手名字+music&#x2F;songs	周杰伦 music	返回周杰伦的各首歌曲</li>
</ul>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>资讯、多媒体订阅</title>
    <url>/2023/09/25/others/%E8%B5%84%E8%AE%AF%E3%80%81%E5%8D%9A%E5%AE%A2%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h3 id="消息-资讯-订阅"><a href="#消息-资讯-订阅" class="headerlink" title="消息|资讯 订阅"></a>消息|资讯 订阅</h3><p><a href="https://sspai.com/post/57498">Tiny Tiny RSS 部署</a></p>
<hr>
<h3 id="多媒体-播客订阅服务"><a href="#多媒体-播客订阅服务" class="headerlink" title="多媒体 播客订阅服务"></a>多媒体 播客订阅服务</h3><p><a href="https://sspai.com/post/63610">Airsonic 部署</a></p>
]]></content>
      <categories>
        <category>订阅</category>
      </categories>
      <tags>
        <tag>订阅</tag>
      </tags>
  </entry>
  <entry>
    <title>码制与位运算</title>
    <url>/2021/11/10/others/%E7%A0%81%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>0b00000001</p>
<h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>0o001(python)</p>
<h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>0xFE</p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><blockquote>
<p>将数字表述为二进制数，方便人看</p>
</blockquote>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">正数与原码相同</span><br><span class="line">负数符号位不变，其余位取反</span><br></pre></td></tr></table></figure>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">正数与原码相同</span><br><span class="line">反码符号位不变其余位取反加一</span><br><span class="line">补码的补码是原码</span><br></pre></td></tr></table></figure>
<h3 id="浮点数存储方式"><a href="#浮点数存储方式" class="headerlink" title="浮点数存储方式"></a>浮点数存储方式</h3><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li>&amp;&amp; </li>
<li>|| </li>
<li>！</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li>&amp; </li>
<li>| </li>
<li>~ </li>
<li>^ </li>
<li>&gt;&gt; </li>
<li>&lt;&lt;</li>
</ul>
]]></content>
      <categories>
        <category>进制与编码</category>
      </categories>
      <tags>
        <tag>进制</tag>
        <tag>编码</tag>
      </tags>
  </entry>
</search>
