<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Java_Stream_API</title>
    <url>/2022/07/13/Java-Stream-API/</url>
    <content><![CDATA[<p>2.1. Empty Stream<br>We should use the empty() method in case of the creation of an empty stream:</p>
<p>Stream<String> streamEmpty &#x3D; Stream.empty();<br>We often use the empty() method upon creation to avoid returning null for streams with no element:</p>
<p>public Stream<String> streamOf(List<String> list) {<br>    return list &#x3D;&#x3D; null || list.isEmpty() ? Stream.empty() : list.stream();<br>}<br>2.2. Stream of Collection<br>We can also create a stream of any type of Collection (Collection, List, Set):</p>
<p>Collection<String> collection &#x3D; Arrays.asList(“a”, “b”, “c”);<br>Stream<String> streamOfCollection &#x3D; collection.stream();<br>2.3. Stream of Array<br>An array can also be the source of a stream:</p>
<p>Stream<String> streamOfArray &#x3D; Stream.of(“a”, “b”, “c”);<br>We can also create a stream out of an existing array or of part of an array:</p>
<p>String[] arr &#x3D; new String[]{“a”, “b”, “c”};<br>Stream<String> streamOfArrayFull &#x3D; Arrays.stream(arr);<br>Stream<String> streamOfArrayPart &#x3D; Arrays.stream(arr, 1, 3);<br>2.4. Stream.builder()<br>When builder is used, the desired type should be additionally specified in the right part of the statement, otherwise the build() method will create an instance of the Stream<Object>:</p>
<p>Stream<String> streamBuilder &#x3D;<br>  Stream.<String>builder().add(“a”).add(“b”).add(“c”).build();<br>2.5. Stream.generate()<br>The generate() method accepts a Supplier<T> for element generation. As the resulting stream is infinite, the developer should specify the desired size, or the generate() method will work until it reaches the memory limit:</p>
<p>Stream<String> streamGenerated &#x3D;<br>  Stream.generate(() -&gt; “element”).limit(10);<br>The code above creates a sequence of ten strings with the value “element.”</p>
<p>2.6. Stream.iterate()<br>Another way of creating an infinite stream is by using the iterate() method:</p>
<p>Stream<Integer> streamIterated &#x3D; Stream.iterate(40, n -&gt; n + 2).limit(20);<br>The first element of the resulting stream is the first parameter of the iterate() method. When creating every following element, the specified function is applied to the previous element. In the example above the second element will be 42.</p>
<p>2.7. Stream of Primitives<br>Java 8 offers the possibility to create streams out of three primitive types: int, long and double. As Stream<T> is a generic interface, and there is no way to use primitives as a type parameter with generics, three new special interfaces were created: IntStream, LongStream, DoubleStream.</p>
<p>Using the new interfaces alleviates unnecessary auto-boxing, which allows for increased productivity:</p>
<p>IntStream intStream &#x3D; IntStream.range(1, 3);<br>LongStream longStream &#x3D; LongStream.rangeClosed(1, 3);<br>The range(int startInclusive, int endExclusive) method creates an ordered stream from the first parameter to the second parameter. It increments the value of subsequent elements with the step equal to 1. The result doesn’t include the last parameter, it is just an upper bound of the sequence.</p>
<p>The rangeClosed(int startInclusive, int endInclusive) method does the same thing with only one difference, the second element is included. We can use these two methods to generate any of the three types of streams of primitives.</p>
<p>Since Java 8, the Random class provides a wide range of methods for generating streams of primitives. For example, the following code creates a DoubleStream, which has three elements:</p>
<p>Random random &#x3D; new Random();<br>DoubleStream doubleStream &#x3D; random.doubles(3);<br>2.8. Stream of String<br>We can also use String as a source for creating a stream with the help of the chars() method of the String class. Since there is no interface for CharStream in JDK, we use the IntStream to represent a stream of chars instead.</p>
<p>IntStream streamOfChars &#x3D; “abc”.chars();<br>The following example breaks a String into sub-strings according to specified RegEx:</p>
<p>Stream<String> streamOfString &#x3D;<br>  Pattern.compile(“, “).splitAsStream(“a, b, c”);<br>2.9. Stream of File<br>Furthermore, Java NIO class Files allows us to generate a Stream<String> of a text file through the lines() method. Every line of the text becomes an element of the stream:</p>
<p>Path path &#x3D; Paths.get(“C:\file.txt”);<br>Stream<String> streamOfStrings &#x3D; Files.lines(path);<br>Stream<String> streamWithCharset &#x3D;<br>  Files.lines(path, Charset.forName(“UTF-8”));<br>The Charset can be specified as an argument of the lines() method.</p>
<ol start="3">
<li>Referencing a Stream<br>We can instantiate a stream, and have an accessible reference to it, as long as only intermediate operations are called. Executing a terminal operation makes a stream inaccessible.</li>
</ol>
<p>To demonstrate this, we will forget for a while that the best practice is to chain the sequence of operation. Besides its unnecessary verbosity, technically the following code is valid:</p>
<p>Stream<String> stream &#x3D;<br>  Stream.of(“a”, “b”, “c”).filter(element -&gt; element.contains(“b”));<br>Optional<String> anyElement &#x3D; stream.findAny();<br>However, an attempt to reuse the same reference after calling the terminal operation will trigger the IllegalStateException:</p>
<p>Optional<String> firstElement &#x3D; stream.findFirst();<br>As the IllegalStateException is a RuntimeException, a compiler will not signalize about a problem. So it is very important to remember that Java 8 streams can’t be reused.</p>
<p>This kind of behavior is logical. We designed streams to apply a finite sequence of operations to the source of elements in a functional style, not to store elements.</p>
<p>So to make the previous code work properly, some changes should be made:</p>
<p>List<String> elements &#x3D;<br>  Stream.of(“a”, “b”, “c”).filter(element -&gt; element.contains(“b”))<br>    .collect(Collectors.toList());<br>Optional<String> anyElement &#x3D; elements.stream().findAny();<br>Optional<String> firstElement &#x3D; elements.stream().findFirst();<br>4. Stream Pipeline<br>To perform a sequence of operations over the elements of the data source and aggregate their results, we need three parts: the source, intermediate operation(s) and a terminal operation.</p>
<p>Intermediate operations return a new modified stream. For example, to create a new stream of the existing one without few elements, the skip() method should be used:</p>
<p>Stream<String> onceModifiedStream &#x3D;<br>  Stream.of(“abcd”, “bbcd”, “cbcd”).skip(1);<br>If we need more than one modification, we can chain intermediate operations. Let’s assume that we also need to substitute every element of the current Stream<String> with a sub-string of the first few chars. We can do this by chaining the skip() and map() methods:</p>
<p>Stream<String> twiceModifiedStream &#x3D;<br>  stream.skip(1).map(element -&gt; element.substring(0, 3));<br>As we can see, the map() method takes a lambda expression as a parameter. If we want to learn more about lambdas, we can take a look at our tutorial Lambda Expressions and Functional Interfaces: Tips and Best Practices.</p>
<p>A stream by itself is worthless; the user is interested in the result of the terminal operation, which can be a value of some type or an action applied to every element of the stream. We can only use one terminal operation per stream.</p>
<p>The correct and most convenient way to use streams is by a stream pipeline, which is a chain of the stream source, intermediate operations, and a terminal operation:</p>
<p>List<String> list &#x3D; Arrays.asList(“abc1”, “abc2”, “abc3”);<br>long size &#x3D; list.stream().skip(1)<br>  .map(element -&gt; element.substring(0, 3)).sorted().count();<br>5. Lazy Invocation<br>Intermediate operations are lazy. This means that they will be invoked only if it is necessary for the terminal operation execution.</p>
<p>For example, let’s call the method wasCalled(), which increments an inner counter every time it’s called:</p>
<p>private long counter;</p>
<p>private void wasCalled() {<br>    counter++;<br>}<br>Now let’s call the method wasCalled() from operation filter():</p>
<p>List<String> list &#x3D; Arrays.asList(“abc1”, “abc2”, “abc3”);<br>counter &#x3D; 0;<br>Stream<String> stream &#x3D; list.stream().filter(element -&gt; {<br>    wasCalled();<br>    return element.contains(“2”);<br>});<br>As we have a source of three elements, we can assume that the filter() method will be called three times, and the value of the counter variable will be 3. However, running this code doesn’t change counter at all, it is still zero, so the filter() method wasn’t even called once. The reason why is missing of the terminal operation.</p>
<p>Let’s rewrite this code a little bit by adding a map() operation and a terminal operation, findFirst(). We will also add the ability to track the order of method calls with the help of logging:</p>
<p>Optional<String> stream &#x3D; list.stream().filter(element -&gt; {<br>    log.info(“filter() was called”);<br>    return element.contains(“2”);<br>}).map(element -&gt; {<br>    log.info(“map() was called”);<br>    return element.toUpperCase();<br>}).findFirst();<br>The resulting log shows that we called the filter() method twice and the map() method once. This is because the pipeline executes vertically. In our example, the first element of the stream didn’t satisfy the filter’s predicate. Then we invoked the filter() method for the second element, which passed the filter. Without calling the filter() for the third element, we went down through the pipeline to the map() method.</p>
<p>The findFirst() operation satisfies by just one element. So in this particular example, the lazy invocation allowed us to avoid two method calls, one for the filter() and one for the map().</p>
<ol start="6">
<li>Order of Execution<br>From the performance point of view, the right order is one of the most important aspects of chaining operations in the stream pipeline:</li>
</ol>
<p>long size &#x3D; list.stream().map(element -&gt; {<br>    wasCalled();<br>    return element.substring(0, 3);<br>}).skip(2).count();<br>Execution of this code will increase the value of the counter by three. This means that we called the map() method of the stream three times, but the value of the size is one. So the resulting stream has just one element, and we executed the expensive map() operations for no reason two out of the three times.</p>
<p>If we change the order of the skip() and the map() methods, the counter will increase by only one. So we will call the map() method only once:</p>
<p>long size &#x3D; list.stream().skip(2).map(element -&gt; {<br>    wasCalled();<br>    return element.substring(0, 3);<br>}).count();<br>This brings us to the following rule: intermediate operations which reduce the size of the stream should be placed before operations which are applying to each element. So we need to keep methods such as skip(), filter(), and distinct() at the top of our stream pipeline.</p>
<ol start="7">
<li>Stream Reduction<br>The API has many terminal operations which aggregate a stream to a type or to a primitive: count(), max(), min(), and sum(). However, these operations work according to the predefined implementation. So what if a developer needs to customize a Stream’s reduction mechanism? There are two methods which allow us to do this, the reduce() and the collect() methods.</li>
</ol>
<p>7.1. The reduce() Method<br>There are three variations of this method, which differ by their signatures and returning types. They can have the following parameters:</p>
<p>identity – the initial value for an accumulator, or a default value if a stream is empty and there is nothing to accumulate</p>
<p>accumulator – a function which specifies the logic of the aggregation of elements. As the accumulator creates a new value for every step of reducing, the quantity of new values equals the stream’s size and only the last value is useful. This is not very good for the performance.</p>
<p>combiner – a function which aggregates the results of the accumulator. We only call combiner in a parallel mode to reduce the results of accumulators from different threads.</p>
<p>Now let’s look at these three methods in action:</p>
<p>OptionalInt reduced &#x3D;<br>  IntStream.range(1, 4).reduce((a, b) -&gt; a + b);<br>reduced &#x3D; 6 (1 + 2 + 3)</p>
<p>int reducedTwoParams &#x3D;<br>  IntStream.range(1, 4).reduce(10, (a, b) -&gt; a + b);<br>reducedTwoParams &#x3D; 16 (10 + 1 + 2 + 3)</p>
<p>int reducedParams &#x3D; Stream.of(1, 2, 3)<br>  .reduce(10, (a, b) -&gt; a + b, (a, b) -&gt; {<br>     log.info(“combiner was called”);<br>     return a + b;<br>  });<br>The result will be the same as in the previous example (16), and there will be no login, which means that combiner wasn’t called. To make a combiner work, a stream should be parallel:</p>
<p>int reducedParallel &#x3D; Arrays.asList(1, 2, 3).parallelStream()<br>    .reduce(10, (a, b) -&gt; a + b, (a, b) -&gt; {<br>       log.info(“combiner was called”);<br>       return a + b;<br>    });<br>The result here is different (36), and the combiner was called twice. Here the reduction works by the following algorithm: the accumulator ran three times by adding every element of the stream to identity. These actions are being done in parallel. As a result, they have (10 + 1 &#x3D; 11; 10 + 2 &#x3D; 12; 10 + 3 &#x3D; 13;). Now combiner can merge these three results. It needs two iterations for that (12 + 13 &#x3D; 25; 25 + 11 &#x3D; 36).</p>
<p>7.2. The collect() Method<br>The reduction of a stream can also be executed by another terminal operation, the collect() method. It accepts an argument of the type Collector, which specifies the mechanism of reduction. There are already created, predefined collectors for most common operations. They can be accessed with the help of the Collectors type.</p>
<p>In this section, we will use the following List as a source for all streams:</p>
<p>List<Product> productList &#x3D; Arrays.asList(new Product(23, “potatoes”),<br>  new Product(14, “orange”), new Product(13, “lemon”),<br>  new Product(23, “bread”), new Product(13, “sugar”));<br>Converting a stream to the Collection (Collection, List or Set):</p>
<p>List<String> collectorCollection &#x3D;<br>  productList.stream().map(Product::getName).collect(Collectors.toList());<br>Reducing to String:</p>
<p>String listToString &#x3D; productList.stream().map(Product::getName)<br>  .collect(Collectors.joining(“, “, “[“, “]”));<br>The joiner() method can have from one to three parameters (delimiter, prefix, suffix). The most convenient thing about using joiner() is that the developer doesn’t need to check if the stream reaches its end to apply the suffix and not to apply a delimiter. Collector will take care of that.</p>
<p>Processing the average value of all numeric elements of the stream:</p>
<p>double averagePrice &#x3D; productList.stream()<br>  .collect(Collectors.averagingInt(Product::getPrice));<br>Processing the sum of all numeric elements of the stream:</p>
<p>int summingPrice &#x3D; productList.stream()<br>  .collect(Collectors.summingInt(Product::getPrice));<br>The methods averagingXX(), summingXX() and summarizingXX() can work with primitives (int, long, double) and with their wrapper classes (Integer, Long, Double). One more powerful feature of these methods is providing the mapping. As a result, the developer doesn’t need to use an additional map() operation before the collect() method.</p>
<p>Collecting statistical information about stream’s elements:</p>
<p>IntSummaryStatistics statistics &#x3D; productList.stream()<br>  .collect(Collectors.summarizingInt(Product::getPrice));<br>By using the resulting instance of type IntSummaryStatistics, the developer can create a statistical report by applying the toString() method. The result will be a String common to this one “IntSummaryStatistics{count&#x3D;5, sum&#x3D;86, min&#x3D;13, average&#x3D;17,200000, max&#x3D;23}.”</p>
<p>It is also easy to extract from this object separate values for count, sum, min, and average by applying the methods getCount(), getSum(), getMin(), getAverage(), and getMax(). All of these values can be extracted from a single pipeline.</p>
<p>Grouping of stream’s elements according to the specified function:</p>
<p>Map&lt;Integer, List<Product>&gt; collectorMapOfLists &#x3D; productList.stream()<br>  .collect(Collectors.groupingBy(Product::getPrice));<br>In the example above, the stream was reduced to the Map, which groups all products by their price.</p>
<p>Dividing stream’s elements into groups according to some predicate:</p>
<p>Map&lt;Boolean, List<Product>&gt; mapPartioned &#x3D; productList.stream()<br>  .collect(Collectors.partitioningBy(element -&gt; element.getPrice() &gt; 15));<br>Pushing the collector to perform additional transformation:</p>
<p>Set<Product> unmodifiableSet &#x3D; productList.stream()<br>  .collect(Collectors.collectingAndThen(Collectors.toSet(),<br>  Collections::unmodifiableSet));<br>In this particular case, the collector has converted a stream to a Set, and then created the unchangeable Set out of it.</p>
<p>Custom collector:</p>
<p>If for some reason a custom collector should be created, the easiest and least verbose way of doing so is to use the method of() of the type Collector.</p>
<p>Collector&lt;Product, ?, LinkedList<Product>&gt; toLinkedList &#x3D;<br>  Collector.of(LinkedList::new, LinkedList::add,<br>    (first, second) -&gt; {<br>       first.addAll(second);<br>       return first;<br>    });</p>
<p>LinkedList<Product> linkedListOfPersons &#x3D;<br>  productList.stream().collect(toLinkedList);<br>In this example, an instance of the Collector got reduced to the LinkedList<Persone>.</p>
<ol start="8">
<li>Parallel Streams<br>Before Java 8, parallelization was complex. The emergence of the ExecutorService and the ForkJoin simplified a developer’s life a little bit, but it was still worth remembering how to create a specific executor, how to run it, and so on. Java 8 introduced a way of accomplishing parallelism in a functional style.</li>
</ol>
<p>The API allows us to create parallel streams, which perform operations in a parallel mode. When the source of a stream is a Collection or an array, it can be achieved with the help of the parallelStream() method:</p>
<p>Stream<Product> streamOfCollection &#x3D; productList.parallelStream();<br>boolean isParallel &#x3D; streamOfCollection.isParallel();<br>boolean bigPrice &#x3D; streamOfCollection<br>  .map(product -&gt; product.getPrice() * 12)<br>  .anyMatch(price -&gt; price &gt; 200);<br>If the source of a stream is something other than a Collection or an array, the parallel() method should be used:</p>
<p>IntStream intStreamParallel &#x3D; IntStream.range(1, 150).parallel();<br>boolean isParallel &#x3D; intStreamParallel.isParallel();<br>Under the hood, Stream API automatically uses the ForkJoin framework to execute operations in parallel. By default, the common thread pool will be used and there is no way (at least for now) to assign some custom thread pool to it. This can be overcome by using a custom set of parallel collectors.</p>
<p>When using streams in parallel mode, avoid blocking operations. It is also best to use parallel mode when tasks need a similar amount of time to execute. If one task lasts much longer than the other, it can slow down the complete app’s workflow.</p>
<p>The stream in parallel mode can be converted back to the sequential mode by using the sequential() method:</p>
<p>IntStream intStreamSequential &#x3D; intStreamParallel.sequential();<br>boolean isParallel &#x3D; intStreamSequential.isParallel();</p>
]]></content>
  </entry>
  <entry>
    <title>markdown-math</title>
    <url>/2023/12/17/Markdown-math/</url>
    <content><![CDATA[<p><a href="https://blog.csdn.net/qq_38342510/article/details/124064158">markdown数学</a></p>
<h3 id="MarkDown数学公式基本语法"><a href="#MarkDown数学公式基本语法" class="headerlink" title="MarkDown数学公式基本语法"></a>MarkDown数学公式基本语法</h3><p>一、 公式排版<br>​ MarkDown中公式公式的语法与LaTeX类似，排版可以分为两种：</p>
<ol>
<li><p>行内公式： 使用$包裹公式<br>例如：<br>$E&#x3D;mc^2$</p>
<p>$$H_2SO_4$$ </p>
<p>$$Na_2CO_3$$</p>
</li>
</ol>
<span id="more"></span>
<ol start="2">
<li><p>独立公式： 使用$$包裹公式<br>例如：<br>&nbsp;</p>
<p>$$<br>E&#x3D;mc^2<br>$$</p>
</li>
</ol>
<ul>
<li><p>\boxed命令给公式加一个边框 ，例如：</p>
<p>$$<br>\boxed{E&#x3D;mc^2}<br>$$</p>
</li>
</ul>
<p>二、特殊转义字符<br>​ # $ &amp; ~ _ ^ \ { } %这些字符在MarkDown中有特殊的意义，在需要使用这些字符的时候，需要进行转义，在前面加\：</p>
<p>#  $  &amp; ~  _  ^ \ {  } % </p>
]]></content>
      <categories>
        <category>markdown-math</category>
      </categories>
      <tags>
        <tag>markdown-math</tag>
      </tags>
  </entry>
  <entry>
    <title>MVC模式</title>
    <url>/2022/09/16/MVC%E6%A8%A1%E5%BC%8F/</url>
    <content><![CDATA[<h1 id="PO-BO-VO-DTO-POJO-DAO-DO这些Java中的概念分别指一些什么？"><a href="#PO-BO-VO-DTO-POJO-DAO-DO这些Java中的概念分别指一些什么？" class="headerlink" title="PO BO VO DTO POJO DAO DO这些Java中的概念分别指一些什么？"></a><a href="https://www.zhihu.com/question/39651928/answer/2490565983">PO BO VO DTO POJO DAO DO这些Java中的概念分别指一些什么？</a></h1>]]></content>
  </entry>
  <entry>
    <title>PWA相关知识</title>
    <url>/2022/09/16/PWA%E7%9B%B8%E5%85%B3%E7%9F%A5%E8%AF%86/</url>
    <content><![CDATA[<h1 id="Web-在继续离我们远去"><a href="#Web-在继续离我们远去" class="headerlink" title="Web 在继续离我们远去"></a><a href="https://zhuanlan.zhihu.com/p/22561084">Web 在继续离我们远去</a></h1><h1 id="下一代-Web-应用模型-—-Progressive-Web-Ap"><a href="#下一代-Web-应用模型-—-Progressive-Web-Ap" class="headerlink" title="下一代 Web 应用模型 — Progressive Web Ap"></a><a href="https://zhuanlan.zhihu.com/p/25167289">下一代 Web 应用模型 — Progressive Web Ap</a></h1>]]></content>
      <categories>
        <category>PWA</category>
      </categories>
      <tags>
        <tag>PWA</tag>
      </tags>
  </entry>
  <entry>
    <title>RPC</title>
    <url>/2022/09/16/RPC/</url>
    <content><![CDATA[<h1 id="什么是RPC"><a href="#什么是RPC" class="headerlink" title="什么是RPC"></a><a href="https://zhuanlan.zhihu.com/p/139688497">什么是RPC</a></h1>]]></content>
  </entry>
  <entry>
    <title>TS的!和?用法</title>
    <url>/2022/09/11/TS%E7%9A%84!%E5%92%8C%E9%97%AE%E5%8F%B7/</url>
    <content><![CDATA[<h2 id="用法"><a href="#用法" class="headerlink" title="!用法"></a>!用法</h2><ul>
<li><p>用在变量前表示取反</p>
</li>
<li><p>用在赋值的内容后时，使null和undefined类型可以赋值给其他类型并通过编译，表示该变量值可空</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line">y = <span class="literal">null</span>		<span class="comment">// 无法通过编译</span></span><br><span class="line">y = <span class="literal">undefined</span>	<span class="comment">// 无法通过编译</span></span><br><span class="line"></span><br><span class="line">y = <span class="literal">null</span>!</span><br><span class="line">y = <span class="literal">undefined</span>!</span><br><span class="line"><span class="comment">// 由于x是可选的，因此parma.x的类型为number | undefined，无法传递给number类型的y，因此需要用x!</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line">x?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params">parma: IDemo</span>) =&gt; &#123;</span><br><span class="line">y = parma.<span class="property">x</span>!</span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
<li><p>如果存在空情况的判断并赋具体值时，可以不用!，但是如果要想令y存在等于undefined的情况还是需要用!</p>
<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line">x?: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params">parma: IDemo</span>) =&gt; &#123;</span><br><span class="line">y = parma.<span class="property">x</span> || <span class="number">1</span>	<span class="comment">// 如果为undefined，返回y=1，如果不为undefined，则返回parma.x的值</span></span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
<hr>
<h2 id="用法-1"><a href="#用法-1" class="headerlink" title="?用法"></a>?用法</h2><ul>
<li>除了表示可选参数外，常用于防御性编程<figure class="highlight typescript"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="title function_">fetch</span>(...) || &#123;&#125;		<span class="comment">// 假设a是从后端拿到的一个对象类型数据</span></span><br><span class="line"><span class="keyword">const</span> unsafeData = a.<span class="property">b</span>.<span class="property">c</span>		<span class="comment">// 这样写时不安全的，无法确保b是否有值，如果为空则b.c会进行报错</span></span><br><span class="line"><span class="keyword">const</span> safeData = a?.<span class="property">b</span>?.<span class="property">c</span>		<span class="comment">// 实际上就是相当于 const safeData = a &amp;&amp; a.b &amp;&amp; a.b.c</span></span><br><span class="line">当使用A对象属性A.<span class="property">B</span>时，如果无法确定A是否为空，则需要用A?.<span class="property">B</span>，表示当A有值的时候才去访问B属性，没有值的时候就不去访问，如果不使用?则会报错</span><br><span class="line"></span><br><span class="line"><span class="comment">// 由于函数参数可选，因此parma无法确定是否拥有，所以无法正常使用parma.x，使用parma?.x向编译器假设此时parma不为空且为IDemo类型，同时parma?.x无法保证非空，因此使用parma?.x!来保证了整体通过编译</span></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span>:<span class="built_in">number</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params">parma?: IDemo</span>) =&gt; &#123;</span><br><span class="line">y = parma?.<span class="property">x</span>!</span><br><span class="line"><span class="variable language_">console</span>.<span class="title function_">log</span>(parma?.<span class="property">x</span>)	<span class="comment">// 只是单纯调用属性时就无需!</span></span><br><span class="line"><span class="keyword">return</span> y</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 如果使用y = parma!.x!是会报错的，因为当parma为空时，是不拥有x属性的，会报找不到x的错误</span></span><br><span class="line">但是?用法只能读操作而不能写操作，对一个可能为空的属性赋值是不会被编译通过的，此时还需用用到类型断言</span><br><span class="line"></span><br><span class="line"><span class="keyword">interface</span> <span class="title class_">IDemo</span> &#123;</span><br><span class="line"><span class="attr">x</span>: <span class="built_in">number</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 编译报错，不能赋值给可选属性</span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo</span> = (<span class="params">parma?: IDemo</span>) =&gt; &#123;</span><br><span class="line">parma?.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用类型断言  </span></span><br><span class="line"><span class="keyword">const</span> <span class="title function_">demo_</span> = (<span class="params">parma?: IDemo</span>) =&gt; &#123;</span><br><span class="line"><span class="keyword">let</span> _parma = parma <span class="keyword">as</span> <span class="title class_">IDemo</span></span><br><span class="line">_parma.<span class="property">x</span> = <span class="number">1</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ul>
]]></content>
      <categories>
        <category>TS</category>
      </categories>
      <tags>
        <tag>TS的!和?用法</tag>
      </tags>
  </entry>
  <entry>
    <title>UML</title>
    <url>/2022/09/16/UML/</url>
    <content><![CDATA[<h1 id="掌握UML类图"><a href="#掌握UML类图" class="headerlink" title="掌握UML类图"></a><a href="https://zhuanlan.zhihu.com/p/267298708">掌握UML类图</a></h1><h2 id="UML-Unified-Modeling-Language-统一建模语言"><a href="#UML-Unified-Modeling-Language-统一建模语言" class="headerlink" title="UML(Unified Modeling Language)统一建模语言"></a>UML(Unified Modeling Language)统一建模语言</h2>]]></content>
  </entry>
  <entry>
    <title>electronAPI文档</title>
    <url>/2022/08/17/electronAPI%E6%96%87%E6%A1%A3/</url>
    <content><![CDATA[<h1 id="electron-文档"><a href="#electron-文档" class="headerlink" title="electron 文档"></a>electron 文档</h1><h2 id="electron"><a href="#electron" class="headerlink" title=" electron"></a> <a href="https://www.electronjs.org/zh/docs/latest/tutorial/tutorial-first-app">electron</a></h2><h2 id="electron中文文档"><a href="#electron中文文档" class="headerlink" title="electron中文文档"></a>electron中文文档</h2><h2 id="electron中文文档-1"><a href="#electron中文文档-1" class="headerlink" title="electron中文文档"></a><a href="https://www.wenjiangs.com/doc/s3ivxhuv">electron中文文档</a></h2><h2 id="electron-Vue"><a href="#electron-Vue" class="headerlink" title="electron + Vue"></a>electron + Vue</h2><p><a href="https://simulatedgreg.gitbooks.io/electron-vue/content/cn/">electron-vue</a></p>
<p>vue init simulatedgreg&#x2F;electron-vue electron-vue</p>
<p>sudo npm –vs2015 install –global windows-build-tools<br><a href="https://www.cnblogs.com/yunjiao/p/16491092.html">安装卡顿</a></p>
<h2 id="electron-vue学习之环境搭建"><a href="#electron-vue学习之环境搭建" class="headerlink" title="electron-vue学习之环境搭建"></a><a href="https://dxsm.github.io/p/electron-learning-chp1.html">electron-vue学习之环境搭建</a></h2><h2 id="electron-React"><a href="#electron-React" class="headerlink" title="electron + React"></a>electron + React</h2><p><a href="https://electron-react-boilerplate.js.org/docs/installation">electron-react</a></p>
<h2 id="git-clone-–depth-1-https-github-com-electron-react-boilerplate-electron-react-boilerplate-electron-react"><a href="#git-clone-–depth-1-https-github-com-electron-react-boilerplate-electron-react-boilerplate-electron-react" class="headerlink" title="git clone –depth&#x3D;1  https://github.com/electron-react-boilerplate/electron-react-boilerplate  electron-react"></a>git clone –depth&#x3D;1  <a href="https://github.com/electron-react-boilerplate/electron-react-boilerplate">https://github.com/electron-react-boilerplate/electron-react-boilerplate</a>  electron-react</h2>]]></content>
      <categories>
        <category>electron</category>
      </categories>
      <tags>
        <tag>electronAPI</tag>
      </tags>
  </entry>
  <entry>
    <title>git 基本使用</title>
    <url>/2022/05/14/git-%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    <content><![CDATA[<p><a href="https://www.liaoxuefeng.com/wiki/896043488029600/898732864121440">廖雪峰</a></p>
<h1 id="Git-config-查看和设置配置信息-慕城南风的博客-CSDN博客-查看git配置信息"><a href="#Git-config-查看和设置配置信息-慕城南风的博客-CSDN博客-查看git配置信息" class="headerlink" title="Git config 查看和设置配置信息_慕城南风的博客-CSDN博客_查看git配置信息"></a><a href="https://blog.csdn.net/lovedingd/article/details/121288974">Git config 查看和设置配置信息_慕城南风的博客-CSDN博客_查看git配置信息</a></h1>]]></content>
      <categories>
        <category>版本控制器</category>
      </categories>
      <tags>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title>编码与解码</title>
    <url>/2021/11/10/encode&amp;decode/</url>
    <content><![CDATA[<h2 id="Unicode-和-UTF-8-有什么区别？"><a href="#Unicode-和-UTF-8-有什么区别？" class="headerlink" title="Unicode 和 UTF-8 有什么区别？"></a>Unicode 和 UTF-8 有什么区别？</h2><p>  中国人民通过对 ASCII 编码的中文扩充改造，产生了 GB2312 编码，可以表示6000多个常用汉字。汉字实在是太多了，包括繁体和各种字符，于是产生了 GBK 编码，它包括了 GB2312 中的编码，同时扩充了很多。中国是个多民族国家，各个民族几乎都有自己独立的语言系统，为了表示那些字符，继续把 GBK 编码扩充为 GB18030 编码。每个国家都像中国一样，把自己的语言编码，于是出现了各种各样的编码，如果你不安装相应的编码，就无法解释相应编码想表达的内容。终于，有个叫 ISO 的组织看不下去了。他们一起创造了一种编码 UNICODE ，这种编码非常大，大到可以容纳世界上任何一个文字和标志。所以只要电脑上有 UNICODE 这种编码系统，无论是全球哪种文字，只需要保存文件的时候，保存成 UNICODE 编码就可以被其他电脑正常解释。UNICODE 在网络传输中，出现了两个标准 UTF-8 和 UTF-16，分别每次传输 8个位和 16个位。于是就会有人产生疑问，UTF-8 既然能保存那么多文字、符号，为什么国内还有这么多使用 GBK 等编码的人？因为 UTF-8 等编码体积比较大，占电脑空间比较多，如果面向的使用人群绝大部分都是中国人，用 GBK 等编码也可以。</p>
<h3 id="ASCII"><a href="#ASCII" class="headerlink" title="ASCII"></a>ASCII</h3><blockquote>
<p>一个字符占一个字节</p>
</blockquote>
<h3 id="GB2312"><a href="#GB2312" class="headerlink" title="GB2312"></a>GB2312</h3><blockquote>
<p>一个英文字符占一个字节，一个汉字符占两个字节</p>
</blockquote>
<h3 id="GBK"><a href="#GBK" class="headerlink" title="GBK"></a>GBK</h3><blockquote>
<p>一个英文字符占一个字节，一个汉字符占两个字节</p>
</blockquote>
<h3 id="Unicode"><a href="#Unicode" class="headerlink" title="Unicode"></a>Unicode</h3><blockquote>
<p>一个字符就是两个字节</p>
</blockquote>
<p>计算机怎么知道三个字节表示一个符号，而不是分别表示三个符号呢？第二个问题是，我们已经知道，英文字母只用一个字节表示就够了，如果unicode统一规定，每个符号用三个或四个字节表示，那么每个英文字母前都必然有二到三个字节是0，这对于存储空间来说是极大的浪费，文本文件的大小会因此大出二三倍，这是难以接受的。</p>
<h3 id="UTF-8"><a href="#UTF-8" class="headerlink" title="UTF-8"></a>UTF-8</h3><blockquote>
<p>字符是可变字节编码,汉字大多数占3个字节</p>
</blockquote>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>编码</tag>
      </tags>
  </entry>
  <entry>
    <title>idea快捷键</title>
    <url>/2022/07/11/idea-shortcut-key/</url>
    <content><![CDATA[<h2 id="常用快捷键1"><a href="#常用快捷键1" class="headerlink" title="常用快捷键1"></a><a href="https://zhuanlan.zhihu.com/p/410613271">常用快捷键1</a></h2><h2 id="常用快捷键2"><a href="#常用快捷键2" class="headerlink" title="常用快捷键2"></a><a href="https://blog.csdn.net/weixin_45395059/article/details/125591122">常用快捷键2</a></h2><ul>
<li>ctrl + alt + o 代码优化(自动删除多余的包与变量)</li>
<li>Alt + F12 打开terminal(终端) </li>
<li>ctrl+shift+(+&#x2F;-) 展开全部折叠全部</li>
<li>ctrl+（+&#x2F;-） 展开折叠当前方法</li>
<li>shift + f6 重命名(重构)</li>
<li>ctrl + alt + l 代码格式化</li>
<li>alt + insert 创建内容</li>
<li>psvm main方法</li>
<li>sout 输出语句</li>
<li>Ctrl + d 复制一行</li>
<li>Ctrl + y 删除一行</li>
<li>Ctrl + Shift + Up&#x2F;Down 代码向上&#x2F;下移动</li>
<li>Ctrl + n 搜索类</li>
<li>alt + insert 生成代码</li>
<li>alt + Enter 导包，生成变量</li>
<li>Ctrl + &#x2F; 或 Ctrl + Shift+ &#x2F; 单行注释或多行注释</li>
<li>fori 回车即可 for循环</li>
<li>ctrl + alt + t 代码包围try-catch,if,while等</li>
<li>ctrl + alt + -&gt; 向后 ctrl + alt + &lt;- 向前</li>
<li>显示代码结构：alt + 7</li>
<li>显示导航栏：alt + 1</li>
<li>撤销 ctrl + Z</li>
<li>REDO 操作 ctrl + shif + z</li>
<li>Tab 缩进 shift+Tab 撤销缩进</li>
<li>Ctrl + u 选择行</li>
<li>alt + f8 查看变量值</li>
<li>ctrl + alt +B 查找接口实现类</li>
<li>ctrl + h 查看类或接口的继承关系</li>
<li>ctrl + o 覆写方法</li>
</ul>
<h3 id="替换"><a href="#替换" class="headerlink" title="替换"></a>替换</h3><ul>
<li>ctrl + r 替换</li>
<li>ctrl + shift + r 路径中替换</li>
</ul>
<h2 id="调试debug"><a href="#调试debug" class="headerlink" title="调试debug"></a>调试<a href="https://blog.csdn.net/m0_37154839/article/details/107617122">debug</a></h2><ul>
<li>F9 调试</li>
</ul>
]]></content>
      <categories>
        <category>IDE</category>
      </categories>
      <tags>
        <tag>IntelliJ IDEA</tag>
      </tags>
  </entry>
  <entry>
    <title>hexo基本使用</title>
    <url>/2022/05/14/hexo-basic-using/</url>
    <content><![CDATA[<p><a href="https://hexo.io/zh-cn/">hexo官方文档参考</a></p>
<h3 id="准备环境"><a href="#准备环境" class="headerlink" title="准备环境"></a>准备环境</h3><p>准备 node 和 git 环境，<br>首先，安装 <a href="https://link.segmentfault.com/?enc=tPuMKqw61RzVm84zcK5dkw==.BrrL2L8eHAnfR3BrkwRyubMol6mR+K00H/+7ZBxUcrM=">NodeJS</a>，因为 <a href="https://link.segmentfault.com/?enc=f8nHs5HlZjB3jM/SypODRQ==.vv33Y6MCSunl6XYOR6iiPhcguAOZy0uU5irFpQvixck=">Hexo</a> 是基于 Node.js 驱动的一款博客框架<br>然后，安装 <a href="https://link.segmentfault.com/?enc=r1UwqShSgc9gM/g9jnEjuA==.K9TvTuGLYKNFeP7MlfEzQn159m3gN5ApzgwCZRvxBj8=">git</a>，一个分布式版本控制系统，用于项目的版本控制管理，作者是 Linux 之父。如果 Git 还不熟悉可以参考廖雪峰大神的 <a href="https://link.segmentfault.com/?enc=TK2QheUGYBO1Z811CjuFfQ==.MIbQjOOeTH073KOW5qjqlwaW3qWWRju/JSabr2F9ra9E6T2vhB3l8uXG7Ic7AldXJZyZ+vUibo+i4mbhakUti50XzrGxf+pqpoaEUqKL8hyyG5Q6ghVJGpV6NaAoW6jI">Git</a> 教程。</p>
<h3 id="配置-SSH-key"><a href="#配置-SSH-key" class="headerlink" title="配置 SSH key"></a>配置 SSH key</h3><p>要使用 git 工具首先要配置一下SSH key，为部署本地博客到 Github 做准备。</p>
<p>打开命令行输入 <code>cd ~/.ssh</code> 如果没报错或者提示什么的说明就是以前生成过的，直接使用 <code>cat ~/.ssh/id_rsa.pub</code> 命令就是可以查看本机上的 SSH key 了。</p>
<p>如果之前没有创建，则执行以下命令全局配置一下本地账户：</p>
<figure class="highlight cmd"><table><tr><td class="code"><pre><span class="line">git config --global user.name &quot;用户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱地址&quot;</span><br></pre></td></tr></table></figure>

<p>然后开始生成密钥 SSH key</p>
<p><code>ssh-keygen -t rsa -C &#39;上面的邮箱&#39;</code></p>
<p>首次使用还需要确认并添加主机到本机SSH可信列表。若返回 Hi xxx! You’ve successfully authenticated, but GitHub does not provide shell access. 内容，则证明添加成功</p>
<p><code>ssh -T git@github.com </code></p>
<p>到这还没完，还要登录 <a href="https://link.segmentfault.com/?enc=85+Hv8EF81wBwnFmUaXwNQ==.dOxoouG2d7F/umPE0hVZfTIS6Ysflj/SrzpL7pxw29U=">Github</a> 上添加刚刚生成的SSH key</p>
<p>创建一个新的 SSH key, 标题随便，key 就填刚才生成那个，确认创建，搞定！！这样在你的 SSH keys 列表里就会看到你刚刚添加的密钥。第一：打开项目根目录下的 _config.yml 配置文件配置参数。拉到文件末尾，填上如下配置（也可同时部署到多个仓库，后面再说）：</p>
<p>第二：要安装一个部署插件 <a href="https://link.segmentfault.com/?enc=W3TzZW+BX9QM2cUu+DFXjA==.NUPBlRnv7z5atg1zooXXprAGulDCzzpNmx9dVOT7sm52bu2dTWUtdyvwMMgikSok">hexo-deployer-git</a>。</p>
<p><code>npm install hexo-deployer-git --save</code></p>
<p>最后执行以下命令就可以部署上传啦，以下 g 是 generate 缩写，d 是 deploy 缩写：</p>
<p>博客搭好了，就开始写文章了，这里简单介绍一下，详细的文档可以看 <a href="https://link.segmentfault.com/?enc=GVa6alqgEg2FZIYlB5iNAg==.hUqRZi6IZ+vffIQ6Etk7TXpQiWUNs7OPjGsC518R9BY=">hexo</a> 官网。<br>新建文章，输入以下命令即可</p>
<p><code>hexo new &#39;文章标题&#39;</code></p>
<p>执行完成后可以在 &#x2F;source&#x2F;_posts 下看到一个“文章标题.md”的文章文件啦。.md 就是 Markdown 格式的文件，具体用法可以在网上找一下，语法还是比较简单的。</p>
<p>再执行一下以下命令</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo g</span></span><br><span class="line"><span class="attribute">hexo s</span></span><br></pre></td></tr></table></figure>

<p>就可以看到你的文章在博客显示了</p>
<p>最后，只要部署到你的 Github 上就可以了！</p>
<figure class="highlight ebnf"><table><tr><td class="code"><pre><span class="line"><span class="attribute">hexo clean</span></span><br><span class="line"><span class="attribute">hexo g -d</span></span><br></pre></td></tr></table></figure>



<p>部署前最好能先执行一下 hexo clean 命令，清除缓存文件 (db.json) 和已生成的静态文件 (public)。在某些情况（尤其是更换主题后），如果发现您对站点的更改无论如何也不生效，您可能需要运行该命令。</p>
<p>另外，如果你的文章暂时不发布可以先保存在草稿里面。生成草稿的方法和文章差不多 hexo new draft “文章标题”，生成后会在 &#x2F;source&#x2F;_drafts 里看到你的草稿文章。当你想发布时只要执行 publish 命令即可发布到博客。</p>
<figure class="highlight xml"><table><tr><td class="code"><pre><span class="line">hexo publish [layout] <span class="tag">&lt;<span class="name">filename</span>&gt;</span></span><br></pre></td></tr></table></figure>

<h3 id="静态图床"><a href="#静态图床" class="headerlink" title="静态图床"></a>静态图床</h3><p>文章里用的一些图片放哪里比较好呢？比对了几个免费的图床七牛、sm.ms和微博图床，最后我决定选用微博的，七牛的好像最近是<a href="https://link.segmentfault.com/?enc=WGsFUEhQxDuklwjV9Q0XpQ==.EimGnNmYeF5dHxYRvJhBZsb/3qoShBfRrMeQHfVWH8dxAYszsnz65kCOuGoT9t3GM1S0/pRNb318WdwdD8V5ehVJBjhg3HgqUPtsFVrvVes=">测试域名</a>不能用了，虽然有解决方案，但怕以后还会有其他问题，所以放弃啦，毕竟免费的东西才是最贵的，特别像云储存这种东西，感觉都是钱钱钱，哈哈哈，万一有一天不让用就比较麻烦了，另外<a href="https://link.segmentfault.com/?enc=g+k0uzJPB7woEaWXRa6yoA==.vLWdIFrafnlAlG873erTng==">sm.ms</a>这个口碑也不错，好像是个人开发的，免费好几年了，有同样的担心就放弃了，最好抱了新浪的大腿，感觉新浪应该会靠谱一点吧，唯一的问题就是如果有一天新浪禁止外链的话就不行了，再看吧。</p>
<p>可以去chrome网上应用商店下载一个叫<a href="https://link.segmentfault.com/?enc=qg1WDVFafB/jSDFuuu395Q==.WPvQjsvs9+wE5pSFvyhuSY4M8pVeehN7NgpVIpqEaFvEUp3+pORJkFckcgaqnZ1isPJep3TTkMbmyHIetlVbeahxbvtd/LRm3w6Ru8ZlO66G+i8SZni3Z+uL/+UAANKfXvU7zv/pP6HBGA498MxJGmH6Q6jiaPbJbucOxEI0pkU=">微博图床</a>的chrome插件，下图是插件的界面，操作简单方便，具体使用看说明就可以啦，比较简单，这样图床的问题就解决了。</p>
<h3 id="主题配置"><a href="#主题配置" class="headerlink" title="主题配置"></a>主题配置</h3><p>你可以到<a href="https://link.segmentfault.com/?enc=/ktKNG3yTnHYSr1QBzJJhA==.WtF+ZKiCkAgwSgK4Bdp45uNsw9Cufzz6OIjKuTuYMCo=">官网主题页</a>或者网上找你喜欢的，很多都不错，我使用的是 next 主题。你可以根据主题<a href="https://link.segmentfault.com/?enc=BPU9/qzqWFFC5Om2+eDfUQ==.TVQXFw3uPoFmy3BquvTXFFiRR/S/OJDJZ1N7UuOorsH76aye1G5OGU6oM+nPKyknDM/V2n05h1Rrpt0/6R6NvQ==">官网使用文档</a>说明修改相应的配置，达到自己想要的效果。例如设置字体、开启打赏功能、添加评论系统、设置腾讯公益404页面、数据统计、内容分享等等功能。这里我说一下简单说一下我个人用到的一些配置。</p>
<p><strong>一、添加评论系统</strong></p>
<p><strong>注意我现在已经改用 gitalk 啦，而下面是之前写的 valine 的教程，后面有空会更新或者增加这部分相应的内容，当然，如果你想使用的是 valine 可以继续参考下面的方法配置</strong></p>
<p>添加 <a href="https://link.segmentfault.com/?enc=tLClhVwMUTQWIvPZjCmAxQ==.hWXqJXv78IcddsAOjkwXLUgPi7o/COSI9NH0szh8Toc=">valine</a> 评论系统，打开 &#x2F;themes&#x2F;next&#x2F;_config.yml 文件，搜索 valine，开启 valine，设置 enable 为 true。</p>
<p>然后到 leanCloud <a href="https://link.segmentfault.com/?enc=Z3bGxJiTF6pdYdhyh1VLCQ==.5g+oJUHmWJf3syjDAQaHtrCjkwkBC11bbP80vHyqKi4UGex9VokmDD2JMmQpoTMiuR/w1FQG0JfDTWDpvH59Zg==">登录</a>或者<a href="https://link.segmentfault.com/?enc=6IE6gFx7KpL5hN0YtbMugA==.wGdmqE1XA+bgCzXPwUqKwSDQJdF7oU5+BhVfNP1q/z2MEybJ/Hxw5bF9hOBGdAkb6ksPQCGZnXYUlrt8qynkMA==">注册</a> 一个账号，注册后登录创建一个应用，然后进入应该到设置里面找到 AppId 和 AppKey 复制粘贴到主题配置文件里面对应的地方，就是上图中的 appid 和 appkey 这两个地方。</p>
<h3 id="二、配置腾讯公益404页面"><a href="#二、配置腾讯公益404页面" class="headerlink" title="二、配置腾讯公益404页面"></a><strong>二、配置腾讯公益404页面</strong></h3><ol>
<li>在博客根目录 &#x2F;source 文件夹下创建404.html（具体内容见下图及代码）；</li>
<li>在 html 上方加入上面3行代码；</li>
</ol>
<p>腾讯公益用到的js其实有有三个，search_children.js、data.js以及page.js，如果你的站点协议是 http 的话直接按照 next 文件的方法添加就可以了，但如果是 https 话直接添加是会报错的，因为腾讯公益404页面暂时还不支持 https，所以我直接把 page.js 的内容直接加入到页面是可以成功的，请看下图</p>
]]></content>
      <categories>
        <category>博客</category>
      </categories>
      <tags>
        <tag>博客框架</tag>
      </tags>
  </entry>
  <entry>
    <title>Java爬虫</title>
    <url>/2023/09/25/java-spider/</url>
    <content><![CDATA[<p>Java编写的开源Web爬虫<br>10. Apache Nutch<br>实现语言： Java<br>GitHub星标数： 1743<br>官方支持链接</p>
<p>简介：</p>
<p>Apache Nutch是一种高度可扩展、可伸缩的开源Web爬虫软件项目。<br>如果要列出最好的开源Web爬虫列表，Apache Nutch无疑金榜题名。<br>作为一种用于数据挖掘的高度可扩展、可伸缩的开源代码Web数据抽取软件项目，Apache Nutch得到了广泛的使用。<br>Nutch支持单机运行，但是在Hadoop集群上运行可最大化地发挥其强大能力。<br>全球范围内很多数据分析人员和科研人员、应用开发人员和Web文本挖掘工程师都在使用Apache Nutch。<br>Apache Nutch是一种Java编写的跨平台解决方案。<br>特性：</p>
<p>默认情况下，爬取数据和分析数据是独立的过程。<br>广泛支持多种文档格式，包括纯文本、HTML&#x2F;XHTML+XML、XML、PDF、ZIP等。<br>使用XPath和命名空间实现映射。<br>通过Hadoop支持分布式文件系统。<br>链接图形式的数据库。<br>支持NTLM认证。<br>– 官方文档： <a href="https://wiki.apache.org/nutch/">https://wiki.apache.org/nutch/</a></p>
<p>– 官方网站： <a href="http://nutch.apache.org/">http://nutch.apache.org/</a></p>
<ol start="11">
<li>Heritrix<br>实现语言： Java<br>GitHub星标数： 1236<br>官方支持链接<br>简介：</li>
</ol>
<p>在使用Java编写的免费开源Web爬虫中，Heritrix是其中一种得到广泛使用的工具。事实上，它是一种可扩展、Web规模、存档质量（archival-quality）的Web爬取项目。<br>Heritrix是一种扩展能力和性能很好的解决方案，支持用户即刻爬取并归档一组网站。此外，它在设计上考虑了robots.txt禁止规则和META机器人标签。<br>Heritrix可运行在Linux&#x2F;Unix和Windows系统上。<br>特性：</p>
<p>HTTP认证。<br>NTLM认证。<br>链接抽取中的XSL转换。<br>独立于搜索引擎。<br>是一种成熟并稳定的平台。<br>高度可配置。<br>支持在任一机器上运行。<br>– 官方文档： <a href="https://github.com/internetarchive/heritrix3/wiki/Heritrix%203.0%20and%203.1%20User%20Guide">https://github.com/internetarchive/heritrix3/wiki/Heritrix%203.0%20and%203.1%20User%20Guide</a></p>
<p>– 官方网站： <a href="https://github.com/internetarchive/heritrix3b">https://github.com/internetarchive/heritrix3b</a></p>
<ol start="12">
<li>ACHE爬虫<br>实现语言： Java<br>GitHub星标数： 154<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>ACHE是一种专用于特定用途的Web爬虫。<br>ACHE爬取满足特定标准的Web页面。例如，属于特定领域并包含用户指定模式的页面。<br>不同于通用爬虫，ACHE使用页面分类器遴选特定领域中的相关和无关页面。<br>页面分类器可以是基本的正则表达式（例如，匹配所有包含给定单词的页面），也可以基于机器学习的分类模型。ACHE也可以自动学习如何对链接做优先处理，实现高效地定位相关内容，避免检索无关的页面内容。<br>特性：</p>
<p>对固定网站列表的正常爬取。<br>通过自动链接优先处理，发现并爬取新的相关网站。<br>可配置不同类型的页面分类器（例如，机器学习、正则表达式等）。<br>持续重新爬取站点，实现页面更新的发现。<br>使用ElasticSearch对爬取页面做索引。<br>实时搜索爬取页面的Web接口。<br>用于监控爬虫的REST API和基于Web的用户接口。<br>使用TOR代理爬取隐含服务。<br>– 官方文档： <a href="http://ache.readthedocs.io/en/latest/">http://ache.readthedocs.io/en/latest/</a></p>
<p>– 官方网站： <a href="https://github.com/ViDA-NYU/ache">https://github.com/ViDA-NYU/ache</a></p>
<ol start="13">
<li>Crawler4j<br>实现语言： Java<br>GitHub星标数： 3039<br>官方支持链接<br>简介：</li>
</ol>
<p>crawler4j是一种Java编写的开源Web爬虫，提供了爬取Web网站的基本接口。<br>开发人员可以使用crawler4j在数分钟内建立一个多线程Web爬虫。<br>– 官方文档： <a href="https://github.com/yasserg/crawler4j">https://github.com/yasserg/crawler4j</a></p>
<p>– 官方网站： <a href="https://github.com/yasserg/crawler4j">https://github.com/yasserg/crawler4j</a></p>
<ol start="14">
<li>Gecco<br>实现语言： Java<br>GitHub星标数： 1245<br>官方支持链接<br>简介：</li>
</ol>
<p>Gecco是一种使用Java开发的轻量级Web爬虫，易于使用。<br>Gecco集成了jsoup、httpclient、fastjson、spring、htmlunit、redission等优秀框架。用户只需要配置一系列jQuery风格选择器，就能很快地建立一个爬虫。<br>Gecco框架具有优秀的扩展能力。框架基于一些开放式和封闭式设计原则，对改进封闭，对扩展开放。<br>特性：</p>
<p>易于使用，使用jQuery风格选择器抽取元素。<br>支持页面中的异步Ajax请求。<br>支持页面JavaScript变量抽取。<br>使用Redis实现分布式爬取（参见gecco-redis文档）。<br>支持使用Spring开发业务逻辑（参见gecco-spring文档）。<br>支持htmlunit扩展（参见gecco-htmlunit文档）。<br>支持多种扩展机制。<br>支持下载UserAgent的随机选择。<br>支持下载代理服务器的随机选取。<br>– 官方文档： <a href="https://github.com/xtuhcy/gecco">https://github.com/xtuhcy/gecco</a></p>
<p>– 官方网站： <a href="https://github.com/xtuhcy/gecco">https://github.com/xtuhcy/gecco</a></p>
<ol start="15">
<li>BUbiNG<br>实现语言： Java<br>GitHub星标数：24<br>官方支持链接<br>简介：</li>
</ol>
<p>BUbiNG令人惊喜，它可称为下一代的开源Web爬虫。BUbiNG是一种Java开发的完全分布式爬虫（无需中央协调），每秒可爬取数千个网页，并支持采集大规模数据集。<br>BUbiNG的分布式是基于高速协议实现的，因此可以获得非常高的通量。<br>BUbiNG提供对海量数据的大规模爬取。它完全可配置、易于扩展，并可集成垃圾信息检测。<br>特性：</p>
<p>高度并行。<br>完全分布式。<br>使用JAI4J。JAI4J是一种基于JGroups实现的瘦功能层，实现任务指派。<br>（当前）使用剥离网页的指纹，检测近似的重复内容。<br>快速。<br>大规模爬取。<br>– 官方文档： <a href="http://law.di.unimi.it/software/bubing-docs/index.html">http://law.di.unimi.it/software/bubing-docs/index.html</a></p>
<p>– 官方网站： <a href="http://law.di.unimi.it/software.php#bubing">http://law.di.unimi.it/software.php#bubing</a></p>
<ol start="16">
<li>Narconex<br>实现语言：Java<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>对于寻求可满足企业级需求的开源Web爬虫的用户而言，Narconex是一种很好的工具。<br>Norconex支持用户爬取任何Web内容。用户可以独立运行这种全功能数据采集器，或是将其集成在自己的应用中。<br>支持所有操作系统。可在具有一般容量的单体服务器上爬取数百万信息。此外，Narconex提供多种内容和元数据操作特性，还可以抽取页面中特定的图像。<br>特性：</p>
<p>多线程。<br>支持按各种计划任务，抽取不同时间段的数据。<br>从HTML、Word、PDF等多种文件格式中抽取文本内容。<br>抽取文档相关的元数据。<br>支持抽取使用用JavaScript渲染的页面。<br>检测语言。<br>支持翻译。<br>可配置爬取速度。<br>可检测发生修改或已被删除的文档。<br>支持使用外部命令分析或操作文档。<br>– 官方文档： <a href="http://www.norconex.com/collectors/collector-http/getting-started">http://www.norconex.com/collectors/collector-http/getting-started</a></p>
<p>– 官方网站： <a href="http://www.norconex.com/collectors/collector-http/">http://www.norconex.com/collectors/collector-http/</a></p>
<ol start="17">
<li>WebSPHINX<br>实现语言： Java<br>当前尚不提供官方支持。</li>
</ol>
<p>简介：</p>
<p>WebSphinix是一种非常易于使用的可定制Web爬虫。它设计用于高级Web用户和Java编程人员，支持他们自动爬取小部分Web。<br>WebSphinix数据抽取解决方案也提供了一种全面的Java类库和交互式软件开发环境。WebSphinix包括两部分：爬虫基准测试（Crawler Workbench），WebSPHINX类库。<br>爬虫基准测试提供了很好的用户图形接口，支持用户配置并控制定制的Web爬虫。<br>WebSPHINX类库为使用Java编写Web爬虫提供支持。<br>WebSphinix支持运行在Windows、Linux、Mac和Android IOS上。<br>特性：</p>
<p>以图的方式可视化Web页面采集。<br>将多个页面组合为单个文档，以供查看和打印。<br>支持抽取所有满足设定模式的文本。<br>支持HTML解析。<br>支持robot.txt禁止标准。<br>通用HTML转换。<br>多线程Web页面检索。<br>– 官方文档： <a href="https://www.cs.cmu.edu/~rcm/websphinx/doc/index.html">https://www.cs.cmu.edu/~rcm/websphinx/doc/index.html</a></p>
<p>– 官方网站： <a href="https://www.cs.cmu.edu/~rcm/websphinx/#about">https://www.cs.cmu.edu/~rcm/websphinx/#about</a></p>
<ol start="18">
<li>Spiderman<br>实现语言： Java<br>GitHub星标数： 2400<br>官方支持链接<br>简介：</li>
</ol>
<p>Spiderman是一种Java开源Web数据抽取工具。它采集特定的Web页面，并从中抽取有用数据。<br>Spiderman主要使用XPath和正则表达式等技术抽取实际数据。<br>特性：</p>
<p>更高的性能。<br>持久化集合状态。<br>分布式。<br>支持JavaScript。</p>
<p>– 官方文档： <a href="https://gitee.com/l-weiwei/spiderman">https://gitee.com/l-weiwei/spiderman</a><br>– 官方网站： <a href="https://gitee.com/l-weiwei/spiderman">https://gitee.com/l-weiwei/spiderman</a></p>
<ol start="19">
<li>WebCollector :<br>实现语言： Java<br>GitHub星标数： 1986<br>官方支持链接<br>简介：</li>
</ol>
<p>WebCollector是一种基于Java的开源Web爬虫框架。<br>它为实现Web爬取功能提供了一下基本的接口。用户可以使用它在五分钟内建立起一个多线程爬虫。<br>特性：</p>
<p>快速。<br>– 官方文档： <a href="https://github.com/CrawlScript/WebCollector">https://github.com/CrawlScript/WebCollector</a></p>
<p>– 官方网站： <a href="https://github.com/CrawlScript/WebCollector">https://github.com/CrawlScript/WebCollector</a></p>
<ol start="20">
<li>Webmagic<br>实现语言： Java<br>GitHub星标数： 6891<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>WebMagic是一种可扩展的爬虫框架。<br>WebMagic涵盖了爬虫的整个生命周期，包括下载、URL管理、内容抽取和持久化。<br>可用于简化一些特定爬虫的开发。<br>特性：</p>
<p>高度灵活的简单内核。<br>提供实现HTML抽取的简单API。<br>使用POJO标注定制爬虫，无需配置。<br>支持多线程和分布式。<br>易于集成。<br>– 官方文档： <a href="http://webmagic.io/docs/en/">http://webmagic.io/docs/en/</a></p>
<p>– 官方网站： <a href="https://github.com/code4craft/webmagic">https://github.com/code4craft/webmagic</a></p>
<ol start="21">
<li>StormCrawler<br>实现语言： Java<br>GitHub星标数：437<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>StormCrawler是一种基于Apache Storm构架分布式Web爬虫的开源SDK。<br>StormCrawler为开发人员构建爬虫提供了软件库和一系列资源。<br>StormCrawler完全适用于以数据流提供需获取和解析的URL的情况，也非常适用于大规模递归性爬取，尤其是需要低延迟的情况。<br>特性：</p>
<p>可扩展。<br>有弹性。<br>低延迟。<br>易于扩展。<br>运行良好且高效。<br>– 官方文档： <a href="http://stormcrawler.net/docs/api/">http://stormcrawler.net/docs/api/</a></p>
<p>– 官方网站： <a href="http://stormcrawler.net/">http://stormcrawler.net/</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Java爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>java提高</title>
    <url>/2021/11/11/java%E6%8F%90%E9%AB%98/</url>
    <content><![CDATA[<h3 id="垃圾收集器有几种"><a href="#垃圾收集器有几种" class="headerlink" title="垃圾收集器有几种"></a>垃圾收集器有几种</h3><h3 id="垃圾收集器低层原理剖析"><a href="#垃圾收集器低层原理剖析" class="headerlink" title="垃圾收集器低层原理剖析"></a>垃圾收集器低层原理剖析</h3><h3 id="垃圾收集器算法优化"><a href="#垃圾收集器算法优化" class="headerlink" title="垃圾收集器算法优化"></a>垃圾收集器算法优化</h3>]]></content>
      <categories>
        <category>java垃圾回收机制</category>
      </categories>
      <tags>
        <tag>垃圾收集</tag>
      </tags>
  </entry>
  <entry>
    <title>js模块化</title>
    <url>/2022/08/14/js%E6%A8%A1%E5%9D%97%E5%8C%96/</url>
    <content><![CDATA[<h2 id="CommonJS"><a href="#CommonJS" class="headerlink" title="CommonJS"></a>CommonJS</h2><h2 id="ESM"><a href="#ESM" class="headerlink" title="ESM"></a>ESM</h2>]]></content>
      <categories>
        <category>模块化</category>
      </categories>
      <tags>
        <tag>js模块化</tag>
      </tags>
  </entry>
  <entry>
    <title>jdbc连接数据库SSL</title>
    <url>/2022/07/17/jdbc%E8%BF%9E%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93SSL/</url>
    <content><![CDATA[<h4 id="在Java8及高版本以上的版本在调用ssl时会出现javax-net-ssl-SSLHandshakeException-No-appropriate-protocol的异常。"><a href="#在Java8及高版本以上的版本在调用ssl时会出现javax-net-ssl-SSLHandshakeException-No-appropriate-protocol的异常。" class="headerlink" title="在Java8及高版本以上的版本在调用ssl时会出现javax.net.ssl.SSLHandshakeException: No appropriate protocol的异常。"></a>在Java8及高版本以上的版本在调用ssl时会出现<code>javax.net.ssl.SSLHandshakeException: No appropriate protocol</code>的异常。</h4><figure class="highlight java"><table><tr><td class="code"><pre><span class="line">javax.net.ssl.SSLHandshakeException: No appropriate <span class="title function_">protocol</span> <span class="params">(protocol is disabled or cipher suites are inappropriate)</span></span><br><span class="line">	at sun.security.ssl.HandshakeContext.&lt;init&gt;(HandshakeContext.java:<span class="number">171</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at sun.security.ssl.ClientHandshakeContext.&lt;init&gt;(ClientHandshakeContext.java:<span class="number">98</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at sun.security.ssl.TransportContext.kickstart(TransportContext.java:<span class="number">220</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at sun.security.ssl.SSLSocketImpl.startHandshake(SSLSocketImpl.java:<span class="number">428</span>) ~[na:<span class="number">1.8</span><span class="number">.0_292</span>]</span><br><span class="line">	at com.mysql.cj.protocol.ExportControlled.performTlsHandshake(ExportControlled.java:<span class="number">316</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	at com.mysql.cj.protocol.StandardSocketFactory.performTlsHandshake(StandardSocketFactory.java:<span class="number">188</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeSocketConnection.performTlsHandshake(NativeSocketConnection.java:<span class="number">99</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	at com.mysql.cj.protocol.a.NativeProtocol.negotiateSSLConnection(NativeProtocol.java:<span class="number">331</span>) ~[mysql-connector-java-<span class="number">8.0</span><span class="number">.17</span>.jar:<span class="number">8.0</span><span class="number">.17</span>]</span><br><span class="line">	... <span class="number">68</span> common frames omitted</span><br></pre></td></tr></table></figure>


<h4 id="解决办法如下："><a href="#解决办法如下：" class="headerlink" title="解决办法如下："></a>解决办法如下：</h4><ol>
<li>修改<code>jre/lib/security/java.security</code>中的<code>disabledAlgorithms</code>，删除<code>SSLv3, TLSv1, TLSv1.1</code>，然后重启应用即可。在vim下，可以使用<code>/disabledAlgorithms</code>快速查找。</li>
</ol>
<p><code>jdk.tls.disabledAlgorithms=RC4, DES, MD5withRSA, \     DH keySize &lt; 1024, EC keySize &lt; 224, 3DES_EDE_CBC, anon, NULL, \     include jdk.disabled.namedCurves</code></p>
<p>如果修改了，保存了，重启了还是没有效果，就看下面这个方法：</p>
<ol start="2">
<li>修改jdk配置文件<code>/etc/crypto-policies/back-ends/java.config</code>，类似上面方法一样，删除<code>SSLv3, TLSv1, TLSv1.1</code>，保存重启应用。</li>
</ol>
<p><code>jdk.tls.disabledAlgorithms=DH keySize &lt; 2048, SSLv2, SSLv3, TLSv1.1, DHE_DSS, RSA_EXPORT, DHE_DSS_EXPORT, DHE_RSA_EXPORT, DH_DSS_EXPORT, DH_RSA_EXPORT, DH_anon, ECDH_anon, DH_RSA, DH_DSS, ECDH, 3DES_EDE_CBC, DES_CBC, RC4_40, RC4_128, DES40_CBC, RC2, HmacMD5</code></p>
<ol start="3">
<li><p>另外jdk奇数版本可用，偶数版本有上面这个问题，可用通过<code>yum --showduplicate list java* | grep 1.8.0</code>查看可用的版本，选择奇数版本安装也能解决这个问题。</p>
</li>
<li><p>更新crypto-policies</p>
<p><code>update-crypto-policies --set LEGACY</code></p>
</li>
</ol>
]]></content>
      <categories>
        <category>jdbc</category>
      </categories>
      <tags>
        <tag>jdbc的SSL问题</tag>
      </tags>
  </entry>
  <entry>
    <title>Node.js爬虫</title>
    <url>/2023/09/25/nodejs-spider/</url>
    <content><![CDATA[<ul>
<li>Node.js常用爬虫框架与无头浏览器</li>
</ul>
<p><strong>NodeCrawler</strong><br><strong>Simplecrawler</strong><br><strong>Simplecrawler</strong></p>
<p><a href="https://www.npmjs.com/package/puppeteer"><strong>puppeteer</strong></a></p>
<p>JavaScript编写的开源Web爬虫<br>22. NodeCrawler<br>实现语言： JavaScript<br>GitHub星标数： 3999<br>官方支持链接</p>
<p>简介：</p>
<p>NodeCrawler是一种广为使用的Web爬虫，它基于NodeJS实现，具有非常快的爬取速度。<br>Nodecrawler非常适用于偏爱使用JavaScript编程或者致力于JavaScript项目的开发人员。其安装也非常简单。<br>JSDOM和Cheerio（用于HTML解析）实现服务器端渲染。其中，JSDOM更为稳定。<br>特性：</p>
<p>使用 Cheerio（默认）或JSDOM实现服务端DOM和自动jQuery插入。<br>可配置池子规模和重试次数。<br>控制爬取率限制。<br>请求的优先队列。<br>支持forceUTF8模式，使得爬虫可以检测并转换字符集。<br>与4.x乃至更新版本兼容。<br>– 官方文档：<a href="https://github.com/bda-research/node-crawler">https://github.com/bda-research/node-crawler</a></p>
<p>– 官方网站：<a href="http://nodecrawler.org/">http://nodecrawler.org/</a></p>
<ol start="23">
<li>Simplecrawler<br>实现语言： JavaScript<br>GitHub星标数：1764<br>官方支持链接<br>简介：</li>
</ol>
<p>Simplecrawler设计提供基本的、灵活且稳定的网站爬取API。<br>Simplecrawler在实现上考虑了针对特大型Web站点的归档、分析和搜索。它可爬取上百万页面，并毫无问题地向磁盘写入数十GB数据。<br>特性：</p>
<p>提供了用于自动检测链接资源的一些简单逻辑，用户可自行替换和添加。<br>自动请求任何robots.txt禁止规则。<br>具有灵活的队列系统，可在磁盘上冻结和解冻。<br>– 官方文档： <a href="https://github.com/simplecrawler/simplecrawler">https://github.com/simplecrawler/simplecrawler</a></p>
<p>– 官方网站： <a href="https://www.npmjs.com/package/simplecrawler">https://www.npmjs.com/package/simplecrawler</a></p>
<ol start="24">
<li>Js-crawler :<br>实现语言： JavaScript<br>GitHub星标数： 167<br>官方支持链接)<br>简介：</li>
</ol>
<p>使用NodeJS实现的Web爬虫，支持HTTP和HTTPS<br>– 官方文档： <a href="https://github.com/antivanov/js-crawler">https://github.com/antivanov/js-crawler</a></p>
<p>– 官方网站： <a href="https://github.com/antivanov/js-crawler">https://github.com/antivanov/js-crawler</a></p>
<ol start="25">
<li>Webster<br>实现语言： JavaScript<br>GitHub星标数： 201<br>官方支持链接<br>简介：</li>
</ol>
<p>Webster是一种使用NodeJS编写的可靠Web爬取和采集框架，用于爬取Web站点并从页面中抽取结构化数据。<br>与其他爬取框架的不同之处在于，Webster可以抓取浏览器客户端的JavaScript和Ajax请求呈现的内容。<br>– 官方文档： <a href="http://webster.zhuyingda.com/">http://webster.zhuyingda.com/</a></p>
<p>– 官方网站： <a href="https://github.com/zhuyingda/webster">https://github.com/zhuyingda/webster</a></p>
<ol start="26">
<li>Node-osmosis<br>实现语言：JavaScript<br>GitHub星标数： 3630<br>**官方支持链接<br>简介：</li>
</ol>
<ul>
<li>一种使用NodeJS实现的HTML&#x2F;XML解析器和Web爬虫。</li>
</ul>
<p>特性：</p>
<p>使用原生libxml的C绑定。<br>干净的Promise类接口。<br>支持CSS 3.0和XPath 1.0选择器的混合。<br>Sizzle选择器、Slick选择器以及更多。<br>不具有像jQuery、cheerio或jsdom那样的大型依赖。<br>构成深度和复杂的数据结构。<br>HTML解析器特性：<br>快速解析；<br>高速搜索；<br>内存占用小。<br>HTML DOM特性：<br>加载和搜索ajax内容；<br>DOM交互和事件；<br>执行嵌入和远程脚本；<br>在DOM中执行代码。<br>HTTP请求特性：<br>日志记录URL，重定向和错误；<br>Cookie的jar包，以及自定义Cookie&#x2F;头部&#x2F;用户代理；<br>登录&#x2F;表单提交、会话Cookie，基本的认证；<br>单代理、多代理，处理代理失败情况；<br>限制重试和重定向。<br>– 官方文档： <a href="https://rchipka.github.io/node-osmosis/global.html">https://rchipka.github.io/node-osmosis/global.html</a></p>
<p>– 官方网站： <a href="https://www.npmjs.com/package/osmosis">https://www.npmjs.com/package/osmosis</a></p>
<ol start="27">
<li>Supercrawler<br>实现语言：JavaScript<br>GitHub星标数： 4341<br>官方支持链接<br>简介：</li>
</ol>
<p>Supercrawler是一种使用NodeJS实现的Web爬虫，在设计上支持高度可配置和易用性。<br>一旦成功爬取一个网页（可以是图像、文本文档或其他任何文件），Supercrawler将会触发用户自定义的内容类型（content-type）处理器，处理页面解析、保存数据以及其它一些用户定义的功能。<br>特性：</p>
<p>链接检测：Supercrawler会解析所爬取的HTML文档，识别其中链接并添加到队列中。<br>机器人解析：在爬取前Supercrawler会请求robots.txt并检查其中的禁止规则。它也可识别站点地图。<br>站点地图解析：Supercrawler可以从XML站点地图文件中读取链接，并将链接添加到队列中。<br>并发限制：Supercrawler可限制在任一时间发出的请求数。<br>速率限制：Supercrawler可添加请求的时延，以免对服务器产生轰炸。<br>指数补偿（Exponential backoff）重试：Supercrawler将依此在一小时、两小时、四小时乃至更多时间后重试请求。要使用该特性，爬取队列必须使用数据库或Redis作为后端。<br>主机名均衡：Supercrawler可在不同主机名间平均分割请求量。要使用该特性，爬取队列必须以Redis为后端。<br>– 官方文档： <a href="https://github.com/brendonboshell/supercrawler">https://github.com/brendonboshell/supercrawler</a></p>
<p>– 官方网站： <a href="https://github.com/brendonboshell/supercrawler">https://github.com/brendonboshell/supercrawler</a></p>
<ol start="28">
<li>Web scraper的Chrome扩展<br>实现语言：JavaScript<br>GitHub星标数： 775<br>官方支持链接<br>简介：</li>
</ol>
<p>Web Scraper是一种Chrome浏览器扩展，构建用于从Web页面抽取数据。<br>用户可以使用该扩展创建计划（站点地图），定义如何遍历一个Web网站，以及如何从中抽取数据。<br>Web Scraper使用站点地图相应地遍历网站，并从中抽取数据。<br>支持以CSV格式导出所抽取的数据。<br>特性：</p>
<p>抽取多个页面。<br>站点地图和抽取的数据存储在浏览器的本地存储，也可存储在CouchDB中。<br>多种数据类型选取。<br>支持从动态网页（JavaScript+AJAX）抽取数据。<br>浏览抽取的数据。<br>以CSV格式导出抽取的数据。<br>导入、导出站点地图。<br>只依赖于Chrome浏览器。<br>– 官方文档： <a href="https://www.webscraper.io/documentation">https://www.webscraper.io/documentation</a></p>
<p>– 官方网站： <a href="https://www.webscraper.io/">https://www.webscraper.io</a></p>
<ol start="29">
<li>Headless Chrome爬虫<br>实现语言：JavaScript<br>GitHub星标数： 3256<br>官方支持链接</li>
</ol>
<p>简介：</p>
<p>使用基本HTML文件请求的爬虫，通常速度很快。但这样的爬虫往往会抽取到空白内容，尤其是在爬取使用AngularJS、React和Vue.js等现代前端框架构建的网站时。<br>特性：</p>
<p>分布式爬取。<br>可配置并发、延迟和重试。<br>支持深度优先搜索和广度优先搜索算法。<br>支持插拔缓存存储，例如Redis。<br>支持导出CSV和JSON。<br>在达到最大请求时暂停爬取，并可在任一时刻恢复。<br>自动插入用于抽取的jQuery。<br>保存屏幕截图，用于证实爬取过程。<br>模拟设备和用户代理。<br>具有优先队列，可提高爬取效率。<br>– 官方文档： <a href="https://github.com/yujiosaka/headless-chrome-crawler/blob/master/docs/API.md">https://github.com/yujiosaka/headless-chrome-crawler/blob/master/docs/API.md</a></p>
<p>– 官方网站： <a href="https://github.com/yujiosaka/headless-chrome-crawler">https://github.com/yujiosaka/headless-chrome-crawler</a></p>
<ol start="30">
<li>X-ray<br>实现语言：JavaScript<br>GitHub星标数： 4464<br>官方支持链接</li>
</ol>
<p>特性：</p>
<p>模式灵活：支持字符串、数组、对象以及嵌套对象结构。模式并非绑定于所抽取的页面结构，支持用户获取选定结构中的数据。<br>可组合（Composable）：API是完全可组合的，赋予用户抽取每个页面的极大灵活性。<br>分页支持：爬取页面在Web站点上的所有分页。X-ray还支持请求延迟和分页限制，并支持将爬取页面导入到单个文件中。这样一旦单个页面产生错误，用户不会失去所有已爬取的数据。<br>爬虫支持：从一个页面开始，轻易跳转另一个页面。页面跳转是可预测的，按深度优先爬取所有页面。<br>负责任的爬取：X-ray支持并发、限制、延迟、超时和限制，实现负责任地爬取任何页面。<br>可插拔驱动：可按用户需求置换不同的爬虫。<br>– 官方文档： <a href="https://github.com/matthewmueller/x-ray">https://github.com/matthewmueller/x-ray</a></p>
<p>– 官方网站： <a href="https://www.npmjs.com/package/x-ray-scraper">https://www.npmjs.com/package/x-ray-scraper</a></p>
]]></content>
      <categories>
        <category>爬虫</category>
      </categories>
      <tags>
        <tag>Node.js爬虫</tag>
      </tags>
  </entry>
  <entry>
    <title>Markdown Syntax</title>
    <url>/2023/09/24/markdown-syntax/</url>
    <content><![CDATA[<h2 id="Markdown-基础语法"><a href="#Markdown-基础语法" class="headerlink" title="Markdown 基础语法"></a>Markdown 基础语法</h2><p> <strong>语法文档</strong> <a href="http://markdown.p2hp.com/extended-syntax/">中文</a> <a href="https://www.markdownguide.org/">英文</a></p>
<ul>
<li><p>标题等级</p>
<ul>
<li>标题级别4<h4 id="Heading-level-4"><a href="#Heading-level-4" class="headerlink" title="Heading level 4"></a>Heading level 4</h4></li>
<li>标题级别5<h5 id="Heading-level-5"><a href="#Heading-level-5" class="headerlink" title="Heading level 5"></a>Heading level 5</h5></li>
</ul>
</li>
</ul>
]]></content>
      <categories>
        <category>Markdown</category>
      </categories>
      <tags>
        <tag>Markdown</tag>
      </tags>
  </entry>
  <entry>
    <title>Nodejs包管理器</title>
    <url>/2022/08/14/node%E5%8C%85%E7%AE%A1%E7%90%86%E5%99%A8/</url>
    <content><![CDATA[<h3 id="npm"><a href="#npm" class="headerlink" title="npm"></a>npm</h3><h3 id="npx"><a href="#npx" class="headerlink" title="npx"></a>npx</h3><h3 id="yarn"><a href="#yarn" class="headerlink" title="yarn"></a>yarn</h3><h3 id="pnpm"><a href="#pnpm" class="headerlink" title="pnpm"></a>pnpm</h3>]]></content>
      <categories>
        <category>包管理器</category>
      </categories>
      <tags>
        <tag>Nodejs包管理器</tag>
      </tags>
  </entry>
  <entry>
    <title>oracleSQL</title>
    <url>/2022/07/14/oracleSQL/</url>
    <content><![CDATA[<p><strong>查询Oracle中所有用户信息</strong></p>
<p><strong>1、查看所有用户：</strong></p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from dba_users; ``select * from all_users; ``select * from user_users;</span><br></pre></td></tr></table></figure>

<p>2、查看用户或角色系统权限(直接赋值给用户或角色的系统权限)：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from dba_sys_privs; ``select * from user_sys_privs; (查看当前用户所拥有的权限)</span><br></pre></td></tr></table></figure>

<p>3、查看角色(只能查看登陆用户拥有的角色)所包含的权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sql&gt;select * from role_sys_privs;</span><br></pre></td></tr></table></figure>

<p>4、查看用户对象权限：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from dba_tab_privs; ``select * from all_tab_privs; ``select * from user_tab_privs;</span><br></pre></td></tr></table></figure>

<p>5、查看所有角色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from dba_roles;</span><br></pre></td></tr></table></figure>

<p>6、查看用户或角色所拥有的角色：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from dba_role_privs; ``select * from user_role_privs;</span><br></pre></td></tr></table></figure>

<p>7、查看哪些用户有sysdba或sysoper系统权限(查询时需要相应权限)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select * from V``$PWFILE_USERS</span><br></pre></td></tr></table></figure>

<p>8、SqlPlus中查看一个用户所拥有权限</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SQL&gt;select * from dba_sys_privs where grantee=``&#x27;username&#x27;``; 其中的username即用户名要大写才行。``比如： SQL&gt;select * from dba_sys_privs where grantee=``&#x27;TOM&#x27;``;</span><br></pre></td></tr></table></figure>

<p>9、Oracle删除指定用户所有表的方法</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ``&#x27;Drop table &#x27;``||table_name||``&#x27;;&#x27;` `from all_tables where owner=``&#x27;要删除的用户名(注意要大写)&#x27;``;</span><br></pre></td></tr></table></figure>

<p>10、删除用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">drop user user_name cascade; 如：drop user SMCHANNEL CASCADE</span><br></pre></td></tr></table></figure>

<p>11、获取当前用户下所有的表：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select table_name from user_tables;</span><br></pre></td></tr></table></figure>

<p>12、删除某用户下所有的表数据:</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ``&#x27;truncate table &#x27;` `|| table_name from user_tables;</span><br></pre></td></tr></table></figure>

<p>13、禁止外键 ORACLE数据库中的外键约束名都在表user_constraints中可以查到。</p>
<p>其中constraint_type&#x3D;’R’表示是外键约束。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">启用外键约束的命令为：alter table table_name enable constraint constraint_name ``禁用外键约束的命令为：alter table table_name disable constraint constraint_name</span><br></pre></td></tr></table></figure>

<p>然后再用SQL查出数据库中所以外键的约束名：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">select ``&#x27;alter table &#x27;``||table_name||``&#x27; enable constraint &#x27;``||constraint_name||``&#x27;;&#x27;` `from user_constraints where constraint_type=``&#x27;R&#x27;``select ``&#x27;alter table &#x27;``||table_name||``&#x27; disable constraint &#x27;``||constraint_name||``&#x27;;&#x27;` `from user_constraints where constraint_type=``&#x27;R&#x27;</span><br></pre></td></tr></table></figure>

<p>14、ORACLE禁用&#x2F;启用外键和触发器 –启用脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET SERVEROUTPUT ON SIZE 1000000``BEGIN``for` `c in (select ``&#x27;ALTER TABLE &#x27;``||TABLE_NAME||``&#x27; ENABLE CONSTRAINT &#x27;``||constraint_name||``&#x27; &#x27;` `as` `v_sql from user_constraints``where CONSTRAINT_TYPE=``&#x27;R&#x27;``) loop``DBMS_OUTPUT.PUT_LINE(C.V_SQL);``begin``EXECUTE IMMEDIATE c.v_sql;``exception when others then``dbms_output.put_line(sqlerrm);``end``;``end` `loop; ``for` `c in (select ``&#x27;ALTER TABLE &#x27;``||TNAME||``&#x27; ENABLE ALL TRIGGERS &#x27;` `AS v_sql from tab where tabtype=``&#x27;TABLE&#x27;``) loop``dbms_output.put_line(c.v_sql);``begin``execute immediate c.v_sql;``exception when others then``dbms_output.put_line(sqlerrm);``end``;``end` `loop;``end``;``/ ``commit;</span><br></pre></td></tr></table></figure>

<p>–禁用脚本</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SET SERVEROUTPUT ON SIZE 1000000``BEGIN``for` `c in (select ``&#x27;ALTER TABLE &#x27;``||TABLE_NAME||``&#x27; DISABLE CONSTRAINT &#x27;``||constraint_name||``&#x27; &#x27;` `as` `v_sql from user_constraints``where CONSTRAINT_TYPE=``&#x27;R&#x27;``) loop``DBMS_OUTPUT.PUT_LINE(C.V_SQL);``begin``EXECUTE IMMEDIATE c.v_sql;``exception when others then``dbms_output.put_line(sqlerrm);``end``;``end` `loop; ``for` `c in (select ``&#x27;ALTER TABLE &#x27;``||TNAME||``&#x27; DISABLE ALL TRIGGERS &#x27;` `AS v_sql from tab where tabtype=``&#x27;TABLE&#x27;``) loop``dbms_output.put_line(c.v_sql);``begin``execute immediate c.v_sql;``exception when others then``dbms_output.put_line(sqlerrm);``end``;``end` `loop;``end``;``/``commit;</span><br></pre></td></tr></table></figure>

]]></content>
  </entry>
  <entry>
    <title>centos安装docker</title>
    <url>/2022/06/06/rockylinx-install-docker/</url>
    <content><![CDATA[<h3 id="rockylinux安装教程"><a href="#rockylinux安装教程" class="headerlink" title="rockylinux安装教程"></a><a href="https://blog.csdn.net/dreamerrrrrr/article/details/119837681">rockylinux安装教程</a></h3><h1 id="install-on-CentOS-Install-Docker-Engine-on-CentOS-Docker-Documentation"><a href="#install-on-CentOS-Install-Docker-Engine-on-CentOS-Docker-Documentation" class="headerlink" title="[install on CentOS](Install Docker Engine on CentOS | Docker Documentation)"></a>[install on CentOS](<a href="https://docs.docker.com/engine/install/centos/">Install Docker Engine on CentOS | Docker Documentation</a>)</h1><h3 id="Uninstall-old-versions"><a href="#Uninstall-old-versions" class="headerlink" title="Uninstall old versions"></a>Uninstall old versions</h3><hr>
<figure class="highlight livescript"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker <span class="string">\</span></span><br><span class="line">                  docker-client <span class="string">\</span></span><br><span class="line">                  docker-client-latest <span class="string">\</span></span><br><span class="line">                  docker-common <span class="string">\</span></span><br><span class="line">                  docker-latest <span class="string">\</span></span><br><span class="line">                  docker-latest-logrotate <span class="string">\</span></span><br><span class="line">                  docker-logrotate <span class="string">\</span></span><br><span class="line">                  docker-engine </span><br></pre></td></tr></table></figure>
<h3 id="Install-using-the-repository"><a href="#Install-using-the-repository" class="headerlink" title="Install using the repository"></a>Install using the repository</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum install -y yum-utils</span><br><span class="line"> sudo yum-config-manager \</span><br><span class="line">    --add-repo \</span><br><span class="line">    http://mirrors.aliyun.com/docker-ce/linux/centos/docker-ce.repo</span><br></pre></td></tr></table></figure>
<h3 id="Install-Docker-Engine"><a href="#Install-Docker-Engine" class="headerlink" title="Install Docker Engine"></a>Install Docker Engine</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">sudo yum update</span><br><span class="line">sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin</span><br></pre></td></tr></table></figure>

<h3 id="Start-Docker"><a href="#Start-Docker" class="headerlink" title="Start Docker"></a>Start Docker</h3><hr>
<figure class="highlight crmsh"><table><tr><td class="code"><pre><span class="line">sudo systemctl <span class="literal">start</span> docker</span><br></pre></td></tr></table></figure>

<h3 id="Uninstall-Docker-Engine"><a href="#Uninstall-Docker-Engine" class="headerlink" title="Uninstall Docker Engine"></a>Uninstall Docker Engine</h3><figure class="highlight stata"><table><tr><td class="code"><pre><span class="line">sudo yum remove docker-ce docker-ce-<span class="keyword">cli</span> containerd.io docker-compose-<span class="keyword">plugin</span></span><br><span class="line">sudo <span class="keyword">rm</span> -rf /<span class="keyword">var</span>/lib/docker</span><br><span class="line">sudo <span class="keyword">rm</span> -rf /<span class="keyword">var</span>/lib/containerd</span><br></pre></td></tr></table></figure>

<h3 id="var-lib-docker-为默认工作目录"><a href="#var-lib-docker-为默认工作目录" class="headerlink" title="&#x2F;var&#x2F;lib&#x2F;docker 为默认工作目录"></a>&#x2F;var&#x2F;lib&#x2F;docker 为默认工作目录</h3><h3 id="阿里云镜像加速"><a href="#阿里云镜像加速" class="headerlink" title="阿里云镜像加速"></a>阿里云镜像加速</h3><hr>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sudo <span class="built_in">mkdir</span> -p /etc/docker</span><br><span class="line">sudo <span class="built_in">tee</span> /etc/docker/daemon.json &lt;&lt;-<span class="string">&#x27;EOF&#x27;</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="string">&quot;registry-mirrors&quot;</span>: [<span class="string">&quot;https://rz9fml8b.mirror.aliyuncs.com&quot;</span>]</span><br><span class="line">&#125;</span><br><span class="line">EOF</span><br><span class="line">sudo systemctl daemon-reload</span><br><span class="line">sudo systemctl restart docker</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>centos安装docker</tag>
      </tags>
  </entry>
  <entry>
    <title>rockylinux install</title>
    <url>/2022/09/12/rockylinux-install/</url>
    <content><![CDATA[<h1 id="安装、网络、包源配置"><a href="#安装、网络、包源配置" class="headerlink" title="安装、网络、包源配置"></a><a href="https://blog.csdn.net/dreamerrrrrr/article/details/119837681">安装、网络、包源配置</a></h1><h2 id="阿里镜像"><a href="#阿里镜像" class="headerlink" title="阿里镜像"></a>阿里镜像</h2><ul>
<li>rockylinux下载地址<code>https://mirrors.aliyun.com/rockylinux</code></li>
</ul>
<pre><code class="shell">sed -e &#39;s|^mirrorlist=|#mirrorlist=|g&#39; \
    -e &#39;s|^#baseurl=http://dl.rockylinux.org/$contentdir|baseurl=https://mirrors.aliyun.com/rockylinux|g&#39; \
    -i.bak \
    /etc/yum.repos.d/Rocky-*.repo

dnf makecache

# RHEL常用命令

- [DNF](https://wangchujiang.com/linux-command/c/dnf.html)
- [NetworkManager](https://blog.csdn.net/yangshihuz/article/details/106643970)
- [sytemctl](https://linux265.com/news/3385.html)
- [firewalld](https://blog.51cto.com/andyxu/2137046)
</code></pre>
]]></content>
      <categories>
        <category>centos</category>
      </categories>
      <tags>
        <tag>兼容centos的社区实现</tag>
      </tags>
  </entry>
  <entry>
    <title>http-framework</title>
    <url>/2023/12/17/web-http/</url>
    <content><![CDATA[<p>web 框架指的是处理 http、https 的服务端框架，Node.js 提供了 http、https 模块用于处理协议数据，这是 web 框架的基础。</p>
<p>但是 http、https 的 api 过于简单，用起来比较麻烦，所以一般会用 express、koa、fastify 这种封装了一层的框架来简化。</p>
<p>但 express 类的框架不提供代码架构方面的限制，所以对于模块比较多比较复杂的企业级应用来说并不适合，这时就要用实现了 MVC 的 eggjs、nestjs 这类企业级 web 框架。</p>
<p>这是 web 框架的 3 个层次，理清了它们的关系和适用场景，再去学习才不会迷茫。</p>
<p>下面我们分别来看一下：</p>
<h2 id="http、https"><a href="#http、https" class="headerlink" title="http、https"></a><strong>http、https</strong></h2><p>http 是基于 TCP 的，对 TCP 传过来的 http 协议数据做 parse，传给 handler 处理，handler 处理完要返回 http 响应，这是 http 模块做的事情。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> server = http.<span class="title function_">createServer</span>(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123; <span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/plain&#x27;</span> &#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;okay&#x27;</span>);</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">server.<span class="title function_">listen</span>(<span class="number">8080</span>, <span class="string">&#x27;127.0.0.1&#x27;</span>);</span><br></pre></td></tr></table></figure>

<p>http 模块虽然能处理请求和响应，但是提供的 api 过于原始：</p>
<p>比如获取请求参数还要用 url 模块 parse 一次</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">&#x27;http&#x27;</span>);</span><br><span class="line"><span class="keyword">const</span> url = <span class="built_in">require</span>(<span class="string">&#x27;url&#x27;</span>);</span><br><span class="line"></span><br><span class="line">http.<span class="title function_">createServer</span>(<span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> queryObject = url.<span class="title function_">parse</span>(req.<span class="property">url</span>,<span class="literal">true</span>).<span class="property">query</span>;</span><br><span class="line">  <span class="variable language_">console</span>.<span class="title function_">log</span>(queryObject);</span><br><span class="line"></span><br><span class="line">  res.<span class="title function_">writeHead</span>(<span class="number">200</span>, &#123;<span class="string">&#x27;Content-Type&#x27;</span>: <span class="string">&#x27;text/html&#x27;</span>&#125;);</span><br><span class="line">  res.<span class="title function_">end</span>(<span class="string">&#x27;xxx&#x27;</span>);</span><br><span class="line">&#125;).<span class="title function_">listen</span>(<span class="number">8080</span>);</span><br></pre></td></tr></table></figure>

<p>比如返回响应只能用 write 或者 end 返回一段 buffer 或 string，想返回 JSON、文件下载、html 视图等都要自己实现。</p>
<p>而且 get、post、put、delete 等请求类型也要自己做判断。</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">if</span>(req.<span class="property">method</span> === <span class="string">&#x27;get&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125; <span class="keyword">else</span> <span class="keyword">if</span> (req.<span class="property">method</span> === <span class="string">&#x27;post&#x27;</span>) &#123;</span><br><span class="line">    <span class="comment">//...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//...</span></span><br></pre></td></tr></table></figure>

<p>因为有这些痛点，所以一般我们不会直接用 http 模块，而是用封装了一层的 express、koa、fastify 这类 web 框架。</p>
<h2 id="express、koa、fastify-等"><a href="#express、koa、fastify-等" class="headerlink" title="express、koa、fastify 等"></a><strong>express、koa、fastify 等</strong></h2><p>express 这类框架解决了刚才的那个痛点问题：</p>
<ul>
<li>提供了路由机制，不用自己手动判断 method 和 path</li>
</ul>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/list&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br><span class="line">app.<span class="title function_">post</span>(<span class="string">&#x27;/save&#x27;</span>, <span class="keyword">function</span>(<span class="params">req, res</span>) &#123;</span><br><span class="line">  <span class="comment">//...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>提供了更好用的 request 和 response api：</li>
</ul>
<p>比如 req.params 获取请求参数</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">get</span>(<span class="string">&#x27;/user/:id&#x27;</span>, <span class="keyword">function</span> (<span class="params">req, res</span>) &#123;</span><br><span class="line">  res.<span class="title function_">send</span>(<span class="string">&#x27;user &#x27;</span> + req.<span class="property">params</span>.<span class="property">id</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<p>res.download 返回下载的响应</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">res.<span class="title function_">download</span>(<span class="string">&#x27;/report-12345.pdf&#x27;</span>)</span><br></pre></td></tr></table></figure>

<p>res.render 返回模版引擎渲染的 html</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">render</span>(<span class="string">&#x27;xxx-template&#x27;</span>, &#123; <span class="attr">name</span>: <span class="string">&#x27;guang&#x27;</span> &#125;, <span class="keyword">function</span> (<span class="params">err, html</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>

<ul>
<li>提供了中间件机制，用于复用一些一些逻辑：</li>
</ul>
<p>比如文件上传中间件</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line">app.<span class="title function_">use</span>(<span class="title function_">fileUpload</span>(&#123;</span><br><span class="line">    useTempFiles : <span class="literal">true</span>,</span><br><span class="line">    tempFileDir : <span class="string">&#x27;/tmp/&#x27;</span></span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>

<p>提供了这么多方便的功能，确实比 http 模块用起来简单多了。</p>
<p>但是 express 类的 web 框架也有问题，就是没有提供组织代码的模式，当模块多了代码很容易乱掉，因为它只是按照类似洋葱的顺序调用中间件，没有模块和 MVC 的划分。</p>
<p>express 类框架做一些小的服务可以，企业级应用还得用 nestjs、eggjs 这类 MVC 框架。</p>
<h2 id="nestjs、eggjs、midwayjs、daruk-等"><a href="#nestjs、eggjs、midwayjs、daruk-等" class="headerlink" title="nestjs、eggjs、midwayjs、daruk 等"></a><strong>nestjs、eggjs、midwayjs、daruk 等</strong></h2><p>nestjs 类的框架就实现了 MVC 的模式，代码有明显的 Controller、Service、Model、View 的划分：</p>
<figure class="highlight js"><table><tr><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">Body</span>, <span class="title class_">Controller</span>, <span class="title class_">Delete</span>, <span class="title class_">Get</span>, <span class="title class_">Param</span>, <span class="title class_">Post</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;@nestjs/common&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">CreateUserDto</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./dto/create-user.dto&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">User</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./user.entity&#x27;</span>;</span><br><span class="line"><span class="keyword">import</span> &#123; <span class="title class_">UsersService</span> &#125; <span class="keyword">from</span> <span class="string">&#x27;./users.service&#x27;</span>;</span><br><span class="line"></span><br><span class="line">@<span class="title class_">Controller</span>(<span class="string">&#x27;users&#x27;</span>)</span><br><span class="line"><span class="keyword">export</span> <span class="keyword">class</span> <span class="title class_">UsersController</span> &#123;</span><br><span class="line">  <span class="title function_">constructor</span>(<span class="params">private readonly usersService: UsersService</span>) &#123;&#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Post</span>()</span><br><span class="line">  <span class="title function_">create</span>(@<span class="title class_">Body</span>() <span class="attr">createUserDto</span>: <span class="title class_">CreateUserDto</span>): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">usersService</span>.<span class="title function_">create</span>(createUserDto);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Get</span>()</span><br><span class="line">  <span class="title function_">findAll</span>(): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>[]&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">usersService</span>.<span class="title function_">findAll</span>();</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Get</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="title function_">findOne</span>(@<span class="title class_">Param</span>(<span class="string">&#x27;id&#x27;</span>) <span class="attr">id</span>: string): <span class="title class_">Promise</span>&lt;<span class="title class_">User</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">usersService</span>.<span class="title function_">findOne</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  @<span class="title class_">Delete</span>(<span class="string">&#x27;:id&#x27;</span>)</span><br><span class="line">  <span class="title function_">remove</span>(@<span class="title class_">Param</span>(<span class="string">&#x27;id&#x27;</span>) <span class="attr">id</span>: string): <span class="title class_">Promise</span>&lt;<span class="keyword">void</span>&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="variable language_">this</span>.<span class="property">usersService</span>.<span class="title function_">remove</span>(id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>nestjs 是对标 java 的 spring 的，实现了 IOC、AOP 等模式，模块之间耦合度很低，就算再复杂的项目，通过 Module、Controller、Service 等也可以很好的被组织起来，相比 express 来说，组织代码方面提升了一个档次。</p>
<p>nestjs 的底层就是 express、fastify 等 web 框架，而且还可以灵活的切换底层实现。</p>
<p>可以看到，nestjs、eggjs 类的企业级框架，除了有丰富的 api 以外，更重要的是提供了代码组织的规范，通过 Module、Controller、Service 等概念可以很好的组织复杂的业务逻辑。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a><strong>总结</strong></h2><p>web 框架都是基于 http、https 模块，但它提供的 api 过于原始，使用起来比较麻烦，所以我们一般会用 express、koa 这类框架来简化，它提供了中间件机制来复用逻辑，提供了更多的 request、response 的 api，但却没有组织复杂代码的能力，对于企业级的复杂应用，还是会用 nestjs、eggjs 这类 MVC 框架，它们的底层是 express、koa，但提供了 Module、Controller、Service 等概念，可以很好的组织复杂的代码。</p>
]]></content>
      <categories>
        <category>http-framework</category>
      </categories>
      <tags>
        <tag>http-framework</tag>
      </tags>
  </entry>
  <entry>
    <title>rockylinux8-network-config</title>
    <url>/2023/12/17/rockylinux8-network-config/</url>
    <content><![CDATA[<h4 id="查看linux内核信息"><a href="#查看linux内核信息" class="headerlink" title="查看linux内核信息"></a>查看linux内核信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br></pre></td></tr></table></figure>
<h4 id="查看linux发行版信息"><a href="#查看linux发行版信息" class="headerlink" title="查看linux发行版信息"></a>查看linux发行版信息</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">cat</span> /etc/os-release</span><br></pre></td></tr></table></figure>
<h4 id="配置静态网路"><a href="#配置静态网路" class="headerlink" title="配置静态网路"></a>配置静态网路</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">vi /etc/sysconfig/network-scripts/ifcfg-ens160</span><br><span class="line"></span><br><span class="line">TYPE=Ethernet</span><br><span class="line">PROXY_METHOD=none</span><br><span class="line">BROWSER_ONLY=no</span><br><span class="line"><span class="comment"># 静态IP地址</span></span><br><span class="line">BOOTPROTO=static</span><br><span class="line">DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV4_FAILURE_FATAL=no</span><br><span class="line">IPV6INIT=<span class="built_in">yes</span></span><br><span class="line">IPV6_AUTOCONF=<span class="built_in">yes</span></span><br><span class="line">IPV6_DEFROUTE=<span class="built_in">yes</span></span><br><span class="line">IPV6_FAILURE_FATAL=no</span><br><span class="line">NAME=ens160</span><br><span class="line">UUID=293f1d04-332e-4de2-8f19-4910bca6672c</span><br><span class="line">DEVICE=ens160</span><br><span class="line"><span class="comment"># 开启</span></span><br><span class="line">ONBOOT=<span class="built_in">yes</span></span><br><span class="line"><span class="comment"># 本机地址</span></span><br><span class="line">IPADDR=192.168.166.6</span><br><span class="line"><span class="comment"># 子网掩码</span></span><br><span class="line">NETMASK=255.255.255.0</span><br><span class="line"><span class="comment"># 虚拟VM8网卡 NAT 网关</span></span><br><span class="line">GATEWAY=192.168.166.2</span><br><span class="line"><span class="comment"># DNS 域名解析服务器IP地址</span></span><br><span class="line">DNS1=114.114.114.114</span><br><span class="line">DNS2=223.5.5.5</span><br><span class="line">DNS3=8.8.8.8</span><br></pre></td></tr></table></figure>
<h4 id="重启网络"><a href="#重启网络" class="headerlink" title="重启网络"></a>重启网络</h4><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">nmcli c reload</span><br></pre></td></tr></table></figure>
<h4 id="SSH连接问题-网络不可达-怀疑是VMware软件问题，配置SSH映射就好了"><a href="#SSH连接问题-网络不可达-怀疑是VMware软件问题，配置SSH映射就好了" class="headerlink" title="SSH连接问题 网络不可达(怀疑是VMware软件问题，配置SSH映射就好了)"></a>SSH连接问题 网络不可达(怀疑是VMware软件问题，配置SSH映射就好了)</h4><p>网络也能ping外网了，具体操作见<a href="https://blog.csdn.net/YiRan_Zhao/article/details/110121526">地址</a></p>
]]></content>
      <categories>
        <category>rockylinux8</category>
      </categories>
      <tags>
        <tag>rockylinux8-network-config</tag>
      </tags>
  </entry>
  <entry>
    <title>容器数据卷</title>
    <url>/2022/06/28/%E5%AE%B9%E5%99%A8%E6%95%B0%E6%8D%AE%E5%8D%B7/</url>
    <content><![CDATA[<h2 id="Docker容器数据卷"><a href="#Docker容器数据卷" class="headerlink" title="Docker容器数据卷"></a>Docker容器数据卷</h2><p>原理：将容器目录挂载到Linux的目录</p>
<p><strong>容器的持久化和同步操作 ！容器间也是可以数据共享的</strong></p>
<h2 id="使用数据卷"><a href="#使用数据卷" class="headerlink" title="使用数据卷"></a>使用数据卷</h2><blockquote>
<p>方式一：直接使用命令来挂载 -v</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run -it -v 主机目录：容器内目录</span><br></pre></td></tr></table></figure>

<h5 id="安装MySQL"><a href="#安装MySQL" class="headerlink" title="安装MySQL"></a>安装MySQL</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 获取镜像 </span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker pull mysql:5.7</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 不挂载数据</span></span><br><span class="line"><span class="comment">## 查看主机是否有msql服务</span></span><br><span class="line">[root@localhost home]<span class="comment"># ps -ef |grep mysql</span></span><br><span class="line">root       13049   12627  0 14:40 pts/5    00:00:00 grep --color=auto mysql</span><br><span class="line"><span class="comment">## 启动mysql容器</span></span><br><span class="line">[root@localhost home]<span class="comment"># docker run -p 3306:3306 -e MYSQL_ROOT_PASSWORD=123456 -d mysql:5.7</span></span><br><span class="line">95a10c860fd5ab401b7d29f728addff9b99f1f2a6b28286d78d9d78958843a6b</span><br><span class="line"><span class="comment">## 查看msql容器是否运行</span></span><br><span class="line">[root@localhost home]<span class="comment"># docker ps</span></span><br><span class="line">CONTAINER ID   IMAGE       COMMAND                  CREATED         STATUS         PORTS                                                  NAMES</span><br><span class="line">95a10c860fd5   mysql:5.7   <span class="string">&quot;docker-entrypoint.s…&quot;</span>   6 seconds ago   Up 5 seconds   0.0.0.0:3306-&gt;3306/tcp, :::3306-&gt;3306/tcp, 33060/tcp   kind_shannon</span><br><span class="line"><span class="comment">## 进入mysql容器内</span></span><br><span class="line">[root@localhost home]<span class="comment"># docker exec -it 95a10c860fd5 /bin/bash</span></span><br><span class="line"><span class="comment">## 登录mysql</span></span><br><span class="line">root@95a10c860fd5:/<span class="comment"># mysql -u root -p</span></span><br><span class="line">Enter password: </span><br><span class="line">Welcome to the MySQL monitor.  Commands end with ; or \g.</span><br><span class="line">Your MySQL connection <span class="built_in">id</span> is 2</span><br><span class="line">Server version: 5.7.36 MySQL Community Server (GPL)</span><br><span class="line"></span><br><span class="line">Copyright (c) 2000, 2021, Oracle and/or its affiliates.</span><br><span class="line"></span><br><span class="line">Oracle is a registered trademark of Oracle Corporation and/or its</span><br><span class="line">affiliates. Other names may be trademarks of their respective</span><br><span class="line">owners.</span><br><span class="line"></span><br><span class="line">Type <span class="string">&#x27;help;&#x27;</span> or <span class="string">&#x27;\h&#x27;</span> <span class="keyword">for</span> <span class="built_in">help</span>. Type <span class="string">&#x27;\c&#x27;</span> to clear the current input statement.</span><br><span class="line"><span class="comment">## 查看数据库有哪些</span></span><br><span class="line">mysql&gt; show databases;</span><br><span class="line">+--------------------+</span><br><span class="line">| Database           |</span><br><span class="line">+--------------------+</span><br><span class="line">| information_schema |</span><br><span class="line">| mysql              |</span><br><span class="line">| performance_schema |</span><br><span class="line">| sys                |</span><br><span class="line">+--------------------+</span><br><span class="line">4 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment">## 创建数据库</span></span><br><span class="line">mysql&gt; create database db01;</span><br><span class="line">Query OK, 1 row affected (0.00 sec)</span><br><span class="line"><span class="comment">## 使用数据库</span></span><br><span class="line">mysql&gt; use db01</span><br><span class="line">Database changed</span><br><span class="line"><span class="comment">## 创建表student</span></span><br><span class="line">mysql&gt; create table student(<span class="built_in">id</span> int,name varchar(20));</span><br><span class="line">Query OK, 0 rows affected (0.01 sec)</span><br><span class="line"><span class="comment">## 向student表插入数据</span></span><br><span class="line">mysql&gt; insert into student values(1,<span class="string">&#x27;z3&#x27;</span>);</span><br><span class="line">Query OK, 1 row affected (0.04 sec)</span><br><span class="line"><span class="comment">## 查询student表所有数据</span></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * from student ;</span><br><span class="line">+------+------+</span><br><span class="line">| <span class="built_in">id</span>   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | z3   |</span><br><span class="line">+------+------+</span><br><span class="line">1 row <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"></span><br><span class="line">mysql&gt; <span class="keyword">select</span> * from student;</span><br><span class="line">+------+------+</span><br><span class="line">| <span class="built_in">id</span>   | name |</span><br><span class="line">+------+------+</span><br><span class="line">|    1 | z3   |</span><br><span class="line">|    2 | lisi |</span><br><span class="line">+------+------+</span><br><span class="line">2 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.00 sec)</span><br><span class="line"><span class="comment">## 查看数据库默认字符集为latin1</span></span><br><span class="line">mysql&gt; show variables like <span class="string">&#x27;character%&#x27;</span> ;</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| Variable_name            | Value                      |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">| character_set_client     | latin1                     |</span><br><span class="line">| character_set_connection | latin1                     |</span><br><span class="line">| character_set_database   | latin1                     |</span><br><span class="line">| character_set_filesystem | binary                     |</span><br><span class="line">| character_set_results    | latin1                     |</span><br><span class="line">| character_set_server     | latin1                     |</span><br><span class="line">| character_set_system     | utf8                       |</span><br><span class="line">| character_sets_dir       | /usr/share/mysql/charsets/ |</span><br><span class="line">+--------------------------+----------------------------+</span><br><span class="line">8 rows <span class="keyword">in</span> <span class="built_in">set</span> (0.01 sec)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 运行容器 需要做数据挂载！</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 3306:3306 \</span></span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /home/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /home/mysql/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql01 mysql:5.7</span><br><span class="line"><span class="comment">#修改字符集</span></span><br><span class="line"><span class="comment"># 创建my.conf并填入以下内容</span></span><br><span class="line">vi /home/mysql/conf/my.cnf</span><br><span class="line"><span class="comment"># 方法一</span></span><br><span class="line">  [client]</span><br><span class="line">	default_character_set=utf8</span><br><span class="line">  [mysqld]</span><br><span class="line">	collation_server = utf8_general_ci</span><br><span class="line">	character_set_server = uft8</span><br><span class="line"><span class="comment"># 方法二	</span></span><br><span class="line">	[mysql]</span><br><span class="line">	  default-character-set=utf8mb4</span><br><span class="line">	[mysqld]</span><br><span class="line">	  character_set_server = utf8</span><br><span class="line">	  init_connect=<span class="string">&#x27;SET NAMES utf8&#x27;</span></span><br><span class="line">	  lower_case_table_names=1</span><br><span class="line"><span class="comment"># 方法三</span></span><br><span class="line">[root@localhost ~]<span class="comment"># docker run -d -p 3306:3306 \</span></span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /home/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /home/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /home/mysql/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql01 mysql:5.7 \</span><br><span class="line">--character-set-server=utf8mb4 \</span><br><span class="line">--collation-server=utf8mb4_unicode_ci</span><br><span class="line"><span class="comment">##</span></span><br><span class="line">新项目只考虑utf8mb4</span><br><span class="line">　　UTF-8 编码是一种变长的编码机制，可以用1~4个字节存储字符。</span><br><span class="line"></span><br><span class="line">　　因为历史遗留问题，MySQL 中的 utf8 编码并不是真正的 UTF-8，而是阉割版的，最长只有3个字节。当遇到占4个字节的 UTF-8 编码，例如 emoji 字符或者复杂的汉字，也就是我们通常在聊天时发的小黄脸表情，会导致存储异常。</span><br><span class="line"></span><br><span class="line">　　从 5.5.3 开始，MySQL 开始用 utf8mb4 编码来实现完整的 UTF-8，其中 mb4 表示 most bytes 4，最多占用4个字节，用来兼容四个字节的Unicode（万国码）。utf8mb4是utf8的一个扩展。从 8.0 之后，将会在某个版本开始用 utf8mb4 作为默认字符编码。</span><br><span class="line"><span class="comment"># 重启mysql02</span></span><br><span class="line">docker restart mysql02</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2 id="具名与匿名挂载"><a href="#具名与匿名挂载" class="headerlink" title="具名与匿名挂载"></a>具名与匿名挂载</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看卷的命令</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">[root@localhost home]<span class="comment"># docker volume --help</span></span></span><br><span class="line"></span><br><span class="line">Usage:  docker volume COMMAND</span><br><span class="line"></span><br><span class="line">Manage volumes</span><br><span class="line"></span><br><span class="line">Commands:</span><br><span class="line">  create      Create a volume</span><br><span class="line">  inspect     Display detailed information on one or more volumes</span><br><span class="line">  ls          List volumes</span><br><span class="line">  prune       Remove all unused local volumes</span><br><span class="line">  rm          Remove one or more volumes</span><br><span class="line"></span><br><span class="line">-v 容器内路径！</span><br><span class="line">docker run -d -P</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">匿名挂载</span></span><br><span class="line">[root@localhost home]# docker run -d -P --name nginx01 -v /etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">具名挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">-v 卷名：容器内路径</span></span><br><span class="line">[root@localhost home]# docker run -d -P --name nginx02 -v my-nginx:/etc/nginx nginx</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看挂载路径</span></span><br><span class="line">[root@localhost home]# docker volume inspect my-nginx</span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;CreatedAt&quot;: &quot;2022-06-28T22:46:09-04:00&quot;,</span><br><span class="line">        &quot;Driver&quot;: &quot;local&quot;,</span><br><span class="line">        &quot;Labels&quot;: null,</span><br><span class="line">        &quot;Mountpoint&quot;: &quot;/var/lib/docker/volumes/my-nginx/_data&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;my-nginx&quot;,</span><br><span class="line">        &quot;Options&quot;: null,</span><br><span class="line">        &quot;Scope&quot;: &quot;local&quot;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">所有的docker容器内的卷，没有自定义目录的情况下都是在/var/lib/docker/volumes/xxx/_data</span></span><br></pre></td></tr></table></figure>

<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">如何确定是具名挂载还是匿名挂载，还是指定路径挂载！</span></span><br><span class="line">-v 容器内路径   # 匿名挂载</span><br><span class="line">-v 卷名：容器内路径 # 具名挂载</span><br><span class="line">-v /宿主机路径:/容器内路径 # 指定路径挂载</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">通过 -v 容器内路径:ro rw 改变读写权限</span></span><br><span class="line">ro readonly #只读</span><br><span class="line">rw readwrite #读写</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">一旦这个设置容器权限，容器对我们挂载出来的内容就有先限定了！</span></span><br><span class="line"> docker run -d -P --name nginx02 -v my-nginx:/etc/nginx:ro nginx</span><br><span class="line"> docker run -d -P --name nginx02 -v my-nginx:/etc/nginx:rw nginx</span><br></pre></td></tr></table></figure>

<h2 id="初识Dockerfile"><a href="#初识Dockerfile" class="headerlink" title="初识Dockerfile"></a>初识Dockerfile</h2><p>Dockerfile 就是用来构建 docker 镜像的构建文件 ！ 命令脚本！</p>
<p>通过这个脚本可以生成镜像，镜像是一层一层的，脚本一个个的命令，每个命令都是一层！</p>
<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 编写dockerfile脚本</span></span><br><span class="line">[root@localhost docker-test-<span class="keyword">volume</span><span class="language-bash">]<span class="comment"># vi dockerfile1</span></span></span><br><span class="line">[root@localhost docker-test-<span class="keyword">volume</span><span class="language-bash">]<span class="comment"># cat dockerfile1 </span></span></span><br><span class="line">FORM centos</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"> [<span class="string">&quot;volume01&quot;</span>,<span class="string">&quot;volume02&quot;</span>]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> <span class="built_in">echo</span> <span class="string">&quot;------end------&quot;</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"> /bin/bash</span></span><br><span class="line"><span class="comment"># 构建镜像</span></span><br><span class="line">[root@localhost docker-test-<span class="keyword">volume</span><span class="language-bash">]<span class="comment"># docker build -f dockerfile1 -t shawn/centos:1.0 .</span></span></span><br><span class="line">-f 指定dockerfile文件</span><br><span class="line">-t 指定镜像名以及版本</span><br><span class="line">. 在当前目录生成</span><br><span class="line"></span><br><span class="line"><span class="comment"># 数据卷同步</span></span><br><span class="line">docker <span class="keyword">run</span><span class="language-bash"> -it --name docker03 --volumes-from docker01 shawn/centos:1.0(镜像启动)</span></span><br></pre></td></tr></table></figure>

<p>结论：</p>
<p>容器之间配置信息的传递，数据卷容器的生命周期一直持续到没有容器使用为止。</p>
<p>但是一旦你持久化到了本地，这个时候，本地的数据是不会删除的</p>
<h2 id="DockerFile构建过程"><a href="#DockerFile构建过程" class="headerlink" title="DockerFile构建过程"></a>DockerFile构建过程</h2><h5 id="基础知识"><a href="#基础知识" class="headerlink" title="基础知识"></a>基础知识</h5><p>1、每个保留关键字（指令）都是必须是大写字母</p>
<p>2、执行从上到下顺序执行</p>
<p>3、#表示注释</p>
<p>4、每个指令都会创建提交一个新的镜像层，并提交！</p>
<figure class="highlight stylus"><table><tr><td class="code"><pre><span class="line">可写容器（container）</span><br><span class="line">镜像（tomcat）</span><br><span class="line">镜像（jdk）</span><br><span class="line"><span class="function"><span class="title">rootfs</span><span class="params">(基础镜像 centos/ubuntu)</span></span></span><br><span class="line">bootfs</span><br></pre></td></tr></table></figure>

<p>dockerfile是面向开发的，我们以后要发布项目，做镜像，就需要编写dockerfile文件，这个文件十分简单！</p>
<p>Docker镜像逐渐成为企业交付的标准，必须要掌握 ！</p>
<p>步骤：开发 部署 运维 缺一不可 ！</p>
<p>DockerFile：构建文件，定义了一切的步骤，源代码</p>
<p>DockerImages：通过DockerFile构建生成镜像，最终发布与运行的产品</p>
<p>Docker容器：容器就是镜像运行起来提供服务的</p>
<h2 id="Dockerfile指令"><a href="#Dockerfile指令" class="headerlink" title="Dockerfile指令"></a>Dockerfile指令</h2><figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span>       <span class="comment"># 基础镜像，一切从这里开始构建</span></span><br><span class="line"><span class="keyword">MAINTAINER</span> <span class="comment"># 镜像是谁写的，姓名+邮箱</span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">        <span class="comment"># 镜像构建的时候需要运行的命令</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash">        <span class="comment"># 步骤：tomcat镜像，这个tomcat压缩包！添加内容</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash">    <span class="comment"># 镜像的工作目录</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash">     <span class="comment"># 挂载的目录</span></span></span><br><span class="line"><span class="keyword">EXPOSE</span>     <span class="comment"># 保留端口配置</span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash">        <span class="comment"># 指定容器启动的时候要运行的命令，只有最后一个会生效，可被替代</span></span></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"> <span class="comment"># 指定容器启动的时候要运行的命令，可以追加命令</span></span></span><br><span class="line"><span class="keyword">ONBUILD</span>    <span class="comment"># 当构建一个被继承DockerFile 这个时候就会运行 ONBUILD 的指令。触发指令。</span></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash">       <span class="comment"># 类似ADD，将我们文件拷贝到镜像中</span></span></span><br><span class="line"><span class="keyword">ENV</span>        <span class="comment"># 构建的时候设置环境变量！</span></span><br></pre></td></tr></table></figure>



<figure class="highlight dockerfile"><table><tr><td class="code"><pre><span class="line"><span class="keyword">FROM</span></span><br><span class="line"></span><br><span class="line">功能为指定基础镜像，并且必须是第一条指令。</span><br><span class="line"></span><br><span class="line">如果不以任何镜像为基础，那么写法为：<span class="keyword">FROM</span> scratch。</span><br><span class="line"></span><br><span class="line">同时意味着接下来所写的指令将作为镜像的第一层开始</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;tag&gt;</span><br><span class="line"><span class="keyword">FROM</span> &lt;image&gt;:&lt;digest&gt; </span><br><span class="line">三种写法，其中&lt;tag&gt;和&lt;digest&gt; 是可选项，如果没有选择，那么默认值为latest</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"></span></span><br><span class="line"><span class="language-bash"></span></span><br><span class="line"> 功能为运行指定的命令</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash">命令有两种格式</span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">RUN</span><span class="language-bash"> &lt;<span class="built_in">command</span>&gt;</span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">RUN</span><span class="language-bash"> [<span class="string">&quot;executable&quot;</span>, <span class="string">&quot;param1&quot;</span>, <span class="string">&quot;param2&quot;</span>]</span></span><br><span class="line">第一种后边直接跟<span class="keyword">shell</span><span class="language-bash">命令</span></span><br><span class="line"></span><br><span class="line">在linux操作系统上默认 /bin/sh -c</span><br><span class="line"></span><br><span class="line">在windows操作系统上默认 <span class="keyword">cmd</span><span class="language-bash"> /S /C</span></span><br><span class="line"></span><br><span class="line">第二种是类似于函数调用。</span><br><span class="line"></span><br><span class="line">可将executable理解成为可执行文件，后面就是两个参数。</span><br><span class="line"></span><br><span class="line">两种写法比对：</span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"> /bin/bash -c <span class="string">&#x27;source $HOME/.bashrc; echo $HOME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> [&quot;/bin/bash&quot;, &quot;-c&quot;, &quot;echo hello&quot;]</span></span></span><br><span class="line">注意：多行命令不要写多个<span class="keyword">RUN</span><span class="language-bash"><span class="string">，原因是Dockerfile中每一个指令都会建立一层.</span></span></span><br><span class="line"></span><br><span class="line"> 多少个<span class="keyword">RUN</span><span class="language-bash"><span class="string">就构建了多少层镜像，会造成镜像的臃肿、多层，不仅仅增加了构件部署的时间，还容易出错。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string">书写时的换行符是\</span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">功能为容器启动时要运行的命令</span><br><span class="line"></span><br><span class="line">语法有三种写法</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">CMD</span><span class="language-bash"><span class="string"> [&quot;executable&quot;,&quot;param1&quot;,&quot;param2&quot;]</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">CMD</span><span class="language-bash"><span class="string"> [&quot;param1&quot;,&quot;param2&quot;]</span></span></span><br><span class="line"><span class="number">3</span>. <span class="keyword">CMD</span><span class="language-bash"><span class="string"> command param1 param2</span></span></span><br><span class="line">第三种比较好理解了，就时<span class="keyword">shell</span><span class="language-bash"><span class="string">这种执行方式和写法</span></span></span><br><span class="line"></span><br><span class="line">第一种和第二种其实都是可执行文件加上参数的形式</span><br><span class="line"></span><br><span class="line">举例说明两种写法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> [ &quot;sh&quot;, &quot;-c&quot;, &quot;echo $HOME&quot; </span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> [ &quot;echo&quot;, &quot;$HOME&quot; ]</span></span></span><br><span class="line">补充细节：这里边包括参数的一定要用双引号，就是<span class="string">&quot;,不能是单引号。千万不能写成单引号。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">原因是参数传递后，docker解析的是一个JSON array</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN &amp; CMD</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">不要把RUN和CMD搞混了。</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">RUN是构件容器时就运行的命令以及提交运行结果</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">CMD是容器启动时执行的命令，在构件时并不运行，构件时紧紧指定了这个命令到底是个什么样子</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LABEL</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">功能是为镜像指定标签</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">语法：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LABEL &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; &lt;key&gt;=&lt;value&gt; ...</span></span><br><span class="line"><span class="string"> 一个Dockerfile种可以有多个LABEL，如下：</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">LABEL &quot;</span>com.example.vendor<span class="string">&quot;=&quot;</span>ACME Incorporated<span class="string">&quot;</span></span><br><span class="line"><span class="string">LABEL com.example.label-with-value=&quot;</span>foo<span class="string">&quot;</span></span><br><span class="line"><span class="string">LABEL version=&quot;</span><span class="number">1.0</span><span class="string">&quot;</span></span><br><span class="line"><span class="string">LABEL description=&quot;</span>This text illustrates \</span><br><span class="line">that <span class="keyword">label</span><span class="language-bash"><span class="string">-values can span multiple lines.&quot;</span></span></span><br><span class="line"> 但是并不建议这样写，最好就写成一行，如太长需要换行的话则使用\符号</span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">LABEL</span><span class="language-bash"><span class="string"> multi.label1=&quot;value1&quot; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">multi.label2=&quot;value2&quot; \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">other=&quot;value3&quot;</span></span></span><br><span class="line">说明：<span class="keyword">LABEL</span><span class="language-bash"><span class="string">会继承基础镜像种的LABEL，如遇到key相同，则值覆盖</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span></span><br><span class="line"></span><br><span class="line">指定作者</span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">MAINTAINER</span> &lt;name&gt;</span><br><span class="line"><span class="keyword">EXPOSE</span></span><br><span class="line"></span><br><span class="line">功能为暴漏容器运行时的监听端口给外部</span><br><span class="line"></span><br><span class="line">但是<span class="keyword">EXPOSE</span>并不会使容器访问主机的端口</span><br><span class="line"></span><br><span class="line">如果想使得容器与主机的端口有映射关系，必须在容器启动的时候加上 -P参数</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span></span><br><span class="line"></span><br><span class="line">功能为设置环境变量</span><br><span class="line"></span><br><span class="line">语法有两种</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">ENV</span> &lt;key&gt; &lt;value&gt;</span><br><span class="line"><span class="number">2</span>. <span class="keyword">ENV</span> &lt;key&gt;=&lt;value&gt; ...</span><br><span class="line">两者的区别就是第一种是一次设置一个，第二种是一次设置多个</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line"> 一个复制命令，把文件复制到景象中。</span><br><span class="line"></span><br><span class="line">如果把虚拟机与容器想象成两台linux服务器的话，那么这个命令就类似于scp，只是scp需要加用户名和密码的权限验证，而<span class="keyword">ADD</span><span class="language-bash"><span class="string">不用。</span></span></span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">ADD</span><span class="language-bash"><span class="string"> &lt;src&gt;... &lt;dest&gt;</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">ADD</span><span class="language-bash"><span class="string"> [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></span><br><span class="line">&lt;dest&gt;路径的填写可以是容器内的绝对路径，也可以是相对于工作目录的相对路径</span><br><span class="line"></span><br><span class="line">&lt;src&gt;可以是一个本地文件或者是一个本地压缩文件，还可以是一个url</span><br><span class="line"></span><br><span class="line">如果把&lt;src&gt;写成一个url，那么<span class="keyword">ADD</span><span class="language-bash"><span class="string">就类似于wget命令</span></span></span><br><span class="line"></span><br><span class="line">如以下写法都是可以的：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"> test relativeDir/ </span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"> test /relativeDir</span></span></span><br><span class="line"><span class="keyword">ADD</span><span class="language-bash"><span class="string"> http://example.com/foobar /</span></span></span><br><span class="line">尽量不要把&lt;scr&gt;写成一个文件夹，如果&lt;src&gt;是一个文件夹了，复制整个目录的内容,包括文件系统元数据</span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">看这个名字就知道，又是一个复制命令</span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">COPY</span><span class="language-bash"><span class="string"> &lt;src&gt;... &lt;dest&gt;</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">COPY</span><span class="language-bash"><span class="string"> [&quot;&lt;src&gt;&quot;,... &quot;&lt;dest&gt;&quot;]</span></span></span><br><span class="line">与<span class="keyword">ADD</span><span class="language-bash"><span class="string">的区别</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">COPY</span><span class="language-bash"><span class="string">的&lt;src&gt;只能是本地文件，其他用法一致</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">功能是启动时的默认命令</span><br><span class="line"></span><br><span class="line">语法如下：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> [&quot;executable&quot;, &quot;param1&quot;, &quot;param2&quot;]</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> command param1 param2</span></span></span><br><span class="line">如果从上到下看到这里的话，那么你应该对这两种语法很熟悉啦。</span><br><span class="line"></span><br><span class="line">第二种就是写<span class="keyword">shell</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">第一种就是可执行文件加参数</span><br><span class="line"></span><br><span class="line">与<span class="keyword">CMD</span><span class="language-bash"><span class="string">比较说明（这俩命令太像了，而且还可以配合使用）：</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. 相同点：</span><br><span class="line"></span><br><span class="line">只能写一条，如果写了多条，那么只有最后一条生效</span><br><span class="line"></span><br><span class="line">容器启动时才运行，运行时机相同</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>. 不同点：</span><br><span class="line"></span><br><span class="line"> <span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string">不会被运行的command覆盖，而CMD则会被覆盖</span></span></span><br><span class="line"></span><br><span class="line"> 如果我们在Dockerfile种同时写了<span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string">和CMD，并且CMD指令不是一个完整的可执行命令，那么CMD指定的内容将会作为ENTRYPOINT的参数</span></span></span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> [&quot;top&quot;, &quot;-b&quot;]</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> [&quot;-c&quot;]</span></span></span><br><span class="line">如果我们在Dockerfile种同时写了<span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string">和CMD，并且CMD是一个完整的指令，那么它们两个会互相覆盖，谁在最后谁生效</span></span></span><br><span class="line"></span><br><span class="line">如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> ubuntu</span><br><span class="line"><span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> [&quot;top&quot;, &quot;-b&quot;]</span></span></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string"> ls -al</span></span></span><br><span class="line">那么将执行ls -al ,top -b不会执行。</span><br><span class="line"></span><br><span class="line">Docker官方使用一张表格来展示了<span class="keyword">ENTRYPOINT</span><span class="language-bash"><span class="string"> 和CMD不同组合的执行情况</span></span></span><br><span class="line"></span><br><span class="line">（下方表格来自docker官网）</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">可实现挂载功能，可以将内地文件夹或者其他容器种得文件夹挂在到这个容器种</span><br><span class="line"></span><br><span class="line">语法为：</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> [&quot;/data&quot;]</span></span></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">说明：</span><br><span class="line"></span><br><span class="line">   [<span class="string">&quot;/data&quot;</span>]可以是一个JsonArray ，也可以是多个值。所以如下几种写法都是正确的</span><br><span class="line"></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> [&quot;/var/log/&quot;]</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> /var/log</span></span></span><br><span class="line"><span class="keyword">VOLUME</span><span class="language-bash"><span class="string"> /var/log /var/db</span></span></span><br><span class="line">一般的使用场景为需要持久化存储数据时</span><br><span class="line"></span><br><span class="line">容器使用的是AUFS，这种文件系统不能持久化数据，当容器关闭后，所有的更改都会丢失。</span><br><span class="line"></span><br><span class="line">所以当数据需要持久化时用这个命令。</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span></span><br><span class="line"></span><br><span class="line">设置启动容器的用户，可以是用户名或UID，所以，只有下面的两种写法是正确的</span><br><span class="line"></span><br><span class="line"><span class="keyword">USER</span> daemo</span><br><span class="line"><span class="keyword">USER</span> UID</span><br><span class="line">注意：如果设置了容器以daemon用户去运行，那么<span class="keyword">RUN</span><span class="language-bash"><span class="string">, CMD 和 ENTRYPOINT 都会以这个用户去运行</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> /path/to/workdir</span></span></span><br><span class="line">设置工作目录，对<span class="keyword">RUN</span><span class="language-bash"><span class="string">,CMD,ENTRYPOINT,COPY,ADD生效。如果不存在则会创建，也可以设置多次。</span></span></span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> /a</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> b</span></span></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> c</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> pwd</span></span></span><br><span class="line">pwd执行的结果是/a/b/c</span><br><span class="line"></span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string">也可以解析环境变量</span></span></span><br><span class="line"></span><br><span class="line">如：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ENV</span> DIRPATH /path</span><br><span class="line"><span class="keyword">WORKDIR</span><span class="language-bash"><span class="string"> $DIRPATH/$DIRNAME</span></span></span><br><span class="line"><span class="keyword">RUN</span><span class="language-bash"><span class="string"> pwd</span></span></span><br><span class="line">pwd的执行结果是/path/$DIRNAME</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ARG</span> &lt;name&gt;[=&lt;default value&gt;]</span><br><span class="line">设置变量命令，<span class="keyword">ARG</span>命令定义了一个变量，在docker build创建镜像的时候，使用 --build-<span class="keyword">arg</span> &lt;varname&gt;=&lt;value&gt;来指定参数</span><br><span class="line"></span><br><span class="line">如果用户在build镜像时指定了一个参数没有定义在Dockerfile种，那么将有一个Warning</span><br><span class="line"></span><br><span class="line">提示如下：</span><br><span class="line"></span><br><span class="line">[Warning] One or more build-args [foo] were not consumed.</span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">我们可以定义一个或多个参数，如下：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1</span><br><span class="line"><span class="keyword">ARG</span> buildno</span><br><span class="line">...</span><br><span class="line">也可以给参数一个默认值：</span><br><span class="line"></span><br><span class="line"><span class="keyword">FROM</span> busybox</span><br><span class="line"><span class="keyword">ARG</span> user1=someuser</span><br><span class="line"><span class="keyword">ARG</span> buildno=<span class="number">1</span></span><br><span class="line">...</span><br><span class="line">如果我们给了<span class="keyword">ARG</span>定义的参数默认值，那么当build镜像时没有指定参数值，将会使用这个默认值</span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span> [INSTRUCTION]</span><br><span class="line">这个命令只对当前镜像的子镜像生效。</span><br><span class="line"></span><br><span class="line">比如当前镜像为A，在Dockerfile种添加：</span><br><span class="line"></span><br><span class="line"><span class="keyword">ONBUILD</span> <span class="keyword">RUN</span><span class="language-bash"><span class="string"> ls -al</span></span></span><br><span class="line">这个 ls -al 命令不会在A镜像构建或启动的时候执行</span><br><span class="line"></span><br><span class="line">此时有一个镜像B是基于A镜像构建的，那么这个ls -al 命令会在B镜像构建的时候被执行。</span><br><span class="line"></span><br><span class="line"><span class="keyword">STOPSIGNAL</span></span><br><span class="line"></span><br><span class="line">语法：</span><br><span class="line"></span><br><span class="line"><span class="keyword">STOPSIGNAL</span> signal</span><br><span class="line"><span class="keyword">STOPSIGNAL</span>命令是的作用是当容器推出时给系统发送什么样的指令</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"></span></span></span><br><span class="line"><span class="string"><span class="language-bash"></span></span></span><br><span class="line"> 容器健康状况检查命令</span><br><span class="line"></span><br><span class="line">语法有两种：</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>. <span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"> [OPTIONS] CMD command</span></span></span><br><span class="line"><span class="number">2</span>. <span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"> NONE</span></span></span><br><span class="line">第一个的功能是在容器内部运行一个命令来检查容器的健康状况</span><br><span class="line"></span><br><span class="line">第二个的功能是在基础镜像中取消健康检查命令</span><br><span class="line"></span><br><span class="line">[OPTIONS]的选项支持以下三中选项：</span><br><span class="line"></span><br><span class="line">    --interval=DURATION 两次检查默认的时间间隔为<span class="number">30</span>秒</span><br><span class="line"></span><br><span class="line">    --timeout=DURATION 健康检查命令运行超时时长，默认<span class="number">30</span>秒</span><br><span class="line"></span><br><span class="line">    --retries=N 当连续失败指定次数后，则容器被认为是不健康的，状态为unhealthy，默认次数是<span class="number">3</span></span><br><span class="line"></span><br><span class="line">    </span><br><span class="line"></span><br><span class="line">注意：</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string">命令只能出现一次，如果出现了多次，只有最后一个生效。</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">CMD</span><span class="language-bash"><span class="string">后边的命令的返回值决定了本次健康检查是否成功，具体的返回值如下：</span></span></span><br><span class="line"></span><br><span class="line"><span class="number">0</span>: success - 表示容器是健康的</span><br><span class="line"></span><br><span class="line"><span class="number">1</span>: unhealthy - 表示容器已经不能工作了</span><br><span class="line"></span><br><span class="line"><span class="number">2</span>: reserved - 保留值</span><br><span class="line"></span><br><span class="line">例子：</span><br><span class="line"></span><br><span class="line"><span class="keyword">HEALTHCHECK</span><span class="language-bash"><span class="string"> --interval=5m --timeout=3s \</span></span></span><br><span class="line"><span class="string"><span class="language-bash">CMD curl -f http://localhost/ || exit 1</span></span></span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">健康检查命令是：curl -f http://localhost/ || exit <span class="number">1</span></span><br></pre></td></tr></table></figure>



]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker容器数据卷</tag>
      </tags>
  </entry>
  <entry>
    <title>搜索引擎高级搜索技巧</title>
    <url>/2022/06/03/%E6%90%9C%E7%B4%A2%E5%BC%95%E6%93%8E%E9%AB%98%E7%BA%A7%E6%90%9C%E7%B4%A2%E6%8A%80%E5%B7%A7/</url>
    <content><![CDATA[<h5 id="逻辑与-或"><a href="#逻辑与-或" class="headerlink" title="逻辑与&#x2F;或"></a><em><strong>逻辑与&#x2F;或</strong></em></h5><hr>
<ul>
<li>注意AND、OR必须大写，否则会被认为是普通的单词，而不是搜索指令</li>
<li>与普通编程语言不一样的是，OR指令优先于AND指令</li>
<li>简写：AND指令一般以空格代替，不明确写出。另外AND指令还可以用+代替。OR指令可用|代替</li>
</ul>
<h5 id="逻辑非："><a href="#逻辑非：" class="headerlink" title="逻辑非：-"></a><em><strong>逻辑非：-</strong></em></h5><hr>
<ul>
<li>样例：搜索引擎 历史 -文化 -中国历史 -世界历史</li>
</ul>
<h5 id="完整匹配-“-“"><a href="#完整匹配-“-“" class="headerlink" title="完整匹配 “ “"></a><em><strong>完整匹配 “ “</strong></em></h5><hr>
<ul>
<li>样例：”world war I” 表示搜索一次世界大战</li>
</ul>
<h5 id="通配符："><a href="#通配符：" class="headerlink" title="通配符：*?"></a><em><strong>通配符：*?</strong></em></h5><hr>
<ul>
<li>与我们通常的习惯一致，“*”代表一连串字符，“?”代表单个字符</li>
</ul>
<h5 id="site-在某个网站或域名下搜索"><a href="#site-在某个网站或域名下搜索" class="headerlink" title="site: 在某个网站或域名下搜索"></a><em><strong>site: 在某个网站或域名下搜索</strong></em></h5><hr>
<ul>
<li>样例：搜索引擎 技巧 site:edu.cn</li>
<li>这表示要在中文教育科研网站（edu.cn）上关于搜索引擎技巧的页面</li>
</ul>
<h5 id="filetype-搜索某种类型的文件"><a href="#filetype-搜索某种类型的文件" class="headerlink" title="filetype: 搜索某种类型的文件"></a><em><strong>filetype: 搜索某种类型的文件</strong></em></h5><hr>
<ul>
<li>样例：天文学 filetype:pdf </li>
<li>简写: 天文学:pdf</li>
<li>这表示只搜索pdf文件</li>
<li>tips：样例 天文学三个字位置任意写</li>
</ul>
<h5 id="in指令-位置关键词查找"><a href="#in指令-位置关键词查找" class="headerlink" title="in指令: 位置关键词查找"></a><em><strong>in指令: 位置关键词查找</strong></em></h5><hr>
<ul>
<li>intitle: 在网页标题中查找。这通常对讨论比较多的热门话题很有效。例如：intitle:”GeForce 7800”+测试</li>
<li>例如：allintitile:”GeForce 7800” 测试 与 intitle:”GeForce 7800”+测试 的含义一致。但是，allintitile是排他的，不能加上其他非intitle方面的限制条件</li>
<li>inurl: 在网页的url地址中查找。例如：inurl:dowload 表示查找url中包含download的网页</li>
<li>allinurl: inurl的排他指令</li>
<li>inanchor: 在网页的链接锚中查找</li>
</ul>
<h5 id="link-搜索所有链接到某个URL地址的网页"><a href="#link-搜索所有链接到某个URL地址的网页" class="headerlink" title="link: 搜索所有链接到某个URL地址的网页"></a><em><strong>link: 搜索所有链接到某个URL地址的网页</strong></em></h5><hr>
<ul>
<li>例如：link:<a href="http://www.newhua.com/">www.newhua.com</a> 表示所有指向“华军软件园”外部链接。</li>
</ul>
<h5 id="related-寻找某网页的“类似网页”"><a href="#related-寻找某网页的“类似网页”" class="headerlink" title="related: 寻找某网页的“类似网页”"></a><em><strong>related: 寻找某网页的“类似网页”</strong></em></h5><hr>
<ul>
<li>例如：related:<a href="http://www.newhua.com/">www.newhua.com</a> 表示找和“华军软件园”类似的网页。</li>
</ul>
<h5 id="cache-网页快照（略"><a href="#cache-网页快照（略" class="headerlink" title="cache: 网页快照（略)"></a><em><strong>cache: 网页快照（略)</strong></em></h5><hr>
<ul>
<li>查看网站的 Google 缓存版本，会直接显示缓存页面	</li>
<li>cache:weibo.com	查看微博的谷歌快照</li>
</ul>
<h5 id="daterange-查找特定时间网页"><a href="#daterange-查找特定时间网页" class="headerlink" title="daterange 查找特定时间网页"></a><em><strong>daterange 查找特定时间网页</strong></em></h5><hr>
<ul>
<li>例如：”Spice Girls“ daterange:2450958-2450968。这里时间日期的格式是按天文学的儒略日</li>
<li>儒略日数（Julian Day Number，JDN）的计算是从格林威治标准时间的中午开始，包含一个整天的时间，起点的时间（0日）回溯至儒略历的公元前4713年1月1日中午12点（在格里历是公元前4714年11月24日），这个日期是三种多年周期的共同起点，且是历史上最接近现代的一个起点。例如，2000年1月1日的UT12:00是儒略日2,451,545。</li>
<li>世界时UT即格林尼治平太阳时间，是指格林尼治所在地的标准时间，也是表示地球自转速率的一种形式。以地球自转为基础的时间计量系统。</li>
<li>格林尼治（Greenwich），是英国伦敦的一个区，位于伦敦东南、泰晤士河南岸</li>
</ul>
<h5 id="表示数值范围"><a href="#表示数值范围" class="headerlink" title=".. 表示数值范围"></a><em><strong>.. 表示数值范围</strong></em></h5><hr>
<ul>
<li>例如：数码相机 600..900 万像素 3000..4000 元</li>
<li>注意：“900”与“万”之间必须有空格。</li>
</ul>
<h5 id=""><a href="#" class="headerlink" title="@"></a><em><strong>@</strong></em></h5><hr>
<ul>
<li>在用于搜索社交媒体的字词前加上@	trump @twitter	搜索trump的twitter</li>
</ul>
<h5 id="-1"><a href="#-1" class="headerlink" title="$"></a><em><strong>$</strong></em></h5><hr>
<ul>
<li>在数字前加上$搜索特定价格	camera $400	搜索400$的camera</li>
</ul>
<h5 id="-2"><a href="#-2" class="headerlink" title="#"></a><em><strong>#</strong></em></h5><hr>
<ul>
<li>搜索 # 标签	#throwbackthursday	</li>
<li>搜索标签throwbackthursday</li>
</ul>
<h5 id="info"><a href="#info" class="headerlink" title="info"></a><em><strong>info</strong></em></h5><hr>
<ul>
<li>在网址前加info:，获取网站详情	info:github.com	搜索github网站详情</li>
</ul>
<h5 id="intext"><a href="#intext" class="headerlink" title="intext"></a><em><strong>intext</strong></em></h5><hr>
<ul>
<li>搜索查询词出现在页面正文(title)中的页面，支持中文和英文	SEO intext:搜索引擎	在正文包含【搜索引擎】的网页中搜索【SEO】</li>
</ul>
<h5 id="allintext"><a href="#allintext" class="headerlink" title="allintext"></a><em><strong>allintext</strong></em></h5><hr>
<ul>
<li>即all+inanchor 页面正文包含多个关键词的页面	allintext:SEO 搜索引擎优化	相当于：intext:SEO intext:搜索引擎优化</li>
</ul>
<h5 id="inanchor"><a href="#inanchor" class="headerlink" title="inanchor"></a><em><strong>inanchor</strong></em></h5><hr>
<ul>
<li>搜索链接锚文字(即链接显示的文字)中包含搜索词的页面	inanchor:前端	搜索链接锚文字中包含【前端】的页面</li>
</ul>
<h5 id="allinanchor"><a href="#allinanchor" class="headerlink" title="allinanchor"></a><em><strong>allinanchor</strong></em></h5><hr>
<ul>
<li><pre><code>即all+inanchor 页面链接锚文字包含多个关键词的页面	allinanchor:SEO 搜索引擎优化	相当于：inanchor:SEO inanchor:搜索引擎优化
</code></pre>
</li>
</ul>
<h5 id="weather"><a href="#weather" class="headerlink" title="weather"></a><em><strong>weather</strong></em></h5><hr>
<ul>
<li>weather&#x2F;time&#x2F;sunrise&#x2F;sundown+城市名，返回城市的天气&#x2F;时间&#x2F;日出时间&#x2F;日落时间</li>
<li>weather:beijing	显示北京的天气</li>
</ul>
<h5 id="music"><a href="#music" class="headerlink" title="music"></a><em><strong>music</strong></em></h5><hr>
<ul>
<li>music或者用songs，歌手名字+music&#x2F;songs	周杰伦 music	返回周杰伦的各首歌曲</li>
</ul>
]]></content>
      <categories>
        <category>搜索</category>
      </categories>
      <tags>
        <tag>搜索引擎</tag>
      </tags>
  </entry>
  <entry>
    <title>加密</title>
    <url>/2022/09/16/%E5%8A%A0%E5%AF%86/</url>
    <content><![CDATA[<h1 id="MD5是32位的，也就是说理论上是有限的，而世界上的数据是无限的，那会不会生成重复的MD5值"><a href="#MD5是32位的，也就是说理论上是有限的，而世界上的数据是无限的，那会不会生成重复的MD5值" class="headerlink" title="MD5是32位的，也就是说理论上是有限的，而世界上的数据是无限的，那会不会生成重复的MD5值?"></a><a href="https://www.zhihu.com/question/365544497/answer/2251328732">MD5是32位的，也就是说理论上是有限的，而世界上的数据是无限的，那会不会生成重复的MD5值?</a></h1><h1 id="为什么说-MD5-是不可逆的？"><a href="#为什么说-MD5-是不可逆的？" class="headerlink" title="为什么说 MD5 是不可逆的？"></a><a href="https://www.zhihu.com/question/22651987/answer/968239218">为什么说 MD5 是不可逆的？</a></h1>]]></content>
      <categories>
        <category>加密</category>
      </categories>
      <tags>
        <tag>加密</tag>
      </tags>
  </entry>
  <entry>
    <title>计算机浮点数存储</title>
    <url>/2022/10/13/%E6%B5%AE%E7%82%B9%E6%95%B0%E5%AD%98%E5%82%A8/</url>
    <content><![CDATA[<h1 id="IEEE-754标准的浮点数存储"><a href="#IEEE-754标准的浮点数存储" class="headerlink" title="IEEE 754标准的浮点数存储"></a>IEEE 754标准的浮点数存储</h1><p>事实上，在浮点数的存储过程中，为了运算方便和尽可能多的提高存储存储空间的利用效率，往往不会直接存储各部分的二进制原码。</p>
<p>例如，指数部分存储的是实际指数值得移码，而尾数部分存储的是规约化后的尾数的补码。</p>
<p>所谓移码，就是将实际的指数值加上一个固定的数值而得到的数。在单精度浮点数中这个数是127，在双精度浮点数中这个数是1024。假设这个数是e，则e的计算公式如下：</p>
<p>e&#x3D;2n−1−1<br>e&#x3D;2n−1−1<br>其中nn是指数部分的长度。</p>
<p>如此一来，即使是最小的指数（例如单精度浮点数是-126），在存储的时候也会存储为1（-126+127）。这样，就方便了指数的大小比较也省了一个符号位。</p>
<p>现在，上面的浮点数的计算公式就变成了下面的样子：</p>
<p><code>(−1)**sign*2**(exponent−e)*fraction2</code><br>(−1)sign×2exponent−e×fraction2<br>当然，这还不是计算公式的最终形态，因为我们还有尾数没有说。</p>
<p>刚刚在上面提到过定点数的表示其实就是在这里做一下铺垫。因为，尾数部分实际上存储的就是一个定点数。</p>
<p>这里的定点数需要时一个以1开头的二进制数并且小数点位于第一位数的后面。</p>
<p>拿(0.5)10(0.5)10来说，把它转换成二进制是(0.1)2&#x3D;(−1)0×(1.0)2×2−1(0.1)2&#x3D;(−1)0×(1.0)2×2−1<br>把指数部分用移码表示就是−1+127&#x3D;126−1+127&#x3D;126,所以，0.5的就存储为：</p>
<p>0 01111110 1000000000000000000000</p>
<p>现在我们又发现，既然尾数部分的定点数都是1开头，那就把这个1给省略掉好了。这样就又多出一位来保存尾数，提高精度了（当然，省略开头的第一个1后，默认小数点的位置就变成现在的第一位数之前了）。</p>
<p>于是乎，上面的0.5在实际存储中就变成了</p>
<p>0 01111110 0000000000000000000000</p>
<p>此时，最终形态的计算公式就是：</p>
<p><code>(−1)**sign*2**(exponent−e)*(fraction2+1)</code><br>(−1)sign×2exponent−e×(fraction2+1)<br>当指数部分为0，而尾数部分不为0（指数、尾数同时为0表示的当然是数字0）时，这个浮点数称为非规约形式浮点数。IEEE 754标准规定：非规约形式的浮点数的指数偏移值比规约形式的浮点数的指数偏移值大1。</p>
]]></content>
      <categories>
        <category>存储</category>
      </categories>
      <tags>
        <tag>浮点数存储</tag>
      </tags>
  </entry>
  <entry>
    <title>码制与位运算</title>
    <url>/2021/11/10/%E7%A0%81%E5%88%B6%E4%B8%8E%E4%BD%8D%E8%BF%90%E7%AE%97/</url>
    <content><![CDATA[<h3 id="二进制"><a href="#二进制" class="headerlink" title="二进制"></a>二进制</h3><p>0b00000001</p>
<h3 id="八进制"><a href="#八进制" class="headerlink" title="八进制"></a>八进制</h3><p>0o001(python)</p>
<h3 id="十六进制"><a href="#十六进制" class="headerlink" title="十六进制"></a>十六进制</h3><p>0xFE</p>
<h3 id="原码"><a href="#原码" class="headerlink" title="原码"></a>原码</h3><blockquote>
<p>将数字表述为二进制数，方便人看</p>
</blockquote>
<h3 id="反码"><a href="#反码" class="headerlink" title="反码"></a>反码</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">正数与原码相同</span><br><span class="line">负数符号位不变，其余位取反</span><br></pre></td></tr></table></figure>
<h3 id="补码"><a href="#补码" class="headerlink" title="补码"></a>补码</h3><figure class="highlight"><table><tr><td class="code"><pre><span class="line">正数与原码相同</span><br><span class="line">反码符号位不变其余位取反加一</span><br><span class="line">补码的补码是原码</span><br></pre></td></tr></table></figure>
<h3 id="浮点数存储方式"><a href="#浮点数存储方式" class="headerlink" title="浮点数存储方式"></a>浮点数存储方式</h3><h3 id="算术运算"><a href="#算术运算" class="headerlink" title="算术运算"></a>算术运算</h3><h3 id="比较运算符"><a href="#比较运算符" class="headerlink" title="比较运算符"></a>比较运算符</h3><h3 id="逻辑运算"><a href="#逻辑运算" class="headerlink" title="逻辑运算"></a>逻辑运算</h3><ul>
<li>&amp;&amp; </li>
<li>|| </li>
<li>！</li>
</ul>
<h3 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h3><ul>
<li>&amp; 乘法</li>
<li>| 加法</li>
<li>~ 取反 包括符号位</li>
<li>^ 异或</li>
<li>&gt;&gt; 右移</li>
<li>&lt;&lt; 左移</li>
</ul>
]]></content>
      <categories>
        <category>进制与编码</category>
      </categories>
      <tags>
        <tag>编码</tag>
        <tag>进制</tag>
      </tags>
  </entry>
  <entry>
    <title>网络线路</title>
    <url>/2022/09/16/%E7%BD%91%E7%BB%9C%E7%BA%BF%E8%B7%AF/</url>
    <content><![CDATA[<h1 id="租服务器时遇到的CN2，GIA，CIA，BGP以及IPLC都是什么意思？"><a href="#租服务器时遇到的CN2，GIA，CIA，BGP以及IPLC都是什么意思？" class="headerlink" title="租服务器时遇到的CN2，GIA，CIA，BGP以及IPLC都是什么意思？"></a><a href="https://zhuanlan.zhihu.com/p/356646013">租服务器时遇到的CN2，GIA，CIA，BGP以及IPLC都是什么意思？</a></h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/11/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E5%B8%B8%E7%94%A8%E7%9A%84%E5%8D%8F%E8%AE%AE/</url>
    <content><![CDATA[<p><a href="https://www.cfmem.com/2021/08/vmess-trojan-shadowsocks.html">科学上网常见协议解析 vmess, trojan, shadowsocks 内容解析</a></p>
]]></content>
  </entry>
  <entry>
    <title>视频编码</title>
    <url>/2022/09/16/%E8%A7%86%E9%A2%91%E7%BC%96%E7%A0%81/</url>
    <content><![CDATA[<h1 id="AV1-VS-HEVC-VS-VP9"><a href="#AV1-VS-HEVC-VS-VP9" class="headerlink" title="AV1 VS HEVC VS VP9"></a><a href="https://zhuanlan.zhihu.com/p/50665570">AV1 VS HEVC VS VP9</a></h1><h1 id="ffmpeg怎么实现视频的无损编码"><a href="#ffmpeg怎么实现视频的无损编码" class="headerlink" title="ffmpeg怎么实现视频的无损编码"></a><a href="https://www.zhihu.com/question/66694602/answer/2407223429">ffmpeg怎么实现视频的无损编码</a></h1>]]></content>
  </entry>
  <entry>
    <title></title>
    <url>/2024/01/11/%E8%B5%84%E8%AE%AF%E3%80%81%E5%8D%9A%E5%AE%A2%E8%AE%A2%E9%98%85/</url>
    <content><![CDATA[<h3 id="消息-资讯-订阅"><a href="#消息-资讯-订阅" class="headerlink" title="消息|资讯 订阅"></a>消息|资讯 订阅</h3><p><a href="https://sspai.com/post/57498">Tiny Tiny RSS 部署</a></p>
<hr>
<h3 id="多媒体-播客订阅服务"><a href="#多媒体-播客订阅服务" class="headerlink" title="多媒体 播客订阅服务"></a>多媒体 播客订阅服务</h3><p><a href="https://sspai.com/post/63610">Airsonic 部署</a></p>
]]></content>
  </entry>
  <entry>
    <title>数据库SQL语言</title>
    <url>/2022/07/14/database/MysqlSQL/</url>
    <content><![CDATA[<ol>
<li>DDL (Data Definition Language): 数据定义语言</li>
<li>DML (Data Manipulation Language)：数据操作语言</li>
<li>DCL (Data Control Language): 数据控制语言</li>
<li>DQL (Data Query Language): 数据查询语言</li>
</ol>
<ul>
<li>ddl：数据库或表的结构操作(****)</li>
<li>dml：对表的记录进行更新(增、删、改)(****)</li>
<li>dql：对表的记录的查询(****，难点)</li>
<li>dcl：对用户的创建及授权(****)</li>
</ul>
<h3 id="DDL"><a href="#DDL" class="headerlink" title="DDL"></a>DDL</h3><h4 id="一、数据库"><a href="#一、数据库" class="headerlink" title="一、数据库"></a>一、数据库</h4><ul>
<li><p>查看所有数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> DATABASES</span><br></pre></td></tr></table></figure>
</li>
<li><p>切换数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">USE DATABASENAME</span><br></pre></td></tr></table></figure>
</li>
<li><p>创建数据库：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> DATABASE IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span> MYDB CHARSET<span class="operator">=</span>utf8</span><br></pre></td></tr></table></figure>
</li>
<li><p>修改数据库：</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">AlTER</span> DATABASE MYDB CHARSET <span class="keyword">SET</span> utf8 </span><br></pre></td></tr></table></figure></li>
<li><p>删除数据库</p>
  <figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">drop</span> database MYDB</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h3><ul>
<li>int：整型;</li>
<li>double ：浮点型，例如double(5,2)表示最多5位，其中必须有2位小数，即最大值为999.99；</li>
<li>decimal：浮点型 ，在表单钱方面使用该类型，因为不会出现精度缺失问题；</li>
<li>char：固定长度字符串类型，char(255);</li>
<li>varchar: 可变字符串类型：varchar(65535);</li>
<li>text(clob):字符串类型；</li>
</ul>
<ol>
<li>tinytext 2^8-1 Byte</li>
<li>text 2^16-1 Byte</li>
<li>mediumtext 2^24-1 Byte</li>
<li>longtext 2^34-1 Byte</li>
</ol>
<ul>
<li>blob ：字节类型；</li>
</ul>
<ol>
<li>tinyblob 2^8-1 Byte</li>
<li>blob 2^16-1 Byte</li>
<li>mediumblob 2^24-1 Byte</li>
<li>longblob 2^34-1 Byte</li>
</ol>
<ul>
<li>date：日期类型，格式为：yyyy-MM-dd;</li>
<li>time: 时间类型 格式为：hh:mm:ss</li>
<li>timestamp: 时间戳类型；</li>
</ul>
<h4 id="二、表"><a href="#二、表" class="headerlink" title="二、表"></a>二、表</h4><ul>
<li>创建表：<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">TABLE</span> [IF <span class="keyword">NOT</span> <span class="keyword">EXISTS</span>] TABLENAME (cloumn01 type01,cloumn02 type02,cloumn03 type03);</span><br></pre></td></tr></table></figure></li>
<li>查看当前数据库中所有表名称：SHOW TABLES;</li>
<li>查看指定表的创建语句：SHOW CREATE TABLE 表名(了解)；</li>
<li>查看表结构：DESC 表名;</li>
<li>删除表结构：DROP TABLE 表名;</li>
<li>修改表：前缀：ALTER TABLE 表名;</li>
</ul>
<ol>
<li>修改之添加列：<br> AlTER TABLE 表名 ADD （<br> 列名 列类型，<br> 列名 列类型，<br> …<br> ）</li>
<li>修改列类型（如果被修改的列已存在数据，那么新的列类型可能会影响到已存在数据）：ALTER TABLE 表名 MODIFY 列名 列类型</li>
<li>修改列名：ALTER TABLE 表名 CHANGE 原列名 新列名 新类型</li>
<li>删除列：ALTER TABLE 表名 DROP 列名</li>
<li>修改表名称：ALTER TABLE 原表名 RENAME TO 新表名</li>
</ol>
<h3 id="DML"><a href="#DML" class="headerlink" title="DML"></a>DML</h3><ul>
<li>添加表记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">INSERT</span> <span class="keyword">INTO</span> tableName (c1,c2,c3)<span class="keyword">values</span>(v1,v2,v3);</span><br></pre></td></tr></table></figure></li>
<li>修改表记录<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">update</span> tableName <span class="keyword">set</span> c1 <span class="operator">=</span> v1,c2 <span class="operator">=</span> v2;</span><br><span class="line"><span class="keyword">update</span> tableName <span class="keyword">set</span> c1 <span class="operator">=</span> v1,c2 <span class="operator">=</span> v2 <span class="keyword">where</span> c3 <span class="operator">=</span> v3 <span class="keyword">or</span> c4 <span class="operator">=</span> v4;</span><br><span class="line"><span class="keyword">delete</span> <span class="operator">*</span> <span class="keyword">from</span> stu <span class="keyword">where</span> gender <span class="keyword">is</span> <span class="keyword">null</span>;</span><br></pre></td></tr></table></figure></li>
</ul>
<h3 id="DCL"><a href="#DCL" class="headerlink" title="DCL"></a>DCL</h3><ul>
<li>一个项目创建一个用户！一个项目对应的数据库只有一个！</li>
<li>这个用户只能对这个数据库有权限，其他数据库不能操作</li>
</ul>
<ol>
<li>创建用户</li>
</ol>
<ul>
<li>在指定的IP地址上登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> username<span class="variable">@IP</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>

<ul>
<li>在任意的IP地址上登录</li>
</ul>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">CREATE</span> <span class="keyword">USER</span> username@<span class="string">&#x27;%&#x27;</span> IDENTIFIED <span class="keyword">BY</span> <span class="string">&#x27;password&#x27;</span></span><br></pre></td></tr></table></figure>
<ol start="2">
<li>给用户授权<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="comment">-- 部分权限授权</span></span><br><span class="line"> <span class="keyword">GRANT</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">INSERT</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span>,<span class="keyword">SELECT</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> shawn<span class="variable">@IP</span></span><br><span class="line"><span class="comment">-- 所有权限授权</span></span><br><span class="line"><span class="keyword">GRANT</span> <span class="keyword">ALL</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">TO</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
<li>撤销授权<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">REVOKE</span> <span class="keyword">CREATE</span>,<span class="keyword">ALTER</span>,<span class="keyword">DROP</span>,<span class="keyword">UPDATE</span>,<span class="keyword">DELETE</span> <span class="keyword">ON</span> mydb.<span class="operator">*</span> <span class="keyword">FROM</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
<li>查看权限<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">SHOW</span> GRANTS <span class="keyword">FOR</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
<li>删除用户<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">DROP</span> <span class="keyword">USER</span> username<span class="variable">@IP</span></span><br></pre></td></tr></table></figure></li>
</ol>
<h3 id="DQL"><a href="#DQL" class="headerlink" title="DQL"></a>DQL</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">SELECT * FROM tableName;</span><br></pre></td></tr></table></figure>
<h3 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">IFNUll(c1,v1);</span><br><span class="line">DATE_FORMAT(&quot;yyyy-MM-dd&quot;,&#x27;%Y-%m-%d&#x27;);</span><br><span class="line">CONCAT(v1,v2,v3);</span><br><span class="line">distinct;</span><br><span class="line">-- &#x27;_&#x27;匹配一个字符</span><br><span class="line">-- &#x27;%&#x27;匹配零个到N个字符</span><br><span class="line">like &#x27;_%&#x27;;</span><br><span class="line">-- （当前页-1）* 每页记录数</span><br><span class="line">limit (17-1)*8,8</span><br></pre></td></tr></table></figure>

<h4 id="聚合函数"><a href="#聚合函数" class="headerlink" title="聚合函数"></a>聚合函数</h4><h4 id="联合查询"><a href="#联合查询" class="headerlink" title="联合查询"></a>联合查询</h4><h4 id="聚合函数-1"><a href="#聚合函数-1" class="headerlink" title="聚合函数"></a>聚合函数</h4>]]></content>
      <categories>
        <category>MySQL数据库</category>
      </categories>
      <tags>
        <tag>SQL</tag>
      </tags>
  </entry>
  <entry>
    <title>Mysql与MariaDB</title>
    <url>/2022/09/16/database/Mysql%E4%B8%8EMariaDB/</url>
    <content><![CDATA[<h1 id="MariaDB和MySQL全面对比"><a href="#MariaDB和MySQL全面对比" class="headerlink" title="MariaDB和MySQL全面对比"></a><a href="https://zhuanlan.zhihu.com/p/43993816">MariaDB和MySQL全面对比</a></h1>]]></content>
      <categories>
        <category>MariaDB</category>
      </categories>
      <tags>
        <tag>Mysql与MariaDB区别</tag>
      </tags>
  </entry>
  <entry>
    <title>docker学习大纲</title>
    <url>/2022/06/28/database/docker%E5%AD%A6%E4%B9%A0%E5%A4%A7%E7%BA%B2/</url>
    <content><![CDATA[<h3 id="Docker-network-（容器网络）"><a href="#Docker-network-（容器网络）" class="headerlink" title="Docker network （容器网络）"></a>Docker network （容器网络）</h3><h3 id="Docker-compose（容器编排）"><a href="#Docker-compose（容器编排）" class="headerlink" title="Docker compose（容器编排）"></a>Docker compose（容器编排）</h3><h3 id="Docker-Swarm（集群）"><a href="#Docker-Swarm（集群）" class="headerlink" title="Docker Swarm（集群）"></a>Docker Swarm（集群）</h3><h3 id="CI-CD-jenkins-流水线"><a href="#CI-CD-jenkins-流水线" class="headerlink" title="CI&#x2F;CD jenkins (流水线)"></a>CI&#x2F;CD jenkins (流水线)</h3><h3 id="ansible-自动化工具，部署"><a href="#ansible-自动化工具，部署" class="headerlink" title="ansible (自动化工具，部署)"></a><a href="http://ansible.com.cn/docs">ansible</a> (自动化工具，部署)</h3>]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker学习大纲</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装mysql</title>
    <url>/2022/07/15/database/docker%E5%AE%89%E8%A3%85mysql/</url>
    <content><![CDATA[<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"> docker run -d -p 3306:3306 \</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /opt/mysql/conf:/etc/mysql/conf.d \</span><br><span class="line">-v /opt/mysql/data:/var/lib/mysql \</span><br><span class="line">-v /opt/mysql/log:/var/log/mysql \</span><br><span class="line">-e MYSQL_ROOT_PASSWORD=123456 \</span><br><span class="line">--name mysql01 mysql:5.7 \</span><br><span class="line">--character-set-server=utf8mb4 \</span><br><span class="line">--collation-server=utf8mb4_unicode_ci</span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>mysql</tag>
      </tags>
  </entry>
  <entry>
    <title>docker安装oracle</title>
    <url>/2022/07/15/database/docker%E5%AE%89%E8%A3%85oracle/</url>
    <content><![CDATA[<h1 id="docker安装oracle"><a href="#docker安装oracle" class="headerlink" title="docker安装oracle"></a><a href="https://zhuanlan.zhihu.com/p/443324194">docker安装oracle</a></h1><h3 id="1、安装docker环境。"><a href="#1、安装docker环境。" class="headerlink" title="1、安装docker环境。"></a>1、安装docker环境。</h3><h3 id="2、开始拉取oracle镜像"><a href="#2、开始拉取oracle镜像" class="headerlink" title="2、开始拉取oracle镜像"></a>2、开始拉取oracle镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker pull registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure>

<h3 id="3、下载完成后，查看镜像"><a href="#3、下载完成后，查看镜像" class="headerlink" title="3、下载完成后，查看镜像"></a>3、下载完成后，查看镜像</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure>

<h3 id="4、创建容器"><a href="#4、创建容器" class="headerlink" title="4、创建容器"></a>4、创建容器</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker run -d -p 1521:1521 --name oracle11g registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br></pre></td></tr></table></figure>

<p>可以写成shell脚本，下次打开oracle数据库就可以一条命令创建容器。</p>
<p>shell脚本如下：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># BEGIN ANSIBLE MANAGED BLOCK</span></span><br><span class="line"><span class="comment">#!/bin/bash</span></span><br><span class="line">docker <span class="built_in">rm</span> -f oracle11;</span><br><span class="line">docker run -it -d -p 1521:1521</span><br><span class="line">--privileged=<span class="literal">true</span> \</span><br><span class="line">-v /opt/oracle/oradata/dbs:/home/oracle/app/oracle/product/11.2.0/dbhome_2/dbs \</span><br><span class="line">-v /opt/oracle/oradata:/home/oracle/app/oracle/oradata \</span><br><span class="line">-e ORACLE_PWD=helowin --name oracle11 registry.cn-hangzhou.aliyuncs.com/helowin/oracle_11g</span><br><span class="line"><span class="comment"># END ANSIBLE MANAGED BLOCK</span></span><br></pre></td></tr></table></figure>



<p><strong>但为了保存上一次容易的配置值，是不建议写这个shell脚本的，下次打开直接用docker start oracle11命令打开。</strong></p>
<p>如果创建成功能会返回容器id</p>
<h3 id="5、进入镜像进行配置"><a href="#5、进入镜像进行配置" class="headerlink" title="5、进入镜像进行配置"></a>5、进入镜像进行配置</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">docker <span class="built_in">exec</span> -it oracle11 bash</span><br></pre></td></tr></table></figure>

<h3 id="6、进行sql登录"><a href="#6、进行sql登录" class="headerlink" title="6、进行sql登录"></a>6、进行sql登录</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">sqlplus /nolog</span><br></pre></td></tr></table></figure>

<p>发现没有该命令，需要先配置环境变量，所以切换root用户。</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su root </span><br></pre></td></tr></table></figure>

<p>输入密码：helowin</p>
<h3 id="7、编辑profile文件配置ORACLE环境变量"><a href="#7、编辑profile文件配置ORACLE环境变量" class="headerlink" title="7、编辑profile文件配置ORACLE环境变量"></a>7、编辑profile文件配置ORACLE环境变量</h3><p>打开：vi &#x2F;etc&#x2F;profile ，在文件最后写上下面内容：</p>
<figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">export</span> ORACLE_HOME=/home/oracle/app/oracle/product/11.2.0/dbhome_2</span><br><span class="line"><span class="built_in">export</span> ORACLE_SID=helowin</span><br><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$ORACLE_HOME</span>/bin:<span class="variable">$PATH</span></span><br></pre></td></tr></table></figure>

<h3 id="8、保存后执行source-etc-profile-加载环境变量；"><a href="#8、保存后执行source-etc-profile-加载环境变量；" class="headerlink" title="8、保存后执行source /etc/profile 加载环境变量；"></a>8、保存后执行<code>source /etc/profile</code> 加载环境变量；</h3><h3 id="9、创建软连接"><a href="#9、创建软连接" class="headerlink" title="9、创建软连接"></a>9、创建软连接</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="built_in">ln</span> -s <span class="variable">$ORACLE_HOME</span>/bin/sqlplus /usr/bin</span><br></pre></td></tr></table></figure>

<h3 id="10、切换到oracle-用户"><a href="#10、切换到oracle-用户" class="headerlink" title="10、切换到oracle 用户"></a>10、切换到oracle 用户</h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">su - oracle</span><br></pre></td></tr></table></figure>



<p><em>这里还要说一下，一定要写中间的短横线 - 必须要，否则软连接无效</em></p>
<h3 id="11、登录sqlplus并修改sys、system用户密码"><a href="#11、登录sqlplus并修改sys、system用户密码" class="headerlink" title="11、登录sqlplus并修改sys、system用户密码"></a>11、登录sqlplus并修改sys、system用户密码</h3><figure class="highlight sql"><table><tr><td class="code"><pre><span class="line">sqlplus <span class="operator">/</span>nolog   <span class="comment">--登录</span></span><br><span class="line">conn <span class="operator">/</span><span class="keyword">as</span> sysdba  <span class="comment">--</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> <span class="keyword">system</span> identified <span class="keyword">by</span> <span class="keyword">system</span>;<span class="comment">--修改system用户账号密码；</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">user</span> sys identified <span class="keyword">by</span> <span class="keyword">system</span>;<span class="comment">--修改sys用户账号密码；</span></span><br><span class="line"><span class="keyword">create</span> <span class="keyword">user</span> test identified <span class="keyword">by</span> test; <span class="comment">-- 创建内部管理员账号密码；</span></span><br><span class="line"><span class="keyword">grant</span> <span class="keyword">connect</span>,resource,dba <span class="keyword">to</span> yan_test; <span class="comment">--将dba权限授权给内部管理员账号和密码；</span></span><br><span class="line"><span class="keyword">ALTER</span> PROFILE <span class="keyword">DEFAULT</span> LIMIT PASSWORD_LIFE_TIME UNLIMITED; <span class="comment">--修改密码规则策略为密码永不过期；（会出现坑，后面讲解）</span></span><br><span class="line"><span class="keyword">alter</span> <span class="keyword">system</span> <span class="keyword">set</span> processes<span class="operator">=</span><span class="number">1000</span> <span class="keyword">scope</span><span class="operator">=</span>spfile; <span class="comment">--修改数据库最大连接数据；</span></span><br></pre></td></tr></table></figure>

<h3 id="12、修改以上信息后，需要重新启动数据库；"><a href="#12、修改以上信息后，需要重新启动数据库；" class="headerlink" title="12、修改以上信息后，需要重新启动数据库；"></a>12、修改以上信息后，需要重新启动数据库；</h3><figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">conn /as sysdba</span><br><span class="line">shutdown immediate; --关闭数据库</span><br><span class="line">startup; --启动数据库</span><br><span class="line">exit：退出软链接</span><br></pre></td></tr></table></figure>

<hr>
<p>*<strong>上面提到的其中一个坑说明：*</strong></p>
<p>当执行修改密码的时候出现 ： database not open</p>
<p>提示数据库没有打开，不急按如下操作</p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database <span class="keyword">open</span>;</span><br></pre></td></tr></table></figure>

<p>注意了：这里也许还会提示 ： ORA-01507: database not mounted</p>
<p><strong>解决办法：</strong></p>
<p>输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">alter</span> database mount;</span><br></pre></td></tr></table></figure>

<p>输入 ：alter database open;</p>
<p>然后就可执行 修改数据库密码的命令了</p>
<p>改完之后输入：</p>
<figure class="highlight sql"><table><tr><td class="code"><pre><span class="line"><span class="keyword">ALTER</span> PROFILE <span class="keyword">DEFAULT</span> LIMIT PASSWORD_LIFE_TIME UNLIMITED;</span><br></pre></td></tr></table></figure>

<p><strong>刷新下表 exit 是退出sql 软连接</strong></p>
<h3 id="13、复制oracle的数据及配置"><a href="#13、复制oracle的数据及配置" class="headerlink" title="13、复制oracle的数据及配置"></a>13、复制oracle的数据及配置</h3><figure class="highlight python"><table><tr><td class="code"><pre><span class="line">sudo docker cp <span class="built_in">id</span>:/home/oracle/app/oracle /opt/oracle</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>数据库</category>
      </categories>
      <tags>
        <tag>oracle</tag>
      </tags>
  </entry>
  <entry>
    <title>docker的基本命令</title>
    <url>/2022/06/27/database/docker%E7%9A%84%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    <content><![CDATA[<h2 id="Docker的常用命令"><a href="#Docker的常用命令" class="headerlink" title="Docker的常用命令"></a>Docker的常用命令</h2><h3 id="一、帮助命令"><a href="#一、帮助命令" class="headerlink" title="一、帮助命令"></a>一、帮助命令</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker version # 显示docker的版本</span><br><span class="line">docker info </span><br><span class="line">docker 命令 --help # 万能命令</span><br></pre></td></tr></table></figure>

<h3 id="二、镜像命令"><a href="#二、镜像命令" class="headerlink" title="二、镜像命令"></a>二、镜像命令</h3><hr>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像</span></span><br><span class="line">docker images  # 列出所有镜像</span><br><span class="line">docker images -a</span><br><span class="line">docker images -aq # 只显示镜像id</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">搜索镜像</span></span><br><span class="line">docker search --filter=STARS=3000 #搜索镜像star大于3000</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">下载镜像</span></span><br><span class="line">docker pull 镜像[:tag] # 如果不写tag 默认是 latest</span><br><span class="line">[root@localhost ~]# docker pull mysql</span><br><span class="line">Using default tag: latest</span><br><span class="line">latest: Pulling from library/mysql</span><br><span class="line">72a69066d2fe: Pull complete  # 分层下载，docker image的核心 联合文件系统</span><br><span class="line">93619dbc5b36: Pull complete </span><br><span class="line">99da31dd6142: Pull complete </span><br><span class="line">626033c43d70: Pull complete </span><br><span class="line">37d5d7efb64e: Pull complete </span><br><span class="line">ac563158d721: Pull complete </span><br><span class="line">d2ba16033dad: Pull complete </span><br><span class="line">688ba7d5c01a: Pull complete </span><br><span class="line">00e060b6d11d: Pull complete </span><br><span class="line">1c04857f594f: Pull complete </span><br><span class="line">4d7cfa90e6ea: Pull complete </span><br><span class="line">e0431212d27d: Pull complete </span><br><span class="line">Digest: sha256:e9027fe4d91c0153429607251656806cc784e914937271037f7738bd5b8e7709 #签名</span><br><span class="line">Status: Downloaded newer image for mysql:latest</span><br><span class="line">docker.io/library/mysql:latest #真实地址</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">删除镜像</span></span><br><span class="line">docker rmi -f 容器id # 删除指定的镜像</span><br><span class="line">docker rmi -f 容器id 容器id 容器id # 删除多个的镜像</span><br><span class="line">docker rmi -f $(docker images -aq) # 删除全部镜像</span><br></pre></td></tr></table></figure>

<h3 id="三、容器命令"><a href="#三、容器命令" class="headerlink" title="三、容器命令"></a>三、容器命令</h3><h4 id="新建容器并启动"><a href="#新建容器并启动" class="headerlink" title="新建容器并启动"></a>新建容器并启动</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker run [可选参数] image</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">参数说明</span></span><br><span class="line">--name=&quot;Name&quot; 容器名字 tomcat01 tomcat02 用来区分容器</span><br><span class="line">-d 后台运行方式</span><br><span class="line">-it 使用交互式运行 进入容器查看内容</span><br><span class="line">-p 指定容器的端口 -p 8080:8080</span><br><span class="line">	—P 主机端口：容器端口 </span><br><span class="line">	-p 容器端口</span><br><span class="line">	容器端口</span><br><span class="line">-P 随机端口</span><br></pre></td></tr></table></figure>

<h4 id="列出所有的运行的容器"><a href="#列出所有的运行的容器" class="headerlink" title="列出所有的运行的容器"></a>列出所有的运行的容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker ps 命令</span></span><br><span class="line"><span class="meta prompt_">   # </span><span class="language-bash">列出当前正在运行的容器</span></span><br><span class="line">-a # 列出当前正在运行的容器+带历史运行过的容器</span><br><span class="line">-n=? # 最近创建过的容器</span><br><span class="line">-q # 只显示容器的编号</span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND   CREATED   STATUS    PORTS     NAMES</span><br><span class="line">[root@localhost ~]# docker ps -aq</span><br><span class="line">1a8af1ce6330</span><br><span class="line">[root@localhost ~]# docker ps -a</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND       CREATED          STATUS                            PORTS     NAMES</span><br><span class="line">1a8af1ce6330   centos    &quot;/bin/bash&quot;   12 minutes ago   Exited (127) About a minute ago             zealous_bartik</span><br></pre></td></tr></table></figure>

<h4 id="退出容器"><a href="#退出容器" class="headerlink" title="退出容器"></a>退出容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">exit #直接容器停止并退出</span><br><span class="line">Ctrl + P + Q #容器不停止退出</span><br></pre></td></tr></table></figure>

<h4 id="删除容器"><a href="#删除容器" class="headerlink" title="删除容器"></a>删除容器</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker rm 容器id       			# 删除指定容器</span><br><span class="line">docker rm -f $(docker ps -aq)	 # 删除全部容器</span><br><span class="line">docker ps -a -q|xargs docker run # 删除全部容器（linux命令）</span><br></pre></td></tr></table></figure>

<h4 id="启动和停止容器的操作"><a href="#启动和停止容器的操作" class="headerlink" title="启动和停止容器的操作"></a>启动和停止容器的操作</h4><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker start 容器id</span><br><span class="line">docker restart 容器id</span><br><span class="line">docker stop 容器id</span><br><span class="line">docker kill 容器id</span><br></pre></td></tr></table></figure>

<h3 id="四、常用其他命令"><a href="#四、常用其他命令" class="headerlink" title="四、常用其他命令"></a>四、常用其他命令</h3><h5 id="后台启动容器"><a href="#后台启动容器" class="headerlink" title="后台启动容器"></a>后台启动容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker run -d 镜像名</span></span><br><span class="line">[root@localhost ~]# docker run -d centos</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">问题docker ps ，发现 centos 停止了</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">常见的坑， docker 容器使用后台运行，就必须要有一个前台进程，docker 发现没有应用，就会自动停止</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">nginx 容器启动后，发现自己没有提供服务，就会立刻停止，就是没有程序了</span></span><br></pre></td></tr></table></figure>

<h5 id="查看日志"><a href="#查看日志" class="headerlink" title="查看日志"></a>查看日志</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker logs</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">自己编写一段shell脚本</span></span><br><span class="line">[root@localhost ~]# docker run -d centos /bin/sh -c &quot;while true; do echo test;sleep 1;done&quot;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看当前在运行的容器</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED          STATUS          PORTS     NAMES</span><br><span class="line">9916a0298bfd   centos    &quot;/bin/sh -c &#x27;while t…&quot;   19 seconds ago   Up 18 seconds             condescending_curie</span><br><span class="line">113e7bdad55e   centos    &quot;/bin/bash&quot;              12 minutes ago   Up 12 minutes             serene_pasteur</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">显示日志</span></span><br><span class="line">-tf </span><br><span class="line">--tail number # 要显示日志的条数</span><br><span class="line">[root@localhost ~]# docker logs -f -t --tail 10  113e7bdad55e</span><br></pre></td></tr></table></figure>

<h5 id="查看容器中进程信息"><a href="#查看容器中进程信息" class="headerlink" title="查看容器中进程信息"></a>查看容器中进程信息</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker top 容器<span class="built_in">id</span></span></span><br><span class="line">[root@localhost ~]# docker top 9916a0298bfd</span><br><span class="line">UID                 PID                 PPID                C                   STIME     </span><br><span class="line">root                180675              180655              0                   20:05      root                183113              180675              0                   20:44     </span><br></pre></td></tr></table></figure>

<h5 id="查看镜像的元数据"><a href="#查看镜像的元数据" class="headerlink" title="查看镜像的元数据"></a>查看镜像的元数据</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令 docker inspect 容器<span class="built_in">id</span></span></span><br><span class="line">[root@localhost ~]# docker inspect 9916a0298bfd </span><br><span class="line">[</span><br><span class="line">    &#123;</span><br><span class="line">        &quot;Id&quot;: &quot;9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0&quot;,</span><br><span class="line">        &quot;Created&quot;: &quot;2022-03-23T00:05:18.49632074Z&quot;,</span><br><span class="line">        &quot;Path&quot;: &quot;/bin/sh&quot;,</span><br><span class="line">        &quot;Args&quot;: [</span><br><span class="line">            &quot;-c&quot;,</span><br><span class="line">            &quot;while true; do echo test;sleep 1;done&quot;</span><br><span class="line">        ],</span><br><span class="line">        &quot;State&quot;: &#123;</span><br><span class="line">            &quot;Status&quot;: &quot;running&quot;,</span><br><span class="line">            &quot;Running&quot;: true,</span><br><span class="line">            &quot;Paused&quot;: false,</span><br><span class="line">            &quot;Restarting&quot;: false,</span><br><span class="line">            &quot;OOMKilled&quot;: false,</span><br><span class="line">            &quot;Dead&quot;: false,</span><br><span class="line">            &quot;Pid&quot;: 180675,</span><br><span class="line">            &quot;ExitCode&quot;: 0,</span><br><span class="line">            &quot;Error&quot;: &quot;&quot;,</span><br><span class="line">            &quot;StartedAt&quot;: &quot;2022-03-23T00:05:19.263635448Z&quot;,</span><br><span class="line">            &quot;FinishedAt&quot;: &quot;0001-01-01T00:00:00Z&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Image&quot;: &quot;sha256:5d0da3dc976460b72c77d94c8a1ad043720b0416bfc16c52c45d4847e53fadb6&quot;,</span><br><span class="line">        &quot;ResolvConfPath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/resolv.conf&quot;,</span><br><span class="line">        &quot;HostnamePath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/hostname&quot;,</span><br><span class="line">        &quot;HostsPath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/hosts&quot;,</span><br><span class="line">        &quot;LogPath&quot;: &quot;/var/lib/docker/containers/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0/9916a0298bfd3fb37d142bdd8bc056a5c943f8aa3c08bc7e1bb75081ee2a3ed0-json.log&quot;,</span><br><span class="line">        &quot;Name&quot;: &quot;/condescending_curie&quot;,</span><br><span class="line">        &quot;RestartCount&quot;: 0,</span><br><span class="line">        &quot;Driver&quot;: &quot;overlay2&quot;,</span><br><span class="line">        &quot;Platform&quot;: &quot;linux&quot;,</span><br><span class="line">        &quot;MountLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ProcessLabel&quot;: &quot;&quot;,</span><br><span class="line">        &quot;AppArmorProfile&quot;: &quot;&quot;,</span><br><span class="line">        &quot;ExecIDs&quot;: null,</span><br><span class="line">        &quot;HostConfig&quot;: &#123;</span><br><span class="line">            &quot;Binds&quot;: null,</span><br><span class="line">            &quot;ContainerIDFile&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LogConfig&quot;: &#123;</span><br><span class="line">                &quot;Type&quot;: &quot;json-file&quot;,</span><br><span class="line">                &quot;Config&quot;: &#123;&#125;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;NetworkMode&quot;: &quot;default&quot;,</span><br><span class="line">            &quot;PortBindings&quot;: &#123;&#125;,</span><br><span class="line">            &quot;RestartPolicy&quot;: &#123;</span><br><span class="line">                &quot;Name&quot;: &quot;no&quot;,</span><br><span class="line">                &quot;MaximumRetryCount&quot;: 0</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;AutoRemove&quot;: false,</span><br><span class="line">            &quot;VolumeDriver&quot;: &quot;&quot;,</span><br><span class="line">            &quot;VolumesFrom&quot;: null,</span><br><span class="line">            &quot;CapAdd&quot;: null,</span><br><span class="line">            &quot;CapDrop&quot;: null,</span><br><span class="line">            &quot;CgroupnsMode&quot;: &quot;host&quot;,</span><br><span class="line">            &quot;Dns&quot;: [],</span><br><span class="line">            &quot;DnsOptions&quot;: [],</span><br><span class="line">            &quot;DnsSearch&quot;: [],</span><br><span class="line">            &quot;ExtraHosts&quot;: null,</span><br><span class="line">            &quot;GroupAdd&quot;: null,</span><br><span class="line">            &quot;IpcMode&quot;: &quot;private&quot;,</span><br><span class="line">            &quot;Cgroup&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Links&quot;: null,</span><br><span class="line">            &quot;OomScoreAdj&quot;: 0,</span><br><span class="line">            &quot;PidMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Privileged&quot;: false,</span><br><span class="line">            &quot;PublishAllPorts&quot;: false,</span><br><span class="line">            &quot;ReadonlyRootfs&quot;: false,</span><br><span class="line">            &quot;SecurityOpt&quot;: null,</span><br><span class="line">            &quot;UTSMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;UsernsMode&quot;: &quot;&quot;,</span><br><span class="line">            &quot;ShmSize&quot;: 67108864,</span><br><span class="line">            &quot;Runtime&quot;: &quot;runc&quot;,</span><br><span class="line">            &quot;ConsoleSize&quot;: [</span><br><span class="line">                0,</span><br><span class="line">                0</span><br><span class="line">            ],</span><br><span class="line">            &quot;Isolation&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpuShares&quot;: 0,</span><br><span class="line">            &quot;Memory&quot;: 0,</span><br><span class="line">            &quot;NanoCpus&quot;: 0,</span><br><span class="line">            &quot;CgroupParent&quot;: &quot;&quot;,</span><br><span class="line">            &quot;BlkioWeight&quot;: 0,</span><br><span class="line">            &quot;BlkioWeightDevice&quot;: [],</span><br><span class="line">            &quot;BlkioDeviceReadBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteBps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceReadIOps&quot;: null,</span><br><span class="line">            &quot;BlkioDeviceWriteIOps&quot;: null,</span><br><span class="line">            &quot;CpuPeriod&quot;: 0,</span><br><span class="line">            &quot;CpuQuota&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimePeriod&quot;: 0,</span><br><span class="line">            &quot;CpuRealtimeRuntime&quot;: 0,</span><br><span class="line">            &quot;CpusetCpus&quot;: &quot;&quot;,</span><br><span class="line">            &quot;CpusetMems&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Devices&quot;: [],</span><br><span class="line">            &quot;DeviceCgroupRules&quot;: null,</span><br><span class="line">            &quot;DeviceRequests&quot;: null,</span><br><span class="line">            &quot;KernelMemory&quot;: 0,</span><br><span class="line">            &quot;KernelMemoryTCP&quot;: 0,</span><br><span class="line">            &quot;MemoryReservation&quot;: 0,</span><br><span class="line">            &quot;MemorySwap&quot;: 0,</span><br><span class="line">            &quot;MemorySwappiness&quot;: null,</span><br><span class="line">            &quot;OomKillDisable&quot;: false,</span><br><span class="line">            &quot;PidsLimit&quot;: null,</span><br><span class="line">            &quot;Ulimits&quot;: null,</span><br><span class="line">            &quot;CpuCount&quot;: 0,</span><br><span class="line">            &quot;CpuPercent&quot;: 0,</span><br><span class="line">            &quot;IOMaximumIOps&quot;: 0,</span><br><span class="line">            &quot;IOMaximumBandwidth&quot;: 0,</span><br><span class="line">            &quot;MaskedPaths&quot;: [</span><br><span class="line">                &quot;/proc/asound&quot;,</span><br><span class="line">                &quot;/proc/acpi&quot;,</span><br><span class="line">                &quot;/proc/kcore&quot;,</span><br><span class="line">                &quot;/proc/keys&quot;,</span><br><span class="line">                &quot;/proc/latency_stats&quot;,</span><br><span class="line">                &quot;/proc/timer_list&quot;,</span><br><span class="line">                &quot;/proc/timer_stats&quot;,</span><br><span class="line">                &quot;/proc/sched_debug&quot;,</span><br><span class="line">                &quot;/proc/scsi&quot;,</span><br><span class="line">                &quot;/sys/firmware&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;ReadonlyPaths&quot;: [</span><br><span class="line">                &quot;/proc/bus&quot;,</span><br><span class="line">                &quot;/proc/fs&quot;,</span><br><span class="line">                &quot;/proc/irq&quot;,</span><br><span class="line">                &quot;/proc/sys&quot;,</span><br><span class="line">                &quot;/proc/sysrq-trigger&quot;</span><br><span class="line">            ]</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;GraphDriver&quot;: &#123;</span><br><span class="line">            &quot;Data&quot;: &#123;</span><br><span class="line">                &quot;LowerDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3-init/diff:/var/lib/docker/overlay2/e75ba16da0fef020c7930a9b6190dbd33a83a8324702c144c689c5cd4e323146/diff&quot;,</span><br><span class="line">                &quot;MergedDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3/merged&quot;,</span><br><span class="line">                &quot;UpperDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3/diff&quot;,</span><br><span class="line">                &quot;WorkDir&quot;: &quot;/var/lib/docker/overlay2/2db2e17cdb47f8a05997664e4e31dc8f59b611e2d23388bc52b56c4407d27cc3/work&quot;</span><br><span class="line">            &#125;,</span><br><span class="line">            &quot;Name&quot;: &quot;overlay2&quot;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;Mounts&quot;: [],</span><br><span class="line">        &quot;Config&quot;: &#123;</span><br><span class="line">            &quot;Hostname&quot;: &quot;9916a0298bfd&quot;,</span><br><span class="line">            &quot;Domainname&quot;: &quot;&quot;,</span><br><span class="line">            &quot;User&quot;: &quot;&quot;,</span><br><span class="line">            &quot;AttachStdin&quot;: false,</span><br><span class="line">            &quot;AttachStdout&quot;: false,</span><br><span class="line">            &quot;AttachStderr&quot;: false,</span><br><span class="line">            &quot;Tty&quot;: false,</span><br><span class="line">            &quot;OpenStdin&quot;: false,</span><br><span class="line">            &quot;StdinOnce&quot;: false,</span><br><span class="line">            &quot;Env&quot;: [</span><br><span class="line">                &quot;PATH=/usr/local/sbin:/usr/local/bin:/usr/sbin:/usr/bin:/sbin:/bin&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Cmd&quot;: [</span><br><span class="line">                &quot;/bin/sh&quot;,</span><br><span class="line">                &quot;-c&quot;,</span><br><span class="line">                &quot;while true; do echo test;sleep 1;done&quot;</span><br><span class="line">            ],</span><br><span class="line">            &quot;Image&quot;: &quot;centos&quot;,</span><br><span class="line">            &quot;Volumes&quot;: null,</span><br><span class="line">            &quot;WorkingDir&quot;: &quot;&quot;,</span><br><span class="line">            &quot;Entrypoint&quot;: null,</span><br><span class="line">            &quot;OnBuild&quot;: null,</span><br><span class="line">            &quot;Labels&quot;: &#123;</span><br><span class="line">                &quot;org.label-schema.build-date&quot;: &quot;20210915&quot;,</span><br><span class="line">                &quot;org.label-schema.license&quot;: &quot;GPLv2&quot;,</span><br><span class="line">                &quot;org.label-schema.name&quot;: &quot;CentOS Base Image&quot;,</span><br><span class="line">                &quot;org.label-schema.schema-version&quot;: &quot;1.0&quot;,</span><br><span class="line">                &quot;org.label-schema.vendor&quot;: &quot;CentOS&quot;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        &quot;NetworkSettings&quot;: &#123;</span><br><span class="line">            &quot;Bridge&quot;: &quot;&quot;,</span><br><span class="line">            &quot;SandboxID&quot;: &quot;f28f51fd2c85ab7e8ba88827ec901c9ef4b517428747bd1cdf5196810db622c7&quot;,</span><br><span class="line">            &quot;HairpinMode&quot;: false,</span><br><span class="line">            &quot;LinkLocalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;LinkLocalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;Ports&quot;: &#123;&#125;,</span><br><span class="line">            &quot;SandboxKey&quot;: &quot;/var/run/docker/netns/f28f51fd2c85&quot;,</span><br><span class="line">            &quot;SecondaryIPAddresses&quot;: null,</span><br><span class="line">            &quot;SecondaryIPv6Addresses&quot;: null,</span><br><span class="line">            &quot;EndpointID&quot;: &quot;41b020afb72dc9602f5a030e56d816692170c2f0427377829da822e62976732a&quot;,</span><br><span class="line">            &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">            &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">            &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">            &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">            &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">            &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">            &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">            &quot;Networks&quot;: &#123;</span><br><span class="line">                &quot;bridge&quot;: &#123;</span><br><span class="line">                    &quot;IPAMConfig&quot;: null,</span><br><span class="line">                    &quot;Links&quot;: null,</span><br><span class="line">                    &quot;Aliases&quot;: null,</span><br><span class="line">                    &quot;NetworkID&quot;: &quot;d91d646c67beba9f1d4aa5cfa191bad1f24cf153ae1c6e3a37cf34599502a27f&quot;,</span><br><span class="line">                    &quot;EndpointID&quot;: &quot;41b020afb72dc9602f5a030e56d816692170c2f0427377829da822e62976732a&quot;,</span><br><span class="line">                    &quot;Gateway&quot;: &quot;172.17.0.1&quot;,</span><br><span class="line">                    &quot;IPAddress&quot;: &quot;172.17.0.3&quot;,</span><br><span class="line">                    &quot;IPPrefixLen&quot;: 16,</span><br><span class="line">                    &quot;IPv6Gateway&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6Address&quot;: &quot;&quot;,</span><br><span class="line">                    &quot;GlobalIPv6PrefixLen&quot;: 0,</span><br><span class="line">                    &quot;MacAddress&quot;: &quot;02:42:ac:11:00:03&quot;,</span><br><span class="line">                    &quot;DriverOpts&quot;: null</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">]</span><br></pre></td></tr></table></figure>

<h5 id="进入当前正在运行的容器"><a href="#进入当前正在运行的容器" class="headerlink" title="进入当前正在运行的容器"></a>进入当前正在运行的容器</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">我们通常容器都是使用后台方式运行的，需要进入容器，修改一些配置</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">命令</span></span><br><span class="line">docker exec -it 容器id bashShell</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE     COMMAND                  CREATED             STATUS             PORTS     NAMES</span><br><span class="line">9916a0298bfd   centos    &quot;/bin/sh -c &#x27;while t…&quot;   About an hour ago   Up About an hour             condescending_curie</span><br><span class="line">113e7bdad55e   centos    &quot;/bin/bash&quot;              About an hour ago   Up About an hour             serene_pasteur</span><br><span class="line">[root@localhost ~]# docker exec -it 9916a0298bfd /bin/bash</span><br><span class="line">[root@9916a0298bfd /]# ps -ef</span><br><span class="line">UID          PID    PPID  C STIME TTY          TIME CMD</span><br><span class="line">root           1       0  0 00:05 ?        00:00:01 /bin/sh -c while true; do echo test;sleep 1;done</span><br><span class="line">root        4061       0  0 01:12 pts/0    00:00:00 /bin/bash</span><br><span class="line">root        4088       1  0 01:12 ?        00:00:00 /usr/bin/coreutils --coreutils-prog-shebang=sleep /usr/bin/sleep 1</span><br><span class="line">root        4089    4061  0 01:12 pts/0    00:00:00 ps -ef</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">方式二</span></span><br><span class="line">docker attach 容器id</span><br><span class="line">正在执行当前的代码...</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker <span class="built_in">exec</span>     <span class="comment"># 进入容器后开启一个新的终端，可以在里面操作（常用）</span></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">docker attach	  <span class="comment"># 进入容器正在执行的终端，不会启动新的进程</span></span></span><br></pre></td></tr></table></figure>

<h5 id="从容器内烤贝文件到主机上"><a href="#从容器内烤贝文件到主机上" class="headerlink" title="从容器内烤贝文件到主机上"></a>从容器内烤贝文件到主机上</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"></span><br><span class="line">docker cp  b4bb1f3f7685:/home/test.java /home</span><br><span class="line"><span class="meta prompt_">#</span><span class="language-bash">进入docker容器内</span></span><br><span class="line">[root@b4bb1f3f7685 /]# cd /home</span><br><span class="line">[root@b4bb1f3f7685 home]# ls</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建java文件</span></span><br><span class="line">[root@b4bb1f3f7685 home]# touch test.java</span><br><span class="line">[root@b4bb1f3f7685 home]# ls</span><br><span class="line">test.java</span><br><span class="line">[root@b4bb1f3f7685 home]# exit</span><br><span class="line">exit</span><br><span class="line">docker cp 容器id:容器内部路径 目的的主路径</span><br><span class="line">[root@localhost home]# docker cp  b4bb1f3f7685:/home/test.java /home</span><br><span class="line">[root@localhost home]# ls</span><br><span class="line">shawn  test.java</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="五、安装服务器软件"><a href="#五、安装服务器软件" class="headerlink" title="五、安装服务器软件"></a>五、安装服务器软件</h3><h5 id="安装Tomcat"><a href="#安装Tomcat" class="headerlink" title="安装Tomcat"></a>安装Tomcat</h5><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line"><span class="comment"># 官方的使用</span></span><br><span class="line">docker run -it --<span class="built_in">rm</span> tomcat:9.0</span><br><span class="line"><span class="comment"># 我们之前的启动都是后台，停止了容器之后，容器还是可以查到 docker run -it --rm 一般用来测试，用完就删除</span></span><br><span class="line"><span class="comment">#下载在启动</span></span><br><span class="line">docker pull tomcat:9.0</span><br></pre></td></tr></table></figure>

<h5 id="安装es-kibana"><a href="#安装es-kibana" class="headerlink" title="安装es+kibana"></a>安装es+kibana</h5><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 暴露的端口很多</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 十分的耗内存</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 的数据一般需要放置到安全目录 挂载</span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">--net somenetwork 网路配置</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动 elasticsearch</span></span><br><span class="line">[root@localhost ~]# docker run -d --name elasticsearch01 -p 9200:9200 -p 9300:9300 -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">启动了 linux就卡住了 docker stats 查看cpu的状态</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">es 是十分耗内存的 1.xG   1核2G</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看 docker stats</span></span><br><span class="line"><span class="meta prompt_"></span></span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">测试一下es是否成功了</span></span><br><span class="line">[root@localhost ~]# curl localhost:9200</span><br><span class="line">&#123;</span><br><span class="line">  &quot;name&quot; : &quot;6620e2b536c4&quot;,</span><br><span class="line">  &quot;cluster_name&quot; : &quot;docker-cluster&quot;,</span><br><span class="line">  &quot;cluster_uuid&quot; : &quot;9i4LLjxvTVKf46Hp1qHkqA&quot;,</span><br><span class="line">  &quot;version&quot; : &#123;</span><br><span class="line">    &quot;number&quot; : &quot;7.6.2&quot;,</span><br><span class="line">    &quot;build_flavor&quot; : &quot;default&quot;,</span><br><span class="line">    &quot;build_type&quot; : &quot;docker&quot;,</span><br><span class="line">    &quot;build_hash&quot; : &quot;ef48eb35cf30adf4db14086e8aabd07ef6fb113f&quot;,</span><br><span class="line">    &quot;build_date&quot; : &quot;2020-03-26T06:34:37.794943Z&quot;,</span><br><span class="line">    &quot;build_snapshot&quot; : false,</span><br><span class="line">    &quot;lucene_version&quot; : &quot;8.4.0&quot;,</span><br><span class="line">    &quot;minimum_wire_compatibility_version&quot; : &quot;6.8.0&quot;,</span><br><span class="line">    &quot;minimum_index_compatibility_version&quot; : &quot;6.0.0-beta1&quot;</span><br><span class="line">  &#125;,</span><br><span class="line">  &quot;tagline&quot; : &quot;You Know, for Search&quot;</span><br><span class="line">&#125;</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">赶紧关闭，增加内存的限制,修改配置文件 -e 环境配置修改</span></span><br><span class="line">docker run -d --name elasticsearch02 -p 9200:9200 -p 9300:9300 -e ES_JAVA_OPTS=&quot;-Xms64m -Xmx512m&quot; -e &quot;discovery.type=single-node&quot; elasticsearch:7.6.2</span><br></pre></td></tr></table></figure>

<h5 id="可视化"><a href="#可视化" class="headerlink" title="可视化"></a>可视化</h5><blockquote>
<p>docker 图形化界面管理工具！提供一个后台供我们操作</p>
</blockquote>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">[root@localhost ~]# docker run -d -p 8090:9000 --restart=always -v /var/run/docker.sock:/var/run/docker.sock --privileged=true portainer/portainer</span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>docker的基本命令</tag>
      </tags>
  </entry>
  <entry>
    <title>docker镜像讲解</title>
    <url>/2022/06/28/database/docker%E9%95%9C%E5%83%8F%E8%AE%B2%E8%A7%A3/</url>
    <content><![CDATA[<h1 id="Docker镜像讲解"><a href="#Docker镜像讲解" class="headerlink" title="Docker镜像讲解"></a>Docker镜像讲解</h1><h2 id="镜像是什么"><a href="#镜像是什么" class="headerlink" title="镜像是什么"></a>镜像是什么</h2><ul>
<li>镜像是一种轻量级、可执行的独立软件包，用来打包软件运行环境和基于运行环境开发的软件，它包含运行某个软件所需的所有内容，包括代码，运行时，库、环境变量和配置文件。</li>
<li>所有的应用，直接打包docker镜像，就可以直接跑起来！</li>
<li>如何得到镜像：<ol>
<li>从远程仓库下载</li>
<li>朋友拷贝给你</li>
<li>自己制作一个镜像DockerFile</li>
</ol>
</li>
</ul>
<h2 id="Docker镜像加载原理"><a href="#Docker镜像加载原理" class="headerlink" title="Docker镜像加载原理"></a>Docker镜像加载原理</h2><blockquote>
<p>UnionsFS( 联合文件系统 Union Filesystem) )</p>
</blockquote>
<p>联合文件系统：union文件系统是一种分层、轻量级并且高性能的文件系统，它支持对文件系统的修改作为一次提交来一层层的叠加，同时可以将不同目录挂载到同一个虚拟文件系统下，union文件系统是docker镜像的基础。镜像可以通过分层来继承，基于基础镜像（没有父镜像），可以制作各种具体的应用镜像。</p>
<p>特性：一次同时加载多个文件系统，但在外面来看，只是看到一个文件系统，联合加载会把各层文件系统叠加，这样最终的文件系统会包含所有底层</p>
<p>的文件和目录</p>
<blockquote>
<p>Docker镜像加载原理</p>
</blockquote>
<p>docker镜像实际上由一层一层的文件系统组成，这种层级的文件系统UnionFS。</p>
<p>bootfs(boot file system)主要包含bootloader和kernel，bootloader主要引导加载kernel，Linux刚启动会加载bootfs文件系统，Docker镜像的最底层是bootfs。这一层与我们典型的Linux&#x2F;Unix系统是一样的，包含boot加载器和内核，当boot加载完成之后整个内核就在内存中了，此时内存的使用权已经由bootfs转交给内核，此时系统也会卸载bootfs。</p>
<p>rootfs（root file system），在bootfs之上。包含的就是典型linux系统中&#x2F;dev,&#x2F;proc,&#x2F;bin&#x2F;etc等标准目录和文件。rootfs就是各种不同的操作系统发行版，比如Ubuntu，Centos等等。</p>
<p><strong>虚拟机的Centos都是好几个G，为什么Docker这里才200M？</strong></p>
<p>对于精简的OS，rootfs可以很小，只需要包含最基本的命令，工具和程序库就可以了，因为底层直接用Host的kernel，自己只需要提供rootfs可以了。由此可见对于不同的linux发行版，bootfs基本是一致的，rootfs会有差别，因此不同发行版可以公用bootfs。。</p>
<p>虚拟机是分钟级，容器是秒级。</p>
<figure class="highlight shell"><table><tr><td class="code"><pre><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看镜像信息</span></span><br><span class="line">[root@localhost ~]# docker image inspect redis:latest</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>.分层理解</p>
</blockquote>
<p>Docker镜像都是只读的，当容器启动时，一个新的可写层被加载到镜像顶部！</p>
<p>这一层就是我们通常说的容器层，容器之下的都叫镜像层！</p>
<h2 id="commit镜像"><a href="#commit镜像" class="headerlink" title="commit镜像"></a>commit镜像</h2><figure class="highlight shell"><table><tr><td class="code"><pre><span class="line">docker commit 提交容器成为一个新的副本</span><br><span class="line">docker commit -m=&quot;提交的描述信息&quot; -a=&quot;作者&quot; 容器id 目标镜像名:[tag]</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">查看运行的容器</span></span><br><span class="line">[root@localhost ~]# docker ps</span><br><span class="line">CONTAINER ID   IMAGE                 COMMAND             CREATED        STATUS         PORTS                                       NAMES</span><br><span class="line">01f17edc0c92   tomcat                &quot;catalina.sh run&quot;   3 months ago   Up 5 minutes   0.0.0.0:8080-&gt;8080/tcp, :::8080-&gt;8080/tcp   tomcat01</span><br><span class="line"><span class="meta prompt_"># </span><span class="language-bash">创建自己的tomcat镜像</span></span><br><span class="line">[root@localhost ~]# docker commit -a=&quot;StephenShawn&quot; -m=&quot;add webapps&quot; 01f17edc0c92 tomcat01:0.1</span><br><span class="line">sha256:5da731531f9fea322cbf4cb2a971c5924672001746de2871171537faf4e6abe9</span><br><span class="line">[root@localhost ~]# docker images</span><br><span class="line">REPOSITORY            TAG       IMAGE ID       CREATED          SIZE</span><br><span class="line">tomcat01              0.1       5da731531f9f   14 seconds ago   684MB</span><br><span class="line">tomcat                9.0       b8e65a4d736d   6 months ago     680MB</span><br><span class="line">tomcat                latest    fb5657adc892   6 months ago     680MB</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

]]></content>
      <categories>
        <category>docker</category>
      </categories>
      <tags>
        <tag>dokcer镜像</tag>
      </tags>
  </entry>
  <entry>
    <title>Kubernetes</title>
    <url>/2022/07/17/database/kubernetes/</url>
    <content><![CDATA[<h1 id="Kubernetes镜像"><a href="#Kubernetes镜像" class="headerlink" title="Kubernetes镜像"></a>Kubernetes镜像</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>Kubernetes是一个开源系统，用于容器化应用的自动部署、扩缩和管理。它将构成应用的容器按逻辑单位进行分组以便于管理和发现。</p>
<p>下载地址：<a href="https://mirrors.aliyun.com/kubernetes/">https://mirrors.aliyun.com/kubernetes/</a></p>
<h2 id="配置方法"><a href="#配置方法" class="headerlink" title="配置方法"></a>配置方法</h2><h3 id="Debian-Ubuntu"><a href="#Debian-Ubuntu" class="headerlink" title="Debian &#x2F; Ubuntu"></a>Debian &#x2F; Ubuntu</h3><figure class="highlight vim"><table><tr><td class="code"><pre><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span> &amp;&amp; apt-<span class="built_in">get</span> install -<span class="keyword">y</span> apt-transport-https</span><br><span class="line">curl https://mirrors.aliyun.<span class="keyword">com</span>/kubernetes/apt/doc/apt-key.gpg | apt-key <span class="built_in">add</span> - </span><br><span class="line"><span class="keyword">cat</span> &lt;&lt;EOF &gt;/etc/apt/sources.<span class="keyword">list</span>.d/kubernetes.<span class="keyword">list</span></span><br><span class="line"><span class="keyword">deb</span> https://mirrors.aliyun.<span class="keyword">com</span>/kubernetes/apt/ kubernetes-xenial main</span><br><span class="line">EOF</span><br><span class="line">apt-<span class="built_in">get</span> <span class="keyword">update</span></span><br><span class="line">apt-<span class="built_in">get</span> install -<span class="keyword">y</span> kubelet kubeadm kubectl</span><br></pre></td></tr></table></figure>

<h3 id="CentOS-RHEL-Fedora"><a href="#CentOS-RHEL-Fedora" class="headerlink" title="CentOS &#x2F; RHEL &#x2F; Fedora"></a>CentOS &#x2F; RHEL &#x2F; Fedora</h3><figure class="highlight awk"><table><tr><td class="code"><pre><span class="line">cat &lt;&lt;EOF &gt; <span class="regexp">/etc/yum</span>.repos.d/kubernetes.repo</span><br><span class="line">[kubernetes]</span><br><span class="line">name=Kubernetes</span><br><span class="line">baseurl=https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/repos/</span>kubernetes-el7-x86_64/</span><br><span class="line">enabled=<span class="number">1</span></span><br><span class="line">gpgcheck=<span class="number">1</span></span><br><span class="line">repo_gpgcheck=<span class="number">1</span></span><br><span class="line">gpgkey=https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/yum</span>-key.gpg https:<span class="regexp">//mi</span>rrors.aliyun.com<span class="regexp">/kubernetes/yum</span><span class="regexp">/doc/</span>rpm-package-key.gpg</span><br><span class="line">EOF</span><br><span class="line">setenforce <span class="number">0</span></span><br><span class="line">yum install -y kubelet kubeadm kubectl</span><br><span class="line">systemctl enable kubelet &amp;&amp; systemctl start kubelet</span><br></pre></td></tr></table></figure>

<p>ps: 由于官网未开放同步方式, 可能会有索引gpg检查失败的情况, 这时请用 <code>yum install -y --nogpgcheck kubelet kubeadm kubectl</code> 安装</p>
<h2 id="相关链接"><a href="#相关链接" class="headerlink" title="相关链接"></a>相关链接</h2><ul>
<li>官方主页：<a href="https://kubernetes.io/">https://kubernetes.io/</a></li>
</ul>
]]></content>
      <categories>
        <category>container</category>
      </categories>
      <tags>
        <tag>kubernetes</tag>
      </tags>
  </entry>
</search>
